<!DOCTYPE html>
<html lang="fr">

<!-- Github-8.5-Vercel -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARÔME Analyse Statistique de jeux de loterie</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    

    <style>
        /* ============================================================================
   1. VARIABLES CSS MODE SOMBRE
   ============================================================================ */

        :root {
            /* Couleurs principales */
            --primary-color: #343a40;
            /* Couleur principale sombre */
            --highlight-color: rgba(15, 52, 96, 0.3);
            /* Couleur de surbrillance bleue transparente */
            --text-primary: #ced4da;
            /* Couleur du texte principal (blanc cassé) */
            --text-secondary: #fff;
            /* Couleur du texte secondaire (identique au principal) */
            --border-color: rgba(255, 255, 255, 0.1);
            /* Couleur des bordures (blanc très transparent) */

            /* Dimensions */
            --sidebar-width: 240px;
            /* Largeur de la barre latérale */
            --header-height: 86px;
            /* Hauteur de l'en-tête */

            /* Effets glass (verre dépoli) */
            --glass-bg: rgba(255, 255, 255, 0.1);
            /* Fond transparent pour effet verre */
            --glass-border: rgba(255, 255, 255, 0.2);
            /* Bordure transparente pour effet verre */
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            /* Ombre portée pour effet verre */
            --glass-blur: blur(10px);
            /* Effet de flou pour le fond */
        }

        /* ============================================================================
   2. RESET ET BASE MODE SOMBRE
   ============================================================================ */

        /* Réinitialisation des marges et paddings par défaut */
        * {
            margin: 0;
            /* Supprime les marges par défaut */
            padding: 0;
            /* Supprime les paddings par défaut */
            box-sizing: border-box;
            /* Inclut padding et border dans la largeur/hauteur */
        }

        /* Styles de base pour le corps de la page */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /* Polices avec fallback */
            background-color: var(--primary-color);
            /* Utilise la couleur principale */
            color: var(--text-primary);
            /* Utilise la couleur de texte principale */
            line-height: 1.1;
            /* Hauteur de ligne réduite */
            min-height: 100vh;
            /* Hauteur minimum = 100% de la hauteur de vue */
            display: flex;
            /* Utilise Flexbox pour la disposition */
        }

        /* ============================================================================
   3. LAYOUT PRINCIPAL
   ============================================================================ */

        /* Barre latérale */
        .sidebar {
            width: var(--sidebar-width);
            /* Largeur définie par variable */
            background-color: var(--primary-color);
            /* Fond avec couleur principale */
            border-right: 1px solid var(--border-color);
            /* Bordure droite fine */
            height: 100vh;
            /* Hauteur = 100% de la hauteur de vue */
            position: fixed;
            /* Position fixe pour rester visible au défilement */
            overflow-y: auto;
            /* Permet le défilement vertical si nécessaire */
            z-index: 100;
            /* Priorité d'affichage élevée */
        }

        /* Contenu principal */
        .main-content {
            margin-left: var(--sidebar-width);
            /* Marge gauche = largeur de la sidebar */
            flex: 1;
            /* Prend tout l'espace disponible restant */
            display: flex;
            /* Utilise Flexbox */
            flex-direction: column;
            /* Disposition en colonne */
            min-height: 100vh;
            /* Hauteur minimum = 100% de la hauteur de vue */
            max-width: 1400px;
            /* Largeur maximum fixe */
        }

        /* En-tête */
        .header {
            height: var(--header-height);
            /* Hauteur définie par variable */
            color: #fff;
            /* Fond avec couleur secondaire (non définie) */
            border-bottom: 0px solid var(--border-color);
            /* Bordure bas fine */
            display: flex;
            /* Utilise Flexbox */
            align-items: center;
            /* Centre verticalement les éléments */
            justify-content: center;
            /* ← Ajoute cette ligne pour centrer horizontalement */
            padding: 0 23px;
            /* Padding horizontal seulement */
            position: sticky !important;
            top: 0 !important;
            z-index: 90 !important;
            /* Position collante lors du défilement */
            top: 0;
            /* Collé en haut de la page */
            z-index: 90;
            /* Priorité d'affichage élevée */
            position: relative;
            /* ← Ajoute ça pour le positionnement de l'icône */
        }

        /* ===== STYLES PERSONNALISÉS POUR LES TITRES ===== */

        #appHeader {
            text-align: center;
            margin-bottom: 2px;
            padding: 1px;
        }

        #mainTitle {
            font-size: 1.4em;
            font-weight: 900;
            letter-spacing: 3px;
            margin-bottom: 1px;
        }

        #subTitle {
            font-size: 0.7em;
            font-weight: 400;
            letter-spacing: 1px;
            margin-top: 0;
        }

        /* Zone de contenu */
        .content {
            flex: 1;
            /* Prend tout l'espace disponible */
            padding: 15px;
            /* Padding interne */
            overflow-y: auto;
            /* Permet le défilement vertical */
        }

        /* ============================================================================
   4. NAVIGATION
   ============================================================================ */

        /* Logo */
        .logo {
            padding: 23px;
            /* Padding interne */
            border-bottom: 0px solid var(--border-color);
            /* Bordure bas invisible */
            text-align: center;
            /* Centre le texte */
        }

        /* Titre du logo */
        .logo h1 {
            font-size: 2.8rem;
            /* Taille de police très grande */
            font-weight: 700;
            /* Poids de police gras */
            color: #fff;
            /* Couleur de texte principale */
        }

        /* Sous-titre du logo */
        .logo p {
            font-size: 1rem;
            /* Taille de police normale */
            color: #fff;
            /* Couleur de texte secondaire */
            margin-top: 0px;
            /* Marge supérieure très fine */
        }

        /* Menu de navigation */
        .nav-menu {
            padding: 0;
            /* Supprime le padding par défaut */
        }

        /* Élément de navigation */
        .nav-item {
            display: flex;
            /* Utilise Flexbox */
            align-items: center;
            /* Centre verticalement les éléments */
            padding: 10px 10px;
            /* Padding interne */
            color: #fff;
            /* Couleur de texte secondaire */
            text-decoration: none;
            /* Supprime le soulignement */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
            border-left: 3px solid transparent;
            /* Bordure gauche transparente */
            cursor: pointer;
            margin: 5px 15px;
            border-radius: 8px;
            /* Dégradé de fond avec effet glass */

            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            /* Position relative pour les pseudo-éléments */
            overflow: hidden;
            /* Cache le débordement */
        }

        /* État au survol de l'élément de navigation */
        .nav-item:hover {
            /* Dégradé de fond plus visible au survol */
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.15) 0%,
                    rgba(255, 255, 255, 0.08) 100%);
            color: var(--text-secondary);
            /* Change la couleur du texte */
            border-color: rgba(255, 255, 255, 0.2);
            /* Change la couleur de la bordure */
            transform: translateX(5px);
            /* Déplace légèrement vers la droite */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            /* Ajoute une ombre portée */
        }

        /* État actif de l'élément de navigation */
        .nav-item.active {
            background-color: rgba(255, 255, 255, 0.04);
            /* Fond légèrement plus clair */
            color: var(--text-secondary);
            /* Couleur de texte principale */
            border-left-color: var(--highlight-color);
            /* Bordure gauche colorée */
        }

        /* Icônes dans les éléments de navigation */
        .nav-item i {
            margin-right: 10px;
            /* Marge à droite de l'icône */
            width: 20px;
            /* Largeur fixe */
            text-align: center;
            /* Centre l'icône */
        }

        /* Effet de brillant animé sur les éléments de navigation */
        .nav-item:before {
            content: '';
            /* Contenu vide */
            position: absolute;
            /* Position absolue par rapport à l'élément */
            top: 0;
            /* Alignement en haut */
            left: -100%;
            /* Position départ à gauche (hors de vue) */
            width: 100%;
            /* Largeur complète */
            height: 100%;
            /* Hauteur complète */
            /* Dégradé brillant */
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.1),
                    transparent);
            transition: left 0.5s ease;
            /* Transition douce pour la position */
        }

        /* ============================================================================
   5. COMPOSANTS RÉUTILISABLES
   ============================================================================ */

        .tab-content .section,
        .tab-content .control-group,
        .tab-content .info-box,
        .tab-content .success-box,
        .tab-content .stat-card,
        .tab-content .grid-selection,
        .tab-content .number-grid,
        .tab-content .chart-container,
        .tab-content .latest-draw,
        .tab-content .results,
        .tab-content .prediction-card,
        .tab-content .matrix-config,
        .tab-content .model-selection,
        .tab-content .advanced-settings,
        .tab-content .prediction-container,
        .tab-content .model-contributions,
        .tab-content .technical-metrics,
        .tab-content .results-grid,
        .tab-content .matrix-result-card,
        .tab-content .matrix-visualization,
        .tab-content .matrix-stats,
        .tab-content .math-explanations,
        .tab-content .math-section,
        .tab-content .checkbox-grid,
        .tab-content .settings-grid,
        .tab-content .matrix-actions,
        .tab-content .progress-container,
        .tab-content .loading {
            margin-bottom: 16px !important;

        }

        /* Sections */
        .section {
            background-color: var(--card-bg);
            /* Couleur de fond (non définie) */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            margin-bottom: 20px;
            /* Marge bas */
            padding: 20px;
            /* Padding interne */
            /* Dégradé de fond avec effet glass */
            background: linear-gradient(1deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(12px);
            /* Effet de flou d'arrière-plan */
            -webkit-backdrop-filter: blur(10px);
            /* Effet de flou pour Safari */
            border-radius: 10px;
            /* Coins arrondis */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            /* Ombre portée légère */
        }

        /* Titre de section niveau 2 */
        .section h2 {
            font-size: 1.7rem;
            /* Taille de police grande */
            margin-bottom: 20px;
            /* Marge bas */
            color: var(--text-secondary);
            /* Couleur de texte principale */
            font-weight: 400;
            /* Poids de police normal */
            border-bottom: 1px solid var(--border-color);
            /* Bordure bas fine */
            padding-bottom: 10px;
            /* Padding bas */
        }

        /* Titre de section niveau 3 */
        .section h3 {
            font-size: 1.2rem;
            /* Taille de police moyenne */
            margin: 0;
            /* Supprime les marges */
            color: var(--text-secondary);
            /* Couleur de texte principale */
            font-weight: 300;
            /* Poids de police normal */
        }

        /* Contenu des onglets */
        .tab-content {
            display: none;
            /* Masqué par défaut */
        }

        /* Contenu d'onglet actif */
        .tab-content.active {
            display: block;
            /* Affiché en bloc */
            animation: fadeIn 0.3s ease;
            /* Animation d'apparition */
        }

        /* Animation d'apparition en fondu */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            /* Début : complètement transparent */
            to {
                opacity: 1;
            }

            /* Fin : complètement opaque */
        }

        /* Cartes (statistiques, contrôles, informations) */
        .stat-card,
        .control-group,
        .info-box {
            /* Dégradé de fond avec effet glass */
            background: linear-gradient(1deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(12px);
            /* Effet de flou d'arrière-plan */
            -webkit-backdrop-filter: blur(10px);
            /* Effet de flou pour Safari */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            border-radius: 8px;
            /* Coins arrondis */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            /* Ombre portée légère */
            padding: 20px;
            /* Padding interne */
        }

        /* Carte de statistiques */
        .stat-card {
            color: var(--text-primary);
            /* Couleur de texte principale */
            margin: 10px 0;
            /* Marge verticale */
        }

        /* Titre de carte de statistiques */
        .stat-card h4 {
            font-size: 0.95rem;
            /* Taille de police petite */
            color: var(--text-secondary);
            /* Couleur de texte secondaire */
            margin-bottom: 5px;
            /* Marge bas réduite */
        }

        /* Valeur dans la carte de statistiques */
        .stat-card .value {
            font-size: 1.1rem;
            /* Taille de police légèrement agrandie */
            font-weight: 300;
            /* Poids de police léger */
        }

        /* Groupe de contrôles */
        .control-group {
            margin: 20px 0;
            /* Marge verticale */
        }

        /* Label des contrôles */
        .control-group label {
            font-size: 1rem;
            /* Taille de police normale */
            display: block;
            /* Affichage en bloc */
            margin-bottom: 8px;
            /* Marge bas */
            font-weight: 300;
            /* Poids de police normal */
            color: var(--text-secondary);
            /* Couleur de texte principale */
        }

        /* Boîte d'information */
        .info-box {
            margin: 0 0 25px 0;
            /* Marge bas seulement */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            /* Ombre portée légère */
        }

        /* Boîte de succès */
        .success-box {
            /* Même style que .section, .stat-card, .control-group, etc. */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin: 15px 0;
            color: var(--text-secondary);
        }

        /* Formulaires */
        input,
        select,
        button {
            padding: 10px 15px;
            /* Padding interne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            color: var(--text-secondary);
            /* Fond avec couleur principale */
            color: var(--text-primary);
            /* Couleur de texte principale */
            font-size: 0.95rem;
            /* Taille de police légèrement réduite */
            margin: 5px 5px 5px 0;
            /* Marge externe (sauf à gauche) */
            transition: all 0.2s ease;
            /* Transition douce pour toutes les propriétés */
        }

        /* États focus des champs de formulaire */
        input:focus,
        select:focus {
            outline: none;
            /* Supprime le contour par défaut */
            color: var(--text-secondary);
            /* Change la couleur de bordure */
            box-shadow: 0 0 0 2px rgba(15, 52, 96, 0.3);
            /* Ajoute un halo bleu */
        }

        /* Select avec effet glass */
        select {
            /* Dégradé de fond avec effet glass */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(10px);
            /* Effet de flou d'arrière-plan */
            -webkit-backdrop-filter: blur(10px);
            /* Effet de flou pour Safari */
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* Bordure fine transparente */
            border-radius: 8px;
            /* Coins arrondis */
            cursor: pointer;
            /* Curseur en forme de main */
            appearance: none;
            /* Supprime le style par défaut */
            -webkit-appearance: none;
            /* Supprime le style par défaut pour Webkit */
            -moz-appearance: none;
            /* Supprime le style par défaut pour Firefox */
            /* Icône de flèche personnalisée */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12' fill='none'%3E%3Cpath d='M3 5L6 8L9 5' stroke='%23f0f0f0' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            /* Empêche la répétition de l'icône */
            background-position: right 15px center;
            /* Position de l'icône */
            background-size: 12px;
            /* Taille de l'icône */
            padding-right: 40px;
            /* Padding droit pour faire de la place à l'icône */
        }

        /* État au survol du select */
        select:hover {
            /* Dégradé de fond plus visible au survol */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
            border-color: rgba(255, 255, 255, 0.3);
            /* Bordure plus visible */
            transform: translateY(-1px);
            /* Légère translation vers le haut */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            /* Ombre portée */
        }

        /* État focus du select */
        select:focus {
            border-color: rgba(255, 255, 255, 0.4);
            /* Bordure encore plus visible */
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
            /* Halo blanc */
        }

        /* Options du select */
        select option {
            background: var(--primary-color);
            /* Fond avec couleur principale */
            color: var(--text-primary);
            /* Couleur de texte principale */
            padding: 12px 15px;
            /* Padding interne */
        }

        /* État désactivé du select */
        select:disabled {
            opacity: 0.6;
            /* Réduit l'opacité */
            cursor: not-allowed;
            /* Curseur "non-autorisé" */
        }

        /* Boutons */
        button,
        .copy-btn {
            /* Dégradé de fond avec effet glass */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(10px);
            /* Effet de flou d'arrière-plan */
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            /* Bordure fine transparente (priorité) */
            border-radius: 8px;
            /* Coins arrondis */
            color: white;
            /* Couleur de texte blanc */
            cursor: pointer;
            /* Curseur en forme de main */
            font-weight: 300;
            /* Poids de police normal */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
        }

        /* État au survol des boutons */
        button:hover,
        .copy-btn:hover {
            /* Dégradé de fond plus visible au survol */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.15) 100%) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            /* Bordure plus visible */
            transform: translateY(-2px);
            /* Légère translation vers le haut */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            /* Ombre portée plus prononcée */
        }

        /* Bouton principal */
        .primary-btn {
            /* Dégradé de couleur violet */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 12px 24px;
            /* Padding interne */
            font-size: 1rem;
            /* Taille de police normale */
        }

        /* Bouton secondaire */
        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            /* Fond blanc transparent */
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* Bordure fine transparente */
            padding: 12px 20px;
            /* Padding interne */
        }

        /* Boules de numéros */
        .number-ball {
            width: 40px;
            /* Largeur fixe */
            height: 40px;
            /* Hauteur fixe (carré) */
            border-radius: 50%;
            /* Forme circulaire */
            display: flex;
            /* Utilise Flexbox */
            align-items: center;
            /* Centre verticalement */
            justify-content: center;
            /* Centre horizontalement */
            font-weight: bold;
            /* Poids de police gras */
            font-size: 1em;
            /* Taille de police normale */
            color: white;
            /* Couleur de texte blanc */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            /* Ombre portée légère */
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            /* Transitions douces */
        }

        /* État au survol des boules de numéros */
        .number-ball:hover {
            transform: scale(1.1);
            /* Agrandissement de 10% */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            /* Ombre portée plus prononcée */
        }

        /* Boule de numéro "chance" */
        .number-ball-chance {
            background: #1E3A5F;
            /* Fond bleu foncé */
        }

        /* Grilles */
        .grid-2 {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            /* Colonnes adaptatives */
            gap: 20px;
            /* Espacement entre les éléments */
        }

        /* Grille de numéros */
        .number-grid {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            /* Colonnes adaptatives */
            gap: 15px;
            /* Espacement entre les éléments */
            margin: 20px 0;
            /* Marge verticale */
        }

        /* Tableaux */
        table {
            width: 100%;
            /* Largeur complète */
            border-collapse: collapse;
            /* Fusion des bordures */
            margin: 20px 0;
            /* Marge verticale */
        }

        /* Cellules de tableau */
        th,
        td {
            padding: 12px;
            /* Padding interne */
            text-align: left;
            /* Alignement du texte à gauche */
            border-bottom: 0px solid var(--border-color);
            /* Pas de bordure bas */
        }

        /* En-têtes de tableau */
        th {
            background-color: var(--accent-color);
            /* Fond avec couleur d'accent (non définie) */
            color: var(--text-secondary);
            /* Couleur de texte principale */
            font-weight: 300;
            /* Poids de police normal */
        }

        /* Lignes de tableau au survol */
        tr:hover {
            background-color: rgba(255, 255, 255, 0.05);
            /* Fond légèrement plus clair */
        }

        /* ============================================================================
   6. EFFETS GLASS
============================================================================ */
        .glass-effect {
            background: var(--glass-bg);
            /* Fond verre */
            backdrop-filter: var(--glass-blur);
            /* Filtre d'arrière-plan */
            -webkit-backdrop-filter: var(--glass-blur);
            /* Filtre pour Safari */
            border: 1px solid var(--glass-border);
            /* Bordure verre */
            box-shadow: var(--glass-shadow);
            /* Ombre verre */
        }

        .glass-card {
            background: linear-gradient(1deg, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0.03) 100%);
            /* Dégradé verre */
            backdrop-filter: blur(12px);
            /* Flou arrière-plan */
            -webkit-backdrop-filter: blur(10px);
            /* Flou pour Safari */
            border: 1px solid rgba(255, 255, 255, 0.15);
            /* Bordure transparente */
            border-radius: 8px;
            /* Coins arrondis */
        }


        .latest-draw.glass-card {
            padding: 20px
                /* Marge interne importante */
        }

        .glass-nav {
            background: rgba(108, 117, 125, 0.7) !important;
            /* Fond navigation verre */
            backdrop-filter: blur(12px);
            /* Flou navigation */
            -webkit-backdrop-filter: blur(10px);
            /* Flou Safari navigation */
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            /* Bordure droite */
        }

        /* Sidebar avec effet glass */
        .sidebar {
            width: var(--sidebar-width);
            /* Largeur barre latérale */
            background-color: var(--primary-color);
            /* Fond barre latérale */
            border-right: 1px solid var(--border-color);
            /* Bordure droite */
            height: 100vh;
            /* Hauteur pleine fenêtre */
            position: fixed;
            /* Position fixe */
            overflow-y: auto;
            /* Défilement vertical */
            z-index: 100;
            /* Ordre d'empilement */
        }

        .main-content {
            margin-left: var(--sidebar-width);
            /* Marge gauche */
            flex: 1;
            /* Prend l'espace disponible */
            display: flex;
            /* Affichage flexible */
            flex-direction: column;
            /* Direction colonne */
            min-height: 100vh;
            /* Hauteur minimum fenêtre */
            max-width: 1400px;
            /* Largeur maximum */
        }

        /* Header glass */
        .header {
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* Boutons glass */
        button,
        .copy-btn {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.15) 0%,
                    rgba(255, 255, 255, 0.05) 100%) !important;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        button:hover,
        .copy-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.25) 0%,
                    rgba(255, 255, 255, 0.15) 100%) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--primary-color);
            color: var(--text-primary);
            line-height: 1.1;
            min-height: 100vh;
            display: flex;
        }

        /* ============================================================================
   7. GRILLES DE SÉLECTION
   ============================================================================ */

        /* Grille de sélection */
        .grid-selection {
            margin: 20px 0;
            /* Marge verticale */
        }

        /* Titre de grille */
        .grid-title {
            margin-bottom: 15px;
            /* Marge bas */
            font-weight: 300;
            /* Poids de police normal */
            color: var(--text-secondary);
            /* Couleur de texte principale */
            font-size: 1.1rem;
            /* Taille de police légèrement agrandie */
        }

        /* Grille de sélection de numéros */
        .number-grid-select {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(10, 1fr);
            /* 10 colonnes de largeur égale */
            gap: 15px;
            /* Espacement entre les éléments */
            margin-bottom: 20px;
            /* Marge bas */
            max-width: 40%;
            /* Largeur maximum = 40% du conteneur */
        }

        /* Boule de sélection de numéro */
        .number-ball-select {
            width: 40px;
            /* Largeur fixe */
            height: 40px;
            /* Hauteur fixe (carré) */
            border-radius: 50%;
            /* Forme circulaire */
            display: flex;
            /* Utilise Flexbox */
            align-items: center;
            /* Centre verticalement */
            justify-content: center;
            /* Centre horizontalement */
            font-weight: bold;
            /* Poids de police gras */
            font-size: 0.95rem;
            /* Taille de police légèrement réduite */
            color: white;
            /* Couleur de texte blanc */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            /* Ombre portée légère */
            cursor: pointer;
            /* Curseur en forme de main */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
            border: 2px solid transparent;
            /* Bordure transparente */
        }

        /* État au survol des boules de sélection */
        .number-ball-select:hover {
            transform: scale(1.1);
            /* Agrandissement de 10% */
        }

        /* État sélectionné des boules de sélection */
        .number-ball-select.selected {
            transform: scale(1.15);
            /* Agrandissement de 15% */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            /* Ombre portée prononcée */
            border: 2px solid #fff;
            /* Bordure blanche */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            /* Halo blanc */
        }

        /* Grille de sélection "chance" */
        .chance-grid-select {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(5, 1fr);
            /* 5 colonnes de largeur égale */
            gap: 15px;
            /* Espacement entre les éléments */
            max-width: 40px;
            /* Largeur maximum très étroite */
        }

        /* Boule de sélection "chance" */
        .number-ball-chance-select {
            border-radius: 50%;
            /* Forme circulaire */
            width: 41px;
            /* Largeur fixe */
            height: 41px;
            /* Hauteur fixe (carré) */
            display: flex;
            /* Utilise Flexbox */
            align-items: center;
            /* Centre verticalement */
            justify-content: center;
            /* Centre horizontalement */
            font-weight: bold;
            /* Poids de police gras */
            font-size: 0.95rem;
            /* Taille de police légèrement réduite */
            color: white;
            /* Couleur de texte blanc */
            background-color: var(--highlight-color);
            /* Fond avec couleur de surbrillance */
            cursor: pointer;
            /* Curseur en forme de main */
            transition: all 0.2s ease;
            /* Transition douce pour toutes les propriétés */
            border: 2px solid transparent;
            /* Bordure transparente */
        }

        /* État au survol des boules "chance" */
        .number-ball-chance-select:hover {
            transform: scale(1.05);
            /* Légère agrandissement */
        }

        /* État sélectionné des boules "chance" */
        .number-ball-chance-select.selected {
            background: #1E3A5F;
            /* Fond bleu foncé */
            transform: scale(1.1);
            /* Agrandissement de 10% */
            border: 2px solid #fff;
            /* Bordure blanche */
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            /* Halo blanc */
        }

        /* Numéros sélectionnés */
        .selected-numbers {
            margin: 20px 0;
            /* Marge verticale */
            padding: 15px;
            /* Padding interne */
            background-color: var(--accent-color);
            /* Fond avec couleur d'accent (non définie) */
            border: 1px solid var(--border-color);
            /* Bordure fine */
        }

        /* Affichage des numéros sélectionnés */
        .selected-numbers-display {
            display: flex;
            /* Utilise Flexbox */
            gap: 10px;
            /* Espacement entre les éléments */
            margin: 10px 0;
            /* Marge verticale */
            flex-wrap: wrap;
            /* Permet le retour à la ligne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            border-radius: 8px;
            padding: 10px;
        }

        /* Désactive les transformations sur l'affichage des numéros sélectionnés */
        .selected-numbers-display .number-ball,
        .selected-numbers-display .number-ball-chance {
            transform: none;
            /* Supprime les transformations */
        }

        /* Désactive les transformations au survol sur l'affichage des numéros sélectionnés */
        .selected-numbers-display .number-ball:hover,
        .selected-numbers-display .number-ball-chance:hover {
            transform: none;
            /* Supprime les transformations */
        }

        /* ============================================================================
   8. COMPOSANTS SPÉCIAUX
   ============================================================================ */

        /* Chargement */
        .loading {
            display: none;
            /* Masqué par défaut */
            text-align: center;
            /* Centre le texte */
            padding: 1px;
            /* Padding interne minimal */
            color: var(--text-secondary);
            /* Couleur de texte secondaire */
        }

        /* État actif du chargement */
        .loading.active {
            display: block;
            /* Affiché en bloc */
        }

        /* Conteneur de barre de progression */
        .progress-container {
            width: 100%;
            /* Largeur complète */
            max-width: 550px;
            /* Largeur maximum fixe */
            margin: 20px auto;
            /* Marge verticale et centrage horizontal */
            background: rgba(255, 255, 255, 0.1);
            /* Fond blanc transparent */
            border-radius: 8px;
            /* Coins arrondis */
            overflow: hidden;
            /* Cache le débordement */
            backdrop-filter: blur(10px);
            /* Effet de flou d'arrière-plan */
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* Bordure fine transparente */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            /* Ombre portée */
        }

        /* Barre de progression */
        .progress-bar {
            height: 12px;
            /* Hauteur fixe */
            /* Dégradé de couleur vert-bleu */
            background: linear-gradient(90deg, #1976d2 0%, #66bb6a 50%, #388e3c 100%);
            border-radius: 8px;
            /* Coins arrondis */
            width: 0%;
            /* Largeur initiale à 0 */
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            /* Transition fluide de la largeur */
            position: relative;
            /* Position relative pour les pseudo-éléments */
            overflow: hidden;
            /* Cache le débordement */
        }

        /* Effet de brillant animé sur la barre de progression */
        .progress-bar::after {
            content: '';
            /* Contenu vide */
            position: absolute;
            /* Position absolue par rapport à la barre */
            top: 0;
            /* Alignement en haut */
            left: -100%;
            /* Position départ à gauche (hors de vue) */
            width: 50%;
            /* Largeur de l'effet */
            height: 100%;
            /* Hauteur complète */
            /* Dégradé brillant */
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.4) 50%, transparent 100%);
            animation: shine 2s infinite;
            /* Animation infinie */
        }

        /* Animation de l'effet de brillant */
        @keyframes shine {
            0% {
                left: -100%;
            }

            /* Début : complètement à gauche */
            100% {
                left: 200%;
            }

            /* Fin : complètement à droite */
        }

        /* Texte de progression */
        .progress-text {
            margin-top: 15px;
            /* Marge supérieure */
            font-size: 1.1em;
            /* Taille de police légèrement agrandie */
            font-weight: 500;
            /* Poids de police moyen */
            color: #ffc107;
            /* Couleur jaune */
            animation: pulseText 2s infinite;
            /* Animation de pulsation infinie */
        }

        /* Animation de pulsation du texte */
        @keyframes pulseText {

            0%,
            100% {
                opacity: 1;
            }

            /* Début et fin : complètement opaque */
            50% {
                opacity: 0.7;
            }

            /* Milieu : légèrement transparent */
        }

        /* Statistiques de progression */
        .progress-stats {
            display: 3;
            /* Utilise Flexbox */
            justify-content: center;
            /* Centre horizontalement */
            margin-top: 10px;
            /* Marge supérieure */
            font-size: 0.9em;
            /* Taille de police réduite */
            color: #fff;
            /* Couleur de texte secondaire */
        }

        /* Pourcentage de progression */
        .progress-percentage {
            font-weight: bold;
            /* Poids de police gras */
            color: #667eea;
            /* Couleur bleue */
            font-size: 1.2em;
            /* Taille de police agrandie */
        }

        /* === Progress bar ML: center percentage text inside bar === */

        /* Conteneur de barre de progression pour ML */
        #mlLoading .progress-container {
            position: relative;
            /* Position relative pour le positionnement absolu enfant */
            width: 100%;
            /* Largeur complète */
            height: 18px;
            /* Hauteur fixe */
            background-color: rgba(255, 255, 255, 0.06);
            /* Fond blanc très transparent */
            border-radius: 12px;
            /* Coins très arrondis */
            overflow: hidden;
            /* Cache le débordement */
        }

        /* Barre de progression pour ML */
        #mlLoading .progress-bar {
            height: 100%;
            /* Hauteur complète du conteneur */
            width: 0%;
            /* Largeur initiale à 0 */
            border-radius: 12px;
            /* Coins très arrondis */
            transition: width 0.35s ease;
            /* Transition fluide de la largeur */
        }

        /* Pourcentage centré au milieu de la barre */

        #mlLoading .progress-percentage {
            position: absolute;
            /* Position absolue par rapport au conteneur */
            top: 50%;
            /* Position verticale au milieu */
            left: 50%;
            /* Position horizontale au milieu */
            transform: translate(-50%, -50%);
            /* Centrage parfait */
            color: #ffc107;
            /* Couleur jaune */
            font-weight: 600;
            /* Poids de police semi-gras */
            font-size: 0.95rem;
            /* Taille de police légèrement réduite */
            pointer-events: none;
            /* Désactive les interactions */
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.45);
            /* Ombre de texte pour meilleure lisibilité */
            white-space: nowrap;
            /* Empêche le retour à la ligne */
            z-index: 2;
            /* Priorité d'affichage */
        }

        /* Graphiques */
        .chart-container {
            position: relative;
            /* Position relative pour le positionnement absolu enfant */
            height: 400px;
            /* Hauteur fixe */
            margin: 20px 20;
            /* Marge verticale */
            background-color: var(--accent-color);
            /* Fond avec couleur d'accent (non définie) */
            padding: 20px;
            /* Padding interne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            border-radius: 8px;
            /* Coins arrondis */
        }

        /* Cartes de prédiction */
        .prediction-card {
            padding: 15px;
            /* Padding interne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            width: 31%;
            /* Largeur = environ 1/3 */
            min-height: 1px;
            /* Hauteur minimum très petite */
            display: inline-block;
            /* Affichage en ligne mais avec dimensions */
            margin: 1%;
            /* Marge de 1% tout autour */
            vertical-align: top;
            /* Alignement en haut */
            background-color: var(--card-bg);
            /* Fond avec couleur de carte (non définie) */
            border-radius: 8px;
            /* Coins arrondis */
        }

        /* Résultats */
        .results {
            margin-top: 20px;
            /* Marge supérieure */
            padding: 20px;
            /* Padding interne */
            color: var(--text-secondary);
            /* Fond avec couleur d'accent (non définie) */
            border-left: 4px solid var(--accent-color);
            /* Bordure gauche épaisse */
        }

        /* === Icône utilisateur === */
        #loginIcon {
            position: fixed;
            top: 25px;
            right: 25px;
            /* Réduit cette valeur */
            font-size: 1.6rem;
            cursor: pointer;
            color: #ddd;
            transition: color 0.3s ease, transform 0.2s ease;
            z-index: 1000;
        }

        #loginIcon:hover {
            color: var(--text-secondary);
            transform: translateY(-50%) scale(1.15);
        }

        /* === Overlay modale === */
        .modal-overlay {
            display: none;
            /* cachée par défaut */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(6px);
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        /* === Fenêtre modale === */
        .modal-content {
            position: relative;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 25px 30px;
            width: 320px;
            color: #fff;
            text-align: left;
            animation: fadeIn 0.3s ease forwards;
        }

        .modal-content h2 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        /* === Bouton fermeture === */
        .close-btn {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: #bbb;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .close-btn:hover {
            color: #fff;
        }

        /* === Formulaire === */
        #loginForm label {
            display: block;
            font-size: 0.9rem;
            margin-top: 12px;
            margin-bottom: 4px;
        }

        #loginForm input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            border: none;
            outline: none;
            font-size: 0.9rem;
            color: #222;
        }

        .login-btn {
            width: 100%;
            margin-top: 18px;
            padding: 10px;
            background: linear-gradient(90deg, #3f8cff, #00bcd4);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .login-btn:hover {
            background: linear-gradient(90deg, #00bcd4, #3f8cff);
        }

        .forgot-link {
            display: block;
            text-align: center;
            margin-top: 10px;
            font-size: 0.85rem;
            color: #aaa;
            text-decoration: none;
        }

        .forgot-link:hover {
            color: var(--text-secondary);
        }

        /* === Animation === */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-15px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
  
         /* Style pour l'encre universelle */

         .floating-top-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            border-radius: 8px;
            padding: 25px 3px;
            color: var(--text-secondary);
            font-weight: 400;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            cursor: pointer;
            border: none;
            font-family: inherit;
            /* Paramètre ajouté pour empêcher le débordement */
            max-width: calc(100vw - 40px);
             
             max-width: 55px;
            /* Largeur maximum fixe */
        }

        .floating-top-button.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .floating-top-button:hover {
            background: rgba(76, 175, 80, 0.3);
            transform: translateY(-2px);
        }

        /* Bouton Haut de page */
        #floatingOngletButton {
            bottom: 26px;
        
        }

        /* Styles pour la coloration syntaxique JavaScript */
        .code-block {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 8px;
         padding: 20px;
            font-family: 'Courier New', monospace;
         font-size: 0.9em;
         overflow-x: auto;
         line-height: 1.5;
        }

        /* Couleurs pour JavaScript */
            .code-keyword { color: #569cd6; }        /* const, let, function */
            .code-string { color: #ce9178; }         /* Chaînes de caractères */
            .code-number { color: #b5cea8; }         /* Nombres */
            .code-comment { color: #6a9955; }        /* Commentaires */
            .code-property { color: #9cdcfe; }       /* Propriétés d'objets */
            .code-operator { color: #d4d4d4; }       /* Opérateurs */
            .code-bracket { color: #ffd700; }        /* Crochets, parenthèses */
            .code-function { color: #dcdcaa; }       /* Noms de fonctions */

        /* ============================================================================
   9. STYLES SPÉCIFIQUES ONGLET MATRICE
   ============================================================================ */

        /* === STYLES MATRICE === */

        /* Grille de cases à cocher */
        .checkbox-grid {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            /* Colonnes adaptatives */
            gap: 12px;
            /* Espacement entre les éléments */
        }

        /* Élément de case à cocher */
        .checkbox-item {
            display: flex;
            /* Utilise Flexbox */
            align-items: flex-start;
            /* Alignement en haut */
            padding: 12px;
            /* Padding interne */
            background: rgba(255, 255, 255, 0.03);
            /* Fond blanc très transparent */
            border-radius: 8px;
            /* Coins arrondis */
            cursor: pointer;
            /* Curseur en forme de main */
        }

        /* Information du modèle */
        .model-info {
            font-size: 0.85rem;
            /* Taille de police réduite */
            color: #fff;
            /* Couleur de texte secondaire */
            margin-top: 4px;
            /* Marge supérieure fine */
            opacity: 0.8;
            /* Légère transparence */
        }

        /* Configuration de la matrice */
        .matrix-config {
            display: grid;
            /* Utilise CSS Grid */
            gap: 25px;
            /* Grand espacement entre les éléments */
            margin-bottom: 25px;
            /* Marge bas */
        }

        /* Sélection de modèle */
        .model-selection {
            background: rgba(255, 255, 255, 0.05);
            /* Fond blanc transparent */
            padding: 20px;
            /* Padding interne */
            border-radius: 8px;
            /* Coins arrondis */
        }

        /* Grille de paramètres */
        .settings-grid {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            /* Colonnes adaptatives */
            gap: 15px;
            /* Espacement entre les éléments */
        }

        /* Actions de la matrice */
        .matrix-actions {
            display: flex;
            /* Utilise Flexbox */
            gap: 15px;
            /* Espacement entre les éléments */
            margin-top: 20px;
            /* Marge supérieure */
            flex-wrap: wrap;
            /* Permet le retour à la ligne */
        }

        /* Configuration matrice */

        .checkbox-grid {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            /* Colonnes adaptatives */
            gap: 12px;
            /* Espacement entre les éléments */
        }

        .checkbox-item {
            display: flex;
            /* Utilise Flexbox */
            align-items: flex-start;
            /* Alignement en haut */
            padding: 12px;
            /* Padding interne */
            background: rgba(255, 255, 255, 0.03);
            /* Fond blanc très transparent */
            border-radius: 8px;
            /* Coins arrondis */
            cursor: pointer;
            /* Curseur en forme de main */
        }

        /* Masque les cases à cocher par défaut */
        .checkbox-item input[type="checkbox"] {
            display: none;
            /* Masque l'élément */
        }

        /* Case à cocher personnalisée */
        .checkmark {
            position: relative;
            /* Position relative pour les pseudo-éléments */
            display: inline-block;
            /* Affichage en ligne avec dimensions */
            width: 18px;
            /* Largeur fixe */
            height: 18px;
            /* Hauteur fixe (carré) */
            background: rgba(255, 255, 255, 0.1);
            /* Fond blanc transparent */
            border: 2px solid rgba(255, 255, 255, 0.3);
            /* Bordure blanche transparente */
            border-radius: 4px;
            /* Coins légèrement arrondis */
            margin-right: 10px;
            /* Marge à droite */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
        }

        /* État coché de la case à cocher personnalisée */
        .checkbox-item input[type="checkbox"]:checked+.checkmark {
            background: var(--accent-color);
            /* Fond avec couleur d'accent (non définie) */
            border-color: var(--accent-color);
            /* Bordure avec couleur d'accent */
        }

        /* Coche à l'intérieur de la case */
        .checkmark:after {
            content: "";
            /* Contenu vide */
            position: absolute;
            /* Position absolue par rapport à la case */
            display: none;
            /* Masqué par défaut */
            left: 5px;
            /* Position depuis la gauche */
            top: 2px;
            /* Position depuis le haut */
            width: 4px;
            /* Largeur de la coche */
            height: 8px;
            /* Hauteur de la coche */
            border: solid white;
            /* Bordure blanche */
            border-width: 0 2px 2px 0;
            /* Bordures seulement en bas et à droite */
            transform: rotate(45deg);
            /* Rotation de 45 degrés */
        }

        /* Affiche la coche quand la case est cochée */
        .checkbox-item input[type="checkbox"]:checked+.checkmark:after {
            display: block;
            /* Affiche l'élément */
        }

        .model-info {
            font-size: 0.85rem;
            /* Taille de police réduite */
            color: #fff;
            /* Couleur de texte secondaire */
            margin-top: 4px;
            /* Marge supérieure fine */
            opacity: 0.8;
            /* Légère transparence */
        }

        /* Paramètres avancés */
        .advanced-settings {
            background: rgba(255, 255, 255, 0.03);
            /* Fond blanc très transparent */
            padding: 20px;
            /* Padding interne */
            border-radius: 8px;
            /* Coins arrondis */
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Bordure fine transparente */
        }

        .settings-grid {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            /* Colonnes adaptatives */
            gap: 15px;
            /* Espacement entre les éléments */
        }

        /* Élément de paramètre */
        .setting-item {
            display: flex;
            /* Utilise Flexbox */
            flex-direction: column;
            /* Disposition en colonne */
            gap: 8px;
            /* Espacement entre les éléments enfants */
        }

        /* Label des paramètres */
        .setting-item label {
            font-size: 0.9rem;
            /* Taille de police réduite */
            color: #fff;
            /* Couleur de texte secondaire */
        }

        .matrix-actions {
            display: flex;
            /* Utilise Flexbox */
            gap: 15px;
            /* Espacement entre les éléments */
            margin-top: 20px;
            /* Marge supérieure */
            flex-wrap: wrap;
            /* Permet le retour à la ligne */
        }

        /* Prédictions matrice en grille 3x2 */

        #matrice .prediction-container {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(3, 1fr);
            /* 3 colonnes de largeur égale */
            gap: 15px;
            /* Espacement entre les éléments */
            margin-top: 15px;
            /* Marge supérieure */
        }

        #matrice .prediction-item {
            padding: 15px;
            /* Padding interne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            background-color: var(--card-bg);
            /* Fond avec couleur de carte (non définie) */
            border-radius: 8px;
            /* Coins arrondis */
            display: flex;
            /* Utilise Flexbox */
            flex-direction: column;
            /* Disposition en colonne */
            align-items: center;
            /* Centre horizontalement */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
        }

        /* État au survol des éléments de prédiction */
        #matrice .prediction-item:hover {
            transform: translateY(-2px);
            /* Légère translation vers le haut */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            /* Ombre portée */
            border-color: rgba(255, 255, 255, 0.3);
            /* Bordure plus visible */
        }

        /* Titre des éléments de prédiction */
        #matrice .prediction-item h5 {
            margin: 0 0 15px 0;
            /* Marge bas seulement */
            font-size: 1rem;
            /* Taille de police normale */
            color: var(--text-secondary);
            /* Couleur de texte principale */
            text-align: center;
            /* Centre le texte */
            font-weight: 300;
            /* Poids de police moyen */
        }

        /* Affichage des numéros dans les prédictions */
        #matrice .prediction-item .selected-numbers-display {
            display: flex;
            /* Utilise Flexbox */
            gap: 8px;
            /* Petit espacement entre les éléments */
            flex-wrap: wrap;
            /* Permet le retour à la ligne */
            justify-content: center;
            /* Centre horizontalement */
            margin: 5px 0;
            /* Marge verticale réduite */
            align-items: center;
            /* Centre verticalement */
        }

        /* Confiance de prédiction */
        #matrice .prediction-confidence {
            margin-top: 10px;
            /* Marge supérieure */
            text-align: center;
            /* Centre le texte */
        }

        /* Texte de confiance de prédiction */
        #matrice .prediction-confidence small {
            font-size: 0.8rem;
            /* Taille de police réduite */
            color: #fff;
            /* Couleur de texte secondaire */
            background: rgba(255, 255, 255, 0.1);
            /* Fond blanc transparent */
            padding: 4px 10px;
            /* Padding interne */
            border-radius: 8px;
            /* Coins très arrondis */
            font-weight: 300;
            /* Poids de police moyen */
        }

        /* Performances des modèles en grille 3x2 */

        #matrice .model-contributions {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(3, 1fr);
            /* 3 colonnes de largeur égale */
            gap: 15px;
            /* Espacement entre les éléments */
            margin-top: 15px;
            /* Marge supérieure */
        }

        #matrice .contribution-item {
            padding: 15px;
            /* Padding interne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            background-color: var(--card-bg);
            /* Fond avec couleur de carte (non définie) */
            border-radius: 8px;
            /* Coins arrondis */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
        }

        /* État au survol des éléments de contribution */
        #matrice .contribution-item:hover {
            transform: translateY(-2px);
            /* Légère translation vers le haut */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            /* Ombre portée */
            border-color: rgba(255, 255, 255, 0.3);
            /* Bordure plus visible */
        }

        /* Barre de performance */
        #matrice .performance-bar {
            position: relative;
            /* Position relative pour le positionnement absolu enfant */
            height: 20px;
            /* Hauteur fixe */
            background: rgba(255, 255, 255, 0.1);
            /* Fond blanc transparent */
            border-radius: 10px;
            /* Coins très arrondis */
            margin: 8px 0;
            /* Marge verticale */
            overflow: hidden;
            /* Cache le débordement */
        }

        /* Remplissage de la barre de performance */
        #matrice .performance-fill {
            height: 100%;
            /* Hauteur complète */
            /* Dégradé de vert */
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 10px;
            /* Coins très arrondis */
            transition: width 0.5s ease;
            /* Transition fluide de la largeur */
        }

        /* Texte de performance */
        #matrice .performance-text {
            position: absolute;
            /* Position absolue par rapport à la barre */
            top: 50%;
            /* Position verticale au milieu */
            left: 10px;
            /* Position horizontale depuis la gauche */
            transform: translateY(-50%);
            /* Centrage vertical */
            color: white;
            /* Couleur de texte blanc */
            font-size: 0.8rem;
            /* Taille de police réduite */
            font-weight: bold;
            /* Poids de police gras */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            /* Ombre de texte pour meilleure lisibilité */
        }

        /* Métriques techniques en grille 2x2 */

        #matrice .technical-metrics {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(2, 1fr);
            /* 2 colonnes de largeur égale */
            gap: 20px;
            /* Espacement entre les éléments */
            margin-top: 20px;
            /* Marge supérieure */
        }

        #matrice .metric-item {
            padding: 20px;
            /* Padding interne */
            border: 1px solid var(--border-color);
            /* Bordure fine */
            background: var(--card-bg);
            /* Fond avec couleur de carte (non définie) */
            border-radius: 10px;
            /* Coins arrondis */
            display: flex;
            /* Utilise Flexbox */
            justify-content: space-between;
            /* Répartit l'espace entre les éléments */
            align-items: center;
            /* Centre verticalement */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
            min-height: 21px;
            /* Hauteur minimum */
        }

        /* État au survol des métriques */
        #matrice .metric-item:hover {
            transform: translateY(-3px);
            /* Légère translation vers le haut */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            /* Ombre portée prononcée */
            border-color: rgba(255, 255, 255, 0.4);
            /* Bordure plus visible */
        }

        /* Label des métriques */
        #matrice .metric-item span:first-child {
            color: var(--text-primary);
            /* Couleur de texte principale */
            font-weight: 500;
            /* Poids de police moyen */
        }

        /* Valeur des métriques */
        #matrice .metric-value {
            font-weight: bold;
            /* Poids de police gras */
            color: var(--accent-color);
            /* Couleur d'accent (non définie) */
            font-size: 1.1rem;
            /* Taille de police légèrement agrandie */
            background: rgba(255, 255, 255, 0.1);
            /* Fond blanc transparent */
            padding: 4px 12px;
            /* Padding interne */
            border-radius: 6px;
            /* Coins arrondis */
        }

        /* Résultats matrice */

        .results-grid {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            /* Colonnes adaptatives */
            gap: 20px;
            /* Espacement entre les éléments */
            margin-top: 20px;
            /* Marge supérieure */
        }

        .matrix-result-card {
            background: rgba(255, 255, 255, 0.05);
            /* Fond blanc transparent */
            padding: 20px;
            /* Padding interne */
            border-radius: 8px;
            /* Coins arrondis */
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Bordure fine transparente */
            height: fit-content;
            /* Hauteur adaptée au contenu */
            min-height: 1px;
            /* Hauteur minimum très petite */
        }

        .prediction-item {
            margin-bottom: 15px;
            /* Marge bas */
            padding: 12px;
            /* Padding interne */
            background: rgba(255, 255, 255, 0.03);
            /* Fond blanc très transparent */
            border-radius: 8px;
            /* Coins arrondis */
        }

        .prediction-item h5 {
            margin-bottom: 10px;
            /* Marge bas */
            color: var(--text-secondary);
            /* Couleur de texte principale */
        }

        .matrix-visualization {
            margin: 25px 0;
            /* Marge verticale */
        }

        .matrix-stats {
            display: grid;
            /* Utilise CSS Grid */
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            /* Colonnes adaptatives */
            gap: 15px;
            /* Espacement entre les éléments */
            margin-top: 20px;
            /* Marge supérieure */
        }

        .math-explanations {
            margin-top: 30px;
            /* Marge supérieure importante */
        }

        .math-section {
            margin-bottom: 25px;
            /* Marge bas importante */
            padding-bottom: 20px;
            /* Padding bas */
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            /* Bordure bas fine transparente */
        }

        .math-section:last-child {
            border-bottom: none;
            /* Supprime la bordure pour le dernier élément */
        }

        .math-formula {
            text-align: center;
            /* Centre le texte */
            margin: 15px 0;
            /* Marge verticale */
            padding: 15px;
            /* Padding interne */
            background: rgba(255, 255, 255, 0.03);
            /* Fond blanc très transparent */
            border-radius: 8px;
            /* Coins arrondis */
            font-family: 'MathJax_Math', 'Times New Roman', serif;
            /* Polices pour formules mathématiques */
        }

        .matrix-notification {
            animation: slideInRight 0.3s ease;
            /* Animation d'entrée depuis la droite */
        }

        /* Animation d'entrée depuis la droite */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                /* Début : complètement à droite (hors de vue) */
                opacity: 0;
                /* Début : complètement transparent */
            }

            to {
                transform: translateX(0);
                /* Fin : position normale */
                opacity: 1;
                /* Fin : complètement opaque */
            }
        }


        /* ============================================================================
   9.A STYLES SPÉCIFIQUES ONGLET PROGRAMME
   ============================================================================ */

        a {
            color: #4da3ff;
            text-decoration: none;
        }

        a:hover {
            color: #66b3ff;
            text-decoration: underline;
        }

        code {
            background: rgba(0, 0, 0, 0.3);
            color: #4da3ff;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        pre {
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }

        ul,
        ol {
            margin: 15px 0 15px 25px;
        }

        li {
            margin: 8px 0;
        }


        /* ============================================================================
   10. AJUSTEMENTS DE TYPOGRAPHIE PAR ONGLET
   ============================================================================ */

        /* Overview */
        #overview .section h2 {
            font-size: 1.7rem;
            font-weight: 400;
        }

        /* Titre grand */
        #overview .section p {
            font-size: 1.05rem;
            margin-bottom: 30px;
            font-weight: 300;

        }

        /* Paragraphe légèrement agrandi avec marge bas */
        #overview .stat-card .value {
            font-size: 1.1rem;
        }

        /* Valeur légèrement agrandie */
        #overview .info-box li {
            font-size: 0.92rem;
        }

        /* Éléments de liste légèrement réduits */
        #overview .section button {
            margin: 1px 0 0 0;
            width: auto;
        }

        /* Bouton avec marge spécifique et largeur automatique */

        /* Frequencies */
        #frequencies .section h2 {
            font-size: 1.7rem;
            font-weight: 400;
        }

        /* Titre grand */
        #frequencies .section p {
            font-size: 1.15rem;
            margin-bottom: 20px;
            font-weight: 300;
        }

        /* Paragraphe agrandi avec marge bas */
        #frequencies .info-box p {
            font-size: 1rem;
            font-weight: 200;
        }

        /* Paragraphe normal */
        #frequencies .control-group {
            margin: 0 0 20px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Groupe de contrôle avec marge et padding spécifiques */
        #frequencies .section select,
        #frequencies .section button {
            margin: 0 10px 10px 0;
            font-weight: 200;
        }

        /* Select et bouton avec marge spécifique */
        #frequencies .chart-container {
            margin: 0 0 20px 0;
        }

        /* Conteneur de graphique avec marge bas */
        #freqResults {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Résultats avec marge verticale */
        #frequencies .info-box {
            margin: 0 0 20px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Boîte d'info avec marge et padding spécifiques */

        /* Predictions */
        #predictions .section h2 {
            font-size: 1.7rem;
            font-weight: 400;
        }

        /* Titre grand */
        #predictions .section p {
            font-size: 1.05rem;
            margin-bottom: 20px;
            font-weight: 200;
        }

        /* Paragraphe légèrement agrandi avec marge bas */
        #predictions .info-box p {
            font-size: 1rem;
            font-weight: 200;
        }

        /* Paragraphe normal */
        #predictionExplanations {
            font-size: 0.95rem;
            margin: 20px 0;
            font-weight: 200;
        }

        /* Explications légèrement réduites avec marge verticale */
        #predictions .control-group {
            margin: 0 0 20px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Groupe de contrôle avec marge et padding spécifiques */
        #predictions .section select,
        #predictions .section input,
        #predictions .section button {
            margin: 0 0 10px 0;
            font-weight: 200;
        }

        /* Champs de formulaire avec marge bas */
        #predLoading {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Chargement avec marge verticale */
        #predResults {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Résultats avec marge verticale */
        #predictions .info-box {
            margin: 0 0 25px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Boîte d'info avec marge bas importante et padding */

        /* Machine Learning */
        #ml .section h2 {
            font-size: 1.7rem;
            margin-bottom: 20px;
            font-weight: 400;
        }

        /* Titre grand avec marge bas */
        #ml .section p {
            font-size: 1.05rem;
            margin-bottom: 15px;
            font-weight: 200;

        }

        /* Paragraphe légèrement agrandi avec marge bas importante */
        #ml .info-box p {
            font-size: 0.95rem;
            font-weight: 200;
        }

        /* Paragraphe légèrement réduit */
        #mlExplanationContent p {
            font-size: 0.95rem;
            font-weight: 200;
        }

        /* Contenu d'explication légèrement réduit */
        #ml .info-box {
            margin: 0 0 20px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Boîte d'info avec marge bas et padding */
        #mlExplanationContent {
            margin-bottom: 20px;
            font-weight: 200;
        }

        /* Contenu d'explication avec marge bas */
        #ml .control-group {
            margin: 1px 1px 1px px;
            padding: 20px;
            font-weight: 200;
        }

        /* Groupe de contrôle avec marges et padding spécifiques */
        #mlModel {
            margin: 0 px 0 0;
            font-weight: 200;
        }

        /* Modèle avec marge droite (valeur invalide) */
        #ml .control-group div {
            margin: 1px 0;
            padding: 1px;
            font-weight: 200;
        }

        /* Div dans groupe de contrôle avec marges et padding minimaux */
        #ml .control-group button {
            margin: 0;
            font-weight: 200;
        }

        /* Bouton sans marge */
        #mlLoading {
            margin: 0;
        }

        /* Chargement sans marge */
        #mlMetrics {
            gap: 20px;
            margin: 0;
        }

        /* Métriques avec espacement et sans marge */
        #mlResults {
            margin: 20px 0;
        }

        /* Résultats avec marge verticale */
        #ml .chart-container {
            margin: 0;
        }

        /* Conteneur de graphique sans marge */

        /* Étapes d'explication ML */
        .ml-explanation-steps {
            line-height: 1.2;
            /* Hauteur de ligne réduite */
        }

        .ml-explanation-steps ol {
            margin-left: 20px;
            /* Marge gauche pour la numérotation */
            margin-bottom: 1px;
            /* Marge bas minimale */
        }

        .ml-explanation-steps li {
            margin-bottom: 5px;
            /* Marge bas entre les éléments de liste */
        }

        .ml-explanation-steps ul {
            margin-left: 15px;
            /* Marge gauche pour les sous-listes */
            margin-top: 5px;
            /* Marge supérieure fine */
            margin-bottom: 10px;
            /* Marge bas */
        }

        .ml-explanation-steps strong {
            color: var(--text-primary);
            /* Texte en gras avec couleur principale */
        }

        .ml-explanation-steps h5 {
            color: var(--accent-color);
            /* Titre avec couleur d'accent (non définie) */
            margin-bottom: 15px;
            /* Marge bas */
            border-bottom: 1px solid var(--border-color);
            /* Bordure bas fine */
            padding-bottom: 10px;
            /* Padding bas */
        }

        /* Clusters */
        #clusters .section h2 {
            font-size: 1.7rem;
            margin-bottom: 20px;
            font-weight: 400;
        }

        /* Titre grand avec marge bas */
        #clusters .section p {
            font-size: 1.05rem;
            margin-bottom: 20px;
            font-weight: 300;
        }

        /* Paragraphe légèrement agrandi avec marge bas */
        #clusters .info-box p {
            font-size: 0.95rem;
            font-weight: 200;
        }

        /* Paragraphe légèrement réduit */
        #clusters .control-group {
            margin: 0 0 20px 0;
            padding: 20px;
            font-weight: 300;
        }

        /* Groupe de contrôle avec marge bas et padding */
        #clusters .section input,
        #clusters .section button {
            margin: 1px 10px 1px 0;
            font-weight: 200;
        }

        /* Champs avec marges spécifiques */
        #clusters .chart-container {
            margin: 0 0 20px 0;
            font-weight: 200;
        }

        /* Conteneur de graphique avec marge bas */
        #clusterResults {
            margin: 20px 0;
            font-weight: 300;
        }

        /* Résultats avec marge verticale */
        #clusters .info-box {
            margin: 0 0 25px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Boîte d'info avec marge bas importante et padding */

        /* Statistics */
        #statistics .section h2 {
            font-size: 1.7rem;
            margin-bottom: 20px;
            font-weight: 400;
        }

        /* Titre grand avec marge bas */
        #statistics .section p {
            font-size: 1.05rem;
            margin-bottom: 1px;
            font-weight: 300;
        }

        /* Paragraphe légèrement agrandi avec marge bas minimale */
        #statistics .control-group {
            margin: 0 0 25px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Groupe de contrôle avec marge bas importante et padding */
        #statistics .section select,
        #statistics .section button {
            margin: 0 10px 10px 0;
            font-weight: 200;
        }

        /* Select et bouton avec marge spécifique */
        #statistics .chart-container {
            margin: 0 0 1px 0;
        }

        /* Conteneur de graphique avec marge bas minimale */
        #statResults {
            margin: 20px 0;
        }

        /* Résultats avec marge verticale */

        /* Evaluation */
        #evaluation .section h2 {
            font-size: 1.7rem;
            margin-bottom: 20px;
            font-weight: 400;
        }

        /* Titre grand avec marge bas */
        #evaluation .section p {
            font-size: 1.05rem;
            margin-bottom: 20px;
            font-weight: 300;
        }

        /* Paragraphe légèrement agrandi avec marge bas */
        #evaluation .info-box p {
            font-size: 0.95rem;
            font-weight: 200;
        }

        /* Paragraphe légèrement réduit */
        #evaluation .grid-title {
            font-size: 1.1rem;
            font-weight: 200;
        }

        /* Titre de grille légèrement agrandi */
        #evaluation .control-group {
            margin: 0 0 25px 0;
            padding: 20px;
            font-weight: 300;
        }

        /* Groupe de contrôle avec marge bas importante et padding */
        #evaluation .grid-selection {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Sélection de grille avec marge verticale */
        #evaluation .number-grid-select,
        #evaluation .chance-grid-select {
            margin: 0 0 20px 0;
            font-weight: 300;
        }

        /* Grilles avec marge bas */
        #evaluation .selected-numbers {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Numéros sélectionnés avec marge verticale */
        #evaluation .section button {
            margin: 0 10px 10px 0;
            font-weight: 200;
        }

        /* Bouton avec marge spécifique */
        #evaluation .chart-container {
            margin: 0 0 25px 0;
        }

        /* Conteneur de graphique avec marge bas importante */
        #evalResults {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Résultats avec marge verticale */

        /* Simulation */
        #simulation .section h2 {
            font-size: 1.7rem;
            margin-bottom: 20px;
            font-weight: 400;
        }

        /* Titre grand avec marge bas */
        #simulation .section p {
            font-size: 1.05rem;
            margin-bottom: 20px;
            font-weight: 300;
        }

        /* Paragraphe légèrement agrandi avec marge bas */
        #simulation .info-box p {
            font-size: 0.95rem;
            font-weight: 200;
        }

        /* Paragraphe légèrement réduit */
        #simulation .grid-title {
            font-size: 1.1rem;
            font-weight: 200;
        }

        /* Titre de grille légèrement agrandi */
        #simulation .control-group {
            margin: 0 0 25px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Groupe de contrôle avec marge bas importante et padding */
        #simulation .grid-selection {
            margin: 1px 0;
            font-weight: 200;
        }

        /* Sélection de grille avec marge verticale minimale */
        #simulation .number-grid-select,
        #simulation .chance-grid-select {
            margin: 0 0 20px 0;
            font-weight: 200;
        }

        /* Grilles avec marge bas */
        #simulation .selected-numbers {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Numéros sélectionnés avec marge verticale */
        #simulation .section input,
        #simulation .section button {
            margin: 0 10px 10px 0;
        }

        /* Champs avec marge spécifique */
        #simLoading {
            margin: 20px 0;
        }

        /* Chargement avec marge verticale */
        #simulation .chart-container {
            margin: 0 0 25px 0;
        }

        /* Conteneur de graphique avec marge bas importante */
        #simMetrics {
            gap: 20px;
            margin: 0 0 25px 0;
            font-weight: 200;
        }

        /* Métriques avec espacement et marge bas importante */
        #simResults {
            margin: 20px 0;
            font-weight: 200;
        }

        /* Résultats avec marge verticale */
        #simulation .info-box {
            margin: 0 0 25px 0;
            padding: 20px;
            font-weight: 200;
        }

        /* Boîte d'info avec marge bas importante et padding */

        /* Programme */
        #programme .section h2 {
            font-size: 1.7rem;
            margin-bottom: 1;
        }

        /* Titre grand avec marge bas (valeur invalide) */
        #programme .section p {
            font-size: 1.05rem;
            margin-bottom: 25px;
        }

        /* Paragraphe légèrement agrandi avec marge bas importante */
        #programme h3 {
            font-size: 1.4rem;
            margin: 25px 0 15px 0;
        }

        /* Sous-titre agrandi avec marges verticales */
        #programme .control-group {
            margin: 0 0 25px 0;
            padding: 20px;
        }

        /* Groupe de contrôle avec marge bas importante et padding */
        #programme .section select {
            margin: 0 10px 15px 0;
        }

        /* Select avec marge spécifique */
        #programme .code-actions {
            gap: 10px;
            margin: 15px 0;
        }

        /* Actions de code avec espacement et marge verticale */
        #programme .code-container {
            margin: 20px 0;
        }

        /* Conteneur de code avec marge verticale */
        #programme .info-box {
            margin: 0 0 25px 0;
            padding: 20px;
        }

        /* Boîte d'info avec marge bas importante et padding */

        /* ============================================================================
   11. COMPOSANTS SUPPLÉMENTAIRES
   ============================================================================ */

        /* Dernier tirage */
        .latest-draw {
            margin: 0 0 20px 0;
            /* Marge bas seulement */
            padding: 20;
            /* padding idem effet glass */
            font-weight: 400;
            color: #fff;

        }

        /* Options de période */
        .period-options {
            display: flex;
            /* Utilise Flexbox */
            gap: 10px;
            /* Espacement entre les éléments */
        }

        .period-btn {
            flex: 1 1 calc(50% - 5px);
            /* Flexibilité : peut grandir/rétrécir, base = 50% moins espacement */
            font-size: 0.rem;
            /* Taille de police (valeur invalide) */
            padding: 8px 5px;
            /* Padding interne */
        }

        /* Menu mobile */
        .mobile-menu-toggle {
            display: none;
            /* Masqué par défaut */
            position: fixed;
            /* Position fixe */
            top: 10px;
            /* 10px du haut */
            left: 10px;
            /* 10px de la gauche */
            z-index: 1000;
            /* Priorité d'affichage très élevée */
            /* Dégradé de couleur */
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--highlight-color) 100%);
            color: white;
            /* Couleur de texte blanc */
            border: none;
            /* Pas de bordure */
            padding: 12px 15px;
            /* Padding interne */
            border-radius: 8px;
            /* Coins arrondis */
            cursor: pointer;
            /* Curseur en forme de main */
            font-size: 1.5rem;
            /* Taille de police grande */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            /* Ombre portée */
            transition: all 0.3s ease;
            /* Transition douce pour toutes les propriétés */
            font-weight: bold;
            /* Poids de police gras */
            line-height: 1;
            /* Hauteur de ligne normale */
            animation: pulseMenu 2s infinite;
            /* Animation de pulsation infinie */
        }

        /* Animation de pulsation du menu */
        @keyframes pulseMenu {

            0%,
            100% {
                box-shadow: 0 4px 15px rgba(233, 69, 96, 0.3);
                /* Ombre rose transparente */
            }

            50% {
                box-shadow: 0 4px 25px rgba(233, 69, 96, 0.6);
                /* Ombre rose plus visible */
            }
        }

        /* État au survol du menu mobile */
        .mobile-menu-toggle:hover {
            transform: scale(1.1);
            /* Agrandissement de 10% */
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.5);
            /* Ombre rose plus prononcée */
        }

        /* État actif du menu mobile */
        .mobile-menu-toggle:active {
            transform: scale(0.95);
            /* Rétrécissement de 5% */
        }

        /* Overlay du menu */
        .menu-overlay {
            display: none;
            /* Masqué par défaut */
            position: fixed;
            /* Position fixe */
            top: 0;
            /* Alignement en haut */
            left: 0;
            /* Alignement à gauche */
            width: 100%;
            /* Largeur complète */
            height: 100%;
            /* Hauteur complète */
            background-color: rgba(0, 0, 0, 0.5);
            /* Fond noir semi-transparent */
            z-index: 98;
            /* Priorité d'affichage élevée */
        }

        /* État actif de l'overlay */
        .menu-overlay.active {
            display: block;
            /* Affiché en bloc */
        }

        /* ============================================================================
   12. RESPONSIVE DESIGN
   ============================================================================ */

        /* Tablettes (768px - 1024px) */
        @media (max-width: 1024px) {
            .sidebar {
                width: 200px;
                /* Barre latérale plus étroite */
            }

            .main-content {
                margin-left: 200px;
                /* Marge gauche réduite */
            }

            .number-grid-select {
                grid-template-columns: repeat(7, 1fr);
                /* 7 colonnes au lieu de 10 */
                gap: 10px;
                /* Espacement réduit */
                max-width: 100%;
                /* Largeur maximum complète */
            }

            .header h2 {
                font-size: 1.2rem;
                /* Titre d'en-tête réduit */
            }

            /* Grilles matrice : 2 colonnes au lieu de 3 */
            #matrice .prediction-container,
            #matrice .model-contributions {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Tablettes et smartphones (< 768px) */
        @media (max-width: 768px) {
            :root {
                --header-height: 60px;
                /* Hauteur d'en-tête réduite */
            }

            .mobile-menu-toggle {
                display: block;
                /* Affiche le bouton menu mobile */
            }

            .sidebar {
                position: fixed;
                /* Position fixe */
                left: -100%;
                /* Positionnée hors écran à gauche */
                top: 0;
                /* Alignement en haut */
                width: 280px;
                /* Largeur fixe */
                height: 100vh;
                /* Hauteur complète */
                z-index: 99;
                /* Priorité d'affichage élevée */
                transition: left 0.3s ease;
                /* Transition douce pour la position */
                overflow-y: auto;
                /* Permet le défilement vertical */
            }

            /* État actif de la barre latérale */
            .sidebar.active {
                left: 0;
                /* Position normale */
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
                /* Ombre portée à droite */
            }

            .main-content {
                margin-left: 0;
                /* Plus de marge gauche */
                width: 100%;
                /* Largeur complète */
            }

            .logo {
                padding: 20px;
                /* Padding interne */
                border-bottom: 1px solid var(--border-color);
                /* Bordure bas visible */
            }

            .logo h1 {
                font-size: 1.3rem;
                /* Titre de logo réduit */
            }

            .nav-menu {
                display: block;
                /* Affichage en bloc */
                padding: 10px 0;
                /* Padding vertical */
            }

            .nav-item {
                display: flex;
                /* Utilise Flexbox */
                padding: 15px 20px;
                /* Padding interne */
                border-left: 3px solid transparent;
                /* Bordure gauche transparente */
                border-bottom: none;
                /* Pas de bordure bas */
                font-size: 0.9rem;
                /* Taille de police réduite */
            }

            .nav-item.active {
                border-left-color: var(--highlight-color);
                /* Bordure gauche colorée */
                border-bottom: none;
                /* Pas de bordure bas */
            }

            .header {
                height: 60px;
                /* Hauteur réduite */
                padding: 0 15px 0 70px;
                /* Padding avec espace pour le bouton menu */
            }

            .header h2 {
                font-size: 0.95rem;
                /* Titre d'en-tête réduit */
            }

            .content {
                padding: 15px;
                /* Padding interne */
            }

            .section {
                padding: 15px;
                /* Padding interne réduit */
            }

            .section h2 {
                font-size: 1.3rem;
                /* Titre de section réduit */
            }

            .number-grid-select {
                grid-template-columns: repeat(7, 1fr);
                /* 7 colonnes */
                gap: 8px;
                /* Espacement réduit */
                max-width: 100%;
                /* Largeur maximum complète */
            }

            .number-ball-select,
            .number-ball-chance-select {
                width: 35px;
                /* Largeur réduite */
                height: 35px;
                /* Hauteur réduite */
                font-size: 0.85em;
                /* Taille de police réduite */
            }

            .prediction-card {
                width: 100%;
                /* Largeur complète */
                margin: 10px 0;
                /* Marge verticale */
            }

            .grid-2 {
                grid-template-columns: 1fr;
                /* 1 colonne seulement */
            }

            .chart-container {
                height: 300px;
                /* Hauteur réduite */
            }

            button,
            input,
            select {
                font-size: 0.9rem;
                /* Taille de police réduite */
                padding: 10px;
                /* Padding interne */
            }

            /* Grilles matrice : 1 colonne seulement */
            #matrice .prediction-container,
            #matrice .model-contributions {
                grid-template-columns: 1fr;
            }

            #matrice .prediction-item,
            #matrice .contribution-item {
                width: 100%;
                /* Largeur complète */
                margin: 10px 0;
                /* Marge verticale */
            }

            #matrice .technical-metrics {
                grid-template-columns: 1fr;
                /* 1 colonne seulement */
            }

            #matrice .metric-item {
                flex-direction: column;
                /* Disposition en colonne */
                text-align: center;
                /* Centre le texte */
                gap: 10px;
                /* Espacement entre les éléments */
                min-height: 100px;
                /* Hauteur minimum augmentée */
            }
        }

        /* Smartphones moyens (414px - 600px) */
        @media (max-width: 600px) {
            .mobile-menu-toggle {
                top: 10px;
                /* Position depuis le haut */
                left: 10px;
                /* Position depuis la gauche */
                padding: 8px 12px;
                /* Padding interne réduit */
                font-size: 1.1rem;
                /* Taille de police réduite */
            }

            .sidebar {
                width: 260px;
                /* Barre latérale plus étroite */
            }

            .header {
                padding: 0 10px 0 65px;
                /* Padding réduit avec espace pour le bouton */
            }

            .header h2 {
                font-size: 0.85rem;
                /* Titre d'en-tête très réduit */
            }

            .logo h1 {
                font-size: 1.2rem;
                /* Titre de logo réduit */
            }

            .nav-item {
                padding: 12px 15px;
                /* Padding interne réduit */
                font-size: 0.85rem;
                /* Taille de police réduite */
            }

            .number-grid-select {
                grid-template-columns: repeat(7, 1fr);
                /* 7 colonnes */
                gap: 6px;
                /* Espacement très réduit */
            }

            .chance-grid-select {
                grid-template-columns: repeat(5, 1fr);
                /* 5 colonnes */
                gap: 8px;
                /* Espacement réduit */
            }

            .number-ball-select,
            .number-ball-chance-select {
                width: 32px;
                /* Largeur réduite */
                height: 32px;
                /* Hauteur réduite */
                font-size: 0.8em;
                /* Taille de police réduite */
            }

            .number-ball {
                width: 35px;
                /* Largeur réduite */
                height: 35px;
                /* Hauteur réduite */
                font-size: 0.9em;
                /* Taille de police réduite */
            }

            .control-group {
                padding: 15px;
                /* Padding interne réduit */
            }

            .control-group label {
                font-size: 0.9rem;
                /* Taille de police réduite */
            }

            .period-btn {
                font-size: 0.7rem;
                /* Taille de police très réduite */
                padding: 6px 4px;
                /* Padding interne réduit */
            }

            .stat-card h4 {
                font-size: 0.85rem;
                /* Titre de carte réduit */
            }

            .stat-card .value {
                font-size: 1.1rem;
                /* Valeur légèrement agrandie */
            }
        }

        /* Petits smartphones (360px - 414px) */
        @media (max-width: 414px) {
            .mobile-menu-toggle {
                top: 8px;
                /* Position depuis le haut réduite */
                left: 8px;
                /* Position depuis la gauche réduite */
                padding: 7px 10px;
                /* Padding interne réduit */
                font-size: 1rem;
                /* Taille de police normale */
            }

            .sidebar {
                width: 240px;
                /* Barre latérale plus étroite */
            }

            .header {
                height: 55px;
                /* Hauteur d'en-tête réduite */
                padding: 0 8px 0 60px;
                /* Padding réduit avec espace pour le bouton */
            }

            .header h2 {
                font-size: 0.75rem;
                /* Titre d'en-tête très réduit */
            }

            .section h2 {
                font-size: 1.1rem;
                /* Titre de section réduit */
            }

            .number-grid-select {
                grid-template-columns: repeat(7, 1fr);
                /* 7 colonnes */
                gap: 5px;
                /* Espacement très réduit */
            }

            .number-ball-select,
            .number-ball-chance-select {
                width: 28px;
                /* Largeur réduite */
                height: 28px;
                /* Hauteur réduite */
                font-size: 0.75em;
                /* Taille de police réduite */
            }

            .number-ball {
                width: 32px;
                /* Largeur réduite */
                height: 32px;
                /* Hauteur réduite */
                font-size: 0.85em;
                /* Taille de police réduite */
            }

            .chart-container {
                height: 250px;
                /* Hauteur réduite */
                padding: 10px;
                /* Padding interne réduit */
            }

            button,
            input,
            select {
                font-size: 0.85rem;
                /* Taille de police réduite */
                padding: 8px;
                /* Padding interne réduit */
            }

            .info-box,
            .success-box {
                padding: 12px;
                /* Padding interne réduit */
                font-size: 0.9rem;
                /* Taille de police réduite */
            }

            .grid-title {
                font-size: 0.9rem;
                /* Titre de grille réduit */
            }
        }

        /* Très petits smartphones (320px - 360px) */
        @media (max-width: 360px) {
            .mobile-menu-toggle {
                top: 5px;
                /* Position depuis le haut très réduite */
                left: 5px;
                /* Position depuis la gauche très réduite */
                padding: 6px 8px;
                /* Padding interne très réduit */
                font-size: 0.9rem;
                /* Taille de police réduite */
            }

            .sidebar {
                width: 220px;
                /* Barre latérale très étroite */
            }

            .logo {
                padding: 15px 10px;
                /* Padding interne réduit */
            }

            .logo h1 {
                font-size: 1rem;
                /* Titre de logo très réduit */
            }

            .logo p {
                font-size: 0.7rem;
                /* Sous-titre de logo très réduit */
            }

            .nav-item {
                padding: 10px 12px;
                /* Padding interne réduit */
                font-size: 0.8rem;
                /* Taille de police réduite */
            }

            .header {
                height: 50px;
                /* Hauteur d'en-tête très réduite */
                padding: 0 5px 0 55px;
                /* Padding très réduit avec espace pour le bouton */
            }

            .header h2 {
                font-size: 0.7rem;
                /* Titre d'en-tête très réduit */
            }

            .content {
                padding: 10px;
                /* Padding interne réduit */
            }

            .section {
                padding: 10px;
                /* Padding interne réduit */
            }

            .section h2 {
                font-size: 1rem;
                /* Titre de section très réduit */
                margin-bottom: 15px;
                /* Marge bas réduite */
            }

            .section h3 {
                font-size: 1rem;
                /* Sous-titre normal */
            }

            .number-grid-select {
                grid-template-columns: repeat(7, 1fr);
                /* 7 colonnes */
                gap: 4px;
                /* Espacement minimal */
            }

            .chance-grid-select {
                grid-template-columns: repeat(5, 1fr);
                /* 5 colonnes */
                gap: 6px;
                /* Espacement réduit */
            }

            .number-ball-select,
            .number-ball-chance-select {
                width: 26px;
                /* Largeur très réduite */
                height: 26px;
                /* Hauteur très réduite */
                font-size: 0.7em;
                /* Taille de police très réduite */
            }

            .number-ball {
                width: 30px;
                /* Largeur réduite */
                height: 30px;
                /* Hauteur réduite */
                font-size: 0.8em;
                /* Taille de police réduite */
            }

            .control-group {
                padding: 10px;
                /* Padding interne réduit */
            }

            .control-group label {
                font-size: 0.85rem;
                /* Taille de police réduite */
                margin-bottom: 6px;
                /* Marge bas réduite */
            }

            button,
            input,
            select {
                font-size: 0.8rem;
                /* Taille de police réduite */
                padding: 7px;
                /* Padding interne réduit */
                margin: 3px 3px 3px 0;
                /* Marge réduite */
            }

            .chart-container {
                height: 200px;
                /* Hauteur très réduite */
                padding: 8px;
                /* Padding interne réduit */
            }

            .stat-card {
                padding: 10px;
                /* Padding interne réduit */
            }

            .stat-card h4 {
                font-size: 0.8rem;
                /* Titre de carte réduit */
            }

            .stat-card .value {
                font-size: 1rem;
                /* Valeur normale */
            }

            .info-box,
            .success-box {
                padding: 10px;
                /* Padding interne réduit */
                font-size: 0.85rem;
                /* Taille de police réduite */
            }

            .info-box ul,
            .success-box ul {
                margin-left: 15px;
                /* Marge gauche réduite */
                font-size: 0.8rem;
                /* Taille de police réduite */
            }

            .grid-title {
                font-size: 0.85rem;
                /* Titre de grille réduit */
                margin-bottom: 10px;
                /* Marge bas réduite */
            }

            .selected-numbers-display {
                gap: 6px;
                /* Espacement réduit */
            }

            .prediction-card {
                padding: 10px;
                /* Padding interne réduit */
                margin: 8px 0;
                /* Marge verticale réduite */
            }

            table {
                font-size: 0.8rem;
                /* Taille de police réduite pour les tableaux */
            }

            th,
            td {
                padding: 8px 4px;
                /* Padding réduit pour les cellules */
            }
        }

        /* Orientation paysage sur mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .header {
                height: 45px;
                /* Hauteur d'en-tête très réduite */
            }

            .header h2 {
                font-size: 0.8rem;
                /* Titre d'en-tête réduit */
            }

            .chart-container {
                height: 250px;
                /* Hauteur réduite */
            }

            .section {
                padding: 10px;
                /* Padding interne réduit */
            }

            .number-grid-select {
                grid-template-columns: repeat(10, 1fr);
                /* 10 colonnes en paysage */
            }
        }

        /* Responsive pour grilles matrice sur grands écrans */
        @media (min-width: 1200px) {
            #matrice .results-grid {
                grid-template-columns: repeat(1, 1fr);
                /* 1 colonne sur très grands écrans */
            }
        }

        @media (min-width: 1500px) {
            #matrice .results-grid {
                grid-template-columns: repeat(1, 1fr);
                /* 1 colonne sur écrans extra larges */
            }
        }

        /* ============================================================================
   BARRE DE RECHERCHE AVANCÉE
   ============================================================================ */

        /* Conteneur de l'icône recherche */
        .search-container {
            position: fixed;
            top: 25px;
            right: 70px;
            z-index: 1000;
        }

        /* Icône de recherche avec emoji */
        .search-icon {
            all: unset !important;
            width: 10px !important;
            height: 25px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            font-size: 1.4rem !important;
            background: transparent !important;
            position: static !important;
        }

        .search-icon:hover {
            border-color: rgba(255, 255, 255, 0.6) !important;
            color: rgba(255, 255, 255, 0.9) !important;
        }


        .search-icon::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;

        }

        .search-icon:hover::before {
            left: 100%;
        }

        .search-icon:active {
            transform: scale(0.95) translateY(0);
            transition: all 0.1s ease;
        }

        .search-icon {
            animation: searchPulse 3s ease-in-out infinite;
        }

        .search-icon:hover::after {
            opacity: 1;
        }

        /* Overlay de recherche */
        .search-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            z-index: 9999;
            justify-content: center;
            align-items: flex-start;
            padding-top: 1px;
        }

        .search-overlay.active {
            display: flex;
        }

        /* Modale de recherche */
        .search-modal {
            position: relative;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.12) 0%,
                    rgba(255, 255, 255, 0.06) 100%);
            backdrop-filter: blur(100px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 10px;
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow:
                0 25px 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-40px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Bouton fermeture */
        .search-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #ddd;
            transition: all 0.3s ease;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .search-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #ff6b6b;
            transform: rotate(90deg);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }

        /* En-tête recherche */
        .search-header {
            padding: 35px 40px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            background: linear-gradient(180deg,
                    rgba(77, 163, 255, 0.1) 0%,
                    transparent 100%);
        }

        .search-header h3 {
            font-size: 1.6rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #4da3ff 0%, #67daff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
        }

        .search-header p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.95rem;
            line-height: 1.4;
        }

        /* Champ de recherche */
        .search-input-container {
            position: relative;
            padding: 25px 40px 15px;
        }

        .search-input-container input {
            width: 100%;
            padding: 18px 60px 18px 25px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: #fff;
            font-size: 1.05rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }

        .search-input-container input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(77, 163, 255, 0.6);
            box-shadow:
                0 0 0 3px rgba(77, 163, 255, 0.2),
                0 10px 30px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        .search-input-container input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-input-container i {
            position: absolute;
            right: 60px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.2rem;
        }

        /* Statistiques de recherche */
        .search-stats {
            padding: 0 40px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        .search-stats span {
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* Résultats de recherche */
        .search-results {
            padding: 0 40px 35px;
            max-height: 500px;
            overflow-y: auto;
        }

        .search-category {
            margin-bottom: 30px;
        }

        .search-category:last-child {
            margin-bottom: 0;
        }

        .search-category h4 {
            font-size: 1.15rem;
            margin-bottom: 18px;
            color: var(--text-secondary);
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .search-category h4::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, #4da3ff 0%, #67daff 100%);
            border-radius: 2px;
        }

        .search-items-grid {
            display: grid;
            grid-template-columns: repeat(1, minmax(350px, 1fr));
            gap: 15px;
        }

        .search-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .search-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.05),
                    transparent);
            transition: left 0.6s ease;
        }

        .search-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .search-item:hover::before {
            left: 100%;
        }

        .search-item-header {
            display: flex;
            justify-content: between;
            align-items: flex-start;
            margin-bottom: 12px;
            gap: 15px;
        }

        .search-item h5 {
            font-size: 1.05rem;
            margin-bottom: 8px;
            color: #fff;
            font-weight: 500;
            line-height: 1.3;
            flex: 1;
        }

        .search-item-type {
            background: rgba(77, 163, 255, 0.2);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .search-item p {
            font-size: 0.87rem;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .search-item-features {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .search-feature {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            padding: 3px 8px;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .search-item .search-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .search-tag {
            background: rgba(77, 163, 255, 0.15);
            color: var(--text-secondary);
            padding: 3px 9px;
            border-radius: 10px;
            font-size: 0.72rem;
            font-weight: 600;
            border: 1px solid rgba(77, 163, 255, 0.3);
        }

        .search-tag.statistical {
            background: rgba(76, 175, 80, 0.15);
            color: #4caf50;
            border-color: rgba(76, 175, 80, 0.3);
        }

        .search-tag.ml {
            background: rgba(156, 39, 176, 0.15);
            color: #9c27b0;
            border-color: rgba(156, 39, 176, 0.3);
        }

        .search-tag.deep-learning {
            background: rgba(255, 152, 0, 0.15);
            color: #ff9800;
            border-color: rgba(255, 152, 0, 0.3);
        }

        .search-tag.clustering {
            background: rgba(244, 67, 54, 0.15);
            color: #f44336;
            border-color: rgba(244, 67, 54, 0.3);
        }

        .search-tag.simulation {
            background: rgba(33, 150, 243, 0.15);
            color: #2196f3;
            border-color: rgba(33, 150, 243, 0.3);
        }

        .search-tag.test {
            background: rgba(121, 85, 72, 0.15);
            color: #795548;
            border-color: rgba(121, 85, 72, 0.3);
        }

        /* État vide */
        .search-empty {
            text-align: center;
            padding: 60px 20px;
            color: rgba(255, 255, 255, 0.5);
        }

        .search-empty i {
            font-size: 3.5rem;
            margin-bottom: 20px;
            opacity: 0.4;
        }

        .search-empty p {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .search-empty .search-suggestions {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 15px;
        }

        /* Indicateur de chargement */
        .search-loading {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
        }

        .search-loading i {
            font-size: 2rem;
            margin-bottom: 15px;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Scrollbar personnalisée */
        .search-results::-webkit-scrollbar {
            width: 8px;
        }

        .search-results::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .search-results::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .search-results::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .search-container {
                top: 18px;
                right: 60px;
            }

            .search-icon {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            .search-modal {
                width: 95%;
                margin: 20px;
                border-radius: 16px;
            }

            .search-header {
                padding: 25px 25px 15px;
            }

            .search-header h3 {
                font-size: 1.3rem;
            }

            .search-input-container,
            .search-results {
                padding: 20px 25px;
            }

            .search-items-grid {
                grid-template-columns: 1fr;
            }

            .search-input-container input {
                padding: 15px 50px 15px 20px;
                font-size: 1rem;
            }

            .search-input-container i {
                right: 45px;
            }
        }

        @media (max-width: 480px) {
            .search-container {
                top: 15px;
                right: 55px;
            }

            .search-icon {
                width: 32px;
                height: 32px;
                font-size: 0.9rem;
            }

            .search-header,
            .search-input-container,
            .search-results {
                padding: 15px 20px;
            }

            .search-header h3 {
                font-size: 1.2rem;
            }

            .search-input-container input {
                padding: 12px 45px 12px 15px;
                font-size: 0.95rem;
            }
        }

        /* Animation pour le bouton Développer */
        .expand-btn {
            position: relative;
            overflow: hidden;
        }

        .expand-btn:hover {
            background: rgba(77, 163, 255, 0.1) !important;
            border-color: rgba(77, 163, 255, 0.6) !important;
            color: #67daff !important;
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(77, 163, 255, 0.3) !important;
        }

        .expand-btn:active {
            transform: translateX(0);
        }

        /* Effet de brillance au survol */
        .expand-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(77, 163, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .expand-btn:hover::before {
            left: 100%;
        }

        /* Animation de déroulement du contenu */
        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                max-height: 2000px;
                transform: translateY(0);
            }
        }

        /* Animation de repli */
        @keyframes slideUp {
            from {
                opacity: 1;
                max-height: 2000px;
            }

            to {
                opacity: 0;
                max-height: 0;
            }
        }

        /* Style pour le contenu développé */
        .item-detail-content {
            overflow: hidden;
        }

        .item-detail-content.closing {
            animation: slideUp 0.3s ease forwards;
        }

        /* ============================================================================
   FIN CSS
   ============================================================================ */
    </style>
</head>

<body>


    <!-- Bouton menu hamburger -->

    <button class="mobile-menu-toggle" id="mobileMenuToggle">☰</button>

    <!-- Overlay pour fermer le menu -->
    <div class="menu-overlay" id="menuOverlay"></div>

    <!-- Barre latérale -->

    <div class="sidebar">
        <div class="logo">
            <h1>LTsTaT</h1>
            <p></p>
        </div>
        <div class="nav-menu">

            <div class="nav-item active" onclick="showTab('overview')">
                <i></i> Accueil
            </div>

            <div class="nav-item" onclick="showTab('predictions')">
                <i></i> Probabilités
            </div>

            <div class="nav-item" onclick="showTab('clusters')">
                <i></i> Clustering
            </div>

            <div class="nav-item" onclick="showTab('frequencies')">
                <i></i> Fréquences
            </div>

            <div class="nav-item" onclick="showTab('statistics')">
                <i></i> Statistiques
            </div>

            <div class="nav-item" onclick="showTab('ml')">
                <i></i> Apprentissage
            </div>

            <div class="nav-item" onclick="showTab('evaluation')">
                <i></i> Évaluation
            </div>

            <div class="nav-item" onclick="showTab('simulation')">
                <i></i> Simulation
            </div>

            <div class="nav-item" onclick="showTab('matrice')">
                <i></i> Matrice
            </div>

            <div class="nav-item" onclick="showTab('programme')">
                <i></i> Programme
            </div>

            <div class="nav-item" onclick="showTab('index')">
                <i></i> Index
            </div>

        </div>
    </div>

    <!-- Contenu principal de l'application -->

    <div class="main-content">

        <!-- En-tête avec le statut de l'application -->

        <div class="header">
            <h2 id="appStatus">Analyse Statistique et Prédictive du Loto</h2>

            <!-- Barre de recherche -->

            <div class="search-container">
                <div class="search-icon" id="searchToggle">
                    🔎
                </div>
            </div>

            <!-- Overlay de recherche -->

            <div class="search-overlay" id="searchOverlay">
                <div class="search-modal">
                    <button class="search-close-btn" id="searchClose">
                        <i class="fas fa-times"></i>
                    </button>

                    <div class="search-header">
                        <h3> Index des Algorithmes Mathématiques</h3>
                        <p>Explorez l'ensemble des modèles statistiques et algorithmes de machine learning</p>

                        <!-- Lien vers l'index complet -->
                        <a href="#" onclick="openFullIndex(); return false;" style="display: inline-block; margin-top: 15px; padding: 10px 20px; 
                                  background: linear-gradient(135deg, #4da3ff 0%, #67daff 100%); 
                                  color: white; text-decoration: none; border-radius: 8px; 
                                  font-weight: 600; transition: all 0.3s ease;">
                            Accéder à l'index complet
                        </a>
                    </div>

                    <div class="search-input-container">
                        <input type="text" id="searchInput"
                            placeholder="Rechercher un modèle, une distribution, un test statistique...">
                        <i class="fas fa-search"></i>
                    </div>

                    <div class="search-stats">
                        <span id="searchCount">0</span> algorithmes disponibles
                    </div>

                    <div class="search-results" id="searchResults">

                        <!-- Les résultats seront injectés ici -->
                    </div>
                </div>
            </div>

            <div id="loginIcon">👤</div>
        </div>

        <!-- ===== Fenêtre modale de connexion ===== -->

        <div id="loginModal" class="modal-overlay">
            <div class="modal-content">
                <button class="close-btn" id="closeLoginModal">✖</button>
                <h2>Connexion</h2>

                <form id="loginForm">
                    <label for="loginEmail">Adresse e-mail ou identifiant</label>
                    <input type="text" id="loginEmail" name="loginEmail" placeholder="ex: utilisateur@mail.com"
                        required>

                    <label for="loginPassword">Mot de passe</label>
                    <input type="password" id="loginPassword" name="loginPassword" placeholder="••••••••" minlength="6"
                        required>


                    <button type="submit" class="login-btn">Se connecter</button>
                    <a href="#" class="forgot-link">Mot de passe oublié ?</a>
                </form>
            </div>
        </div>

        <script>
            const loginIcon = document.getElementById('loginIcon');
            const loginModal = document.getElementById('loginModal');
            const closeLoginModal = document.getElementById('closeLoginModal');

            loginIcon.addEventListener('click', () => {
                loginModal.style.display = 'flex';
            });

            closeLoginModal.addEventListener('click', () => {
                loginModal.style.display = 'none';
            });

            window.addEventListener('click', (e) => {
                if (e.target === loginModal) {
                    loginModal.style.display = 'none';
                }
            });

            document.getElementById('loginForm').addEventListener('submit', (e) => {
                e.preventDefault();
                const email = document.getElementById('loginEmail').value.trim();
                const pass = document.getElementById('loginPassword').value.trim();
                console.log(`Tentative de connexion: ${email} / ${pass ? '••••••••' : ''}`);
                alert('Connexion en cours...');
                loginModal.style.display = 'none';
            });


        </script>

        <!-- Zone de contenu où s'affichent les différents onglets -->

        <div class="content">

            <!-- Onglet Accueil -->

            <div id="overview" class="tab-content active">
                <div class="section">
                    <h2>Accueil</h2>
                    <p style="font-size: 1.05em; line-height: 1.5; margin: 10px 0;">
                        ARÔME propose une plateforme d'analyse avancée innovante combinant des modèles statistiques
                        de pointe et des algorithmes d'apprentissage automatique pour l'étude approfondie des tirages de
                        loterie.
                        Le programme intègre des méthodes probabilistes sophistiquées et des techniques d'apprentissage
                        automatique pour identifier les tendances historiques et générer des prévisions optimisées..<br>

                        <br>L'architecture modulaire permet d'explorer les données sous différents approches :
                        Analyses fréquentielles, clustering K-Means pour la détection de patterns, simulations
                        Monte-Carlo massives, et évaluations statistiques avancées. La fonctionnalité unique de la
                        Matrice personnalisée offre la possibilité de composer des architectures d'analyse sur mesure en
                        combinant plusieurs modèles pour une synergie optimisée. La plateforme constitue un outil
                        d'exploration statistique complet pour comprendre les
                        mécanismes probabilistes régissant les tirages aléatoires.
                    </p>
                    </p>

                    <!-- Section loterie -->

                    <div class="info-box">
                        <h3 style="color: var(--text-secondary); margin-bottom: 1px;">Sélectionner une loterie
                            <p></p>
                            <div class="">
                                <div class="period-options">
                                    <button class="period-btn" onclick="()">Loto</button>
                                    <button class="period-btn" onclick="()">Super Loto</button>
                                    <button class="period-btn" onclick="()">Euro Millions</button>
                                    <button class="period-btn" onclick="()">Kéno</button>
                                </div>
                            </div>
                    </div>

                    <!-- Conteneur pour afficher le dernier tirage (masqué par défaut) -->

                    <div id="latestDrawContainer" style="display: none;">
                        <div class="latest-draw glass-card">
                            </h1>
                            <div id="latestDrawDate" style="font-weight: 300px; margin-bottom: 10px;"></div>
                            <div class="latest-draw-numbers" id="latestDrawNumbers"></div>
                        </div>
                    </div>

                    <!-- Contrôles pour la sélection de la période d'analyse -->

                    <div class="control-group">
                        <h3 style="color: var(--text-secondary); margin-bottom: 15px;">Sélection de la Période d'Analyse
                        </h3>
                        <div class="period-selector">
                            <div class="period-options">
                                <button class="period-btn active" onclick="setPeriod('all')">Tous les tirages</button>
                                <button class="period-btn" onclick="setPeriod('year')">Année</button>
                                <button class="period-btn" onclick="setPeriod('month')">Mois</button>
                                <button class="period-btn" onclick="setPeriod('custom')">Période personnalisée</button>
                            </div>
                        </div>

                        <!-- Sélecteur d'année (masqué par défaut) -->

                        <div id="yearSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Année :</label>
                            <select id="yearSelect" onchange="applyPeriodFilter()">
                                <option value="">Sélectionnez une année</option>
                            </select>
                        </div>

                        <!-- Sélecteur de mois (masqué par défaut) -->

                        <div id="monthSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Mois :</label>
                            <select id="monthSelect" onchange="applyPeriodFilter()">
                                <option value="">Sélectionnez un mois</option>
                                <option value="01">Janvier</option>
                                <option value="02">Février</option>
                                <option value="03">Mars</option>
                                <option value="04">Avril</option>
                                <option value="05">Mai</option>
                                <option value="06">Juin</option>
                                <option value="07">Juillet</option>
                                <option value="08">Août</option>
                                <option value="09">Septembre</option>
                                <option value="10">Octobre</option>
                                <option value="11">Novembre</option>
                                <option value="12">Décembre</option>
                            </select>
                            <select id="monthYearSelect" onchange="applyPeriodFilter()">
                                <option value="">Sélectionnez une année</option>
                            </select>
                        </div>

                        <!-- Sélecteur de période personnalisée (masqué par défaut) -->

                        <div id="customPeriodSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Période personnalisée :</label>
                            <div class="date-inputs">
                                <input type="date" id="startDate" onchange="applyPeriodFilter()">
                                <span>au</span>
                                <input type="date" id="endDate" onchange="applyPeriodFilter()">
                            </div>
                        </div>
                    </div>

                    <!-- Grille de statistiques résumées -->

                    <div class="grid-2">
                        <div class="stat-card">
                            <h4>Tirages Analysés</h4>
                            <div class="value" id="statTotalDraws">0</div>
                            <small id="periodInfo">Période: Tous les tirages</small>
                        </div>
                        <div class="stat-card">
                            <h4>Période Couverte</h4>
                            <div class="value" id="statPeriod">Réelle</div>
                            <small id="dateRange">-</small>
                        </div>
                        <div class="stat-card">
                            <h4>Premier Tirage</h4>
                            <div class="value" id="firstDrawDate">-</div>
                        </div>
                        <div class="stat-card">
                            <h4>Dernier Tirage</h4>
                            <div class="value" id="lastDrawDate">-</div>
                        </div>
                    </div>

                    <!-- Boîte d'information sur les fonctionnalités -->

                    <div class="info-box" style="margin-top: 5px;">
                        <h3 style="color: var(--text-secondary); margin-bottom: 0px;">
                            <h3>Fonctionnalités du programme</h3>
                            <ul style="line-height: 2; margin-left: 20px;">
                                <p></p>
                                <li><strong>Analyse des Fréquences :</strong> Visualisez les numéros les plus et moins
                                    fréquents</li>
                                <li><strong>Prévisions Statistiques :</strong> Algorithmes basés sur les distributions
                                    de
                                    Poisson, Loi de Zipf, Test T Student, Test Chi-carré, Distribution Binomiale,
                                    Distribution de Dirichlet</li>
                                <li><strong>Machine Learning Réel :</strong> Modèles de classification avancés (Random
                                    Forest, Gradient Boosting, Régression Logistique, LSTM Deep Learning, Ensemble
                                    Stacking)
                                </li>
                                <li><strong>Clustering K-Means :</strong> Identification de groupes de numéros
                                    similaires
                                </li>
                                <li><strong>Simulations Monte Carlo :</strong> Testez vos stratégies avec des milliers
                                    de
                                    tirages simulés</li>
                                <li><strong>Analyses Statistiques :</strong> Tests de significativité, corrélations, et
                                    tendances temporelles</li>
                            </ul>
                    </div>

                    <!-- Bouton pour commencer l'analyse -->

                    <button onclick="showTab('frequencies')"
                        style="margin-top: 1px; width: 100%; padding: 10px; font-size: 1.1em;">
                        Commencer l'Analyse →
                    </button>
                </div>
            </div>

            <!-- Onglet Fréquences -->

            <div id="frequencies" class="tab-content">
                <div class="section">
                    <h2>Analyse des Fréquences</h2>
                    <p>Visualisez la fréquence d'apparition de chaque numéro dans l'historique des tirages.</p>

                    <!-- Contrôles pour le type d'analyse de fréquence -->
                    <div class="control-group">
                        <label>Type d'analyse :</label>
                        <select id="freqType" onchange="updateFrequencyChart()">
                            <option value="chance">Numéros Chance (1-10)</option>
                            <option value="main">Numéros Principaux (1-49)</option>
                        </select>
                        <button onclick="updateFrequencyChart()">Générer le Graphique</button>
                    </div>

                    <!-- Boîte d'information explicative -->
                    <div class="info-box">
                        <h4>Analyse des Fréquences</h4>
                        <p>Cette technique est essentielle pour identifier les tendances historiques des numéros.</p>
                    </div>

                    <!-- Conteneur pour le graphique des fréquences -->
                    <div class="chart-container">
                        <canvas id="frequencyChart"></canvas>
                    </div>

                    <!-- Zone d'affichage des résultats -->
                    <div id="freqResults" class="info-box glass-card"></div>

                    <!-- Note d'information importante -->
                    <div class="info-box">
                        <strong>Information :</strong> Les numéros les plus fréquents ne sont pas nécessairement les
                        plus "chanceux" - chaque tirage est indépendant. Cette analyse montre simplement les tendances
                        historiques.
                    </div>
                </div>
            </div>

            <!-- Onglet Probabilités -->

            <div id="predictions" class="tab-content">
                <div class="section">
                    <h2>Probabilités Statistiques</h2>
                    <p>Générez des combinaisons basées sur différents modèles probabilistes.</p>

                    <!-- Boîte d'information détaillée sur les modèles probabilistes -->
                    <div class="info-box">
                        <h4>Modèle de Probabilités</h4>
                        <p>
                        <p>Les simulations sont des algorithmes utilisés dans le but d'estimer la probabilité
                            d'occurrence d'un scénario dans lequel interviennent des paramètres aléatoires. C'est une
                            technique statistique permettant de comprendre l'influence de l'incertitude dans les modèles
                            de Probabilités.</p>
                        <p><strong>Distributions Statistiques Utilisées :</strong>
                        <p></p>
                        <p><strong>Loi de Poisson :</strong> Modélise la probabilité qu'un certain nombre d'événements
                            (apparitions d'un numéro) se produisent dans un intervalle de temps donné. Utile pour les
                            faibles fréquences (numéros "en retard").</p>
                        <p><strong>Distribution Binomiale :</strong> Modélise le nombre de succès (apparitions d'un
                            numéro) dans une séquence de n tirages indépendants, chacun ayant une probabilité p de
                            succès.</p>
                        <p><strong>Distribution de Dirichlet :</strong> Distribution complexe souvent utilisée pour
                            modéliser des proportions de catégories. Dans le contexte du Loto, elle peut modéliser la
                            probabilité que les cinq numéros choisis se répartissent de manière déséquilibrée sur les
                            quatre dizaines.</p>
                        <p><strong>Tests Statistiques :</strong></p>
                        <p><strong>Test T Student :</strong> Permet de comparer la moyenne d'une série de numéros avec
                            une valeur théorique pour déterminer si l'écart est significatif.</p>
                        <p><strong>Test du Chi-carré (χ²) :</strong> Le test essentiel pour le Loto. Il permet de
                            vérifier si la distribution observée des fréquences des numéros est conforme à une
                            distribution uniforme théorique.</p>
                    </div>

                    <!-- Contrôles pour la génération de prédictions -->
                    <div class="control-group">
                        <label>Modèle de Probabilités :</label>
                        <select id="predModel" onchange="togglePredictionOptions()">
                            <option value="montecarlo">Simulation Monte-Carlo</option>
                            <option value="poisson">Distribution de Poisson</option>
                            <option value="dirichlet">Distribution de Dirichlet</option>
                            <option value="binomiale">Distribution Binomiale</option>
                            <option value="gamma">Distribution Gamma</option>
                            <option value="chisquare">Test du Chi-carré (χ²)</option>
                            <option value="student">Test T de Student</option>
                            <option value="zipf">Loi de Zipf</option>
                            <option value="hybrid">Modèle Hybride</option>
                        </select>
                        <br>

                        <!-- Options standard pour toutes les prédictions -->
                        <div id="standardOptions">
                            <label>Nombre de combinaisons :</label>
                            <select id="numPredictions">
                                <option value="1">1 combinaison</option>
                                <option value="3">3 combinaisons</option>
                                <option value="5">5 combinaisons</option>
                                <option value="6" selected>6 combinaisons</option>
                                <option value="10">10 combinaisons</option>
                                <option value="15">15 combinaisons</option>
                                <option value="20">20 combinaisons</option>
                            </select>
                        </div>

                        <!-- Options spécifiques aux tests statistiques -->
                        <div id="testOptions" style="display: none;">
                            <label>Seuil de significativité (α) :</label>
                            <input type="number" id="alphaLevel" value="0.05" min="0.01" max="0.1" step="0.01">
                        </div>

                        <!-- Options spécifiques à Monte-Carlo -->
                        <div id="monteCarloOptions" style="display: none;">
                            <label>Nombre de simulations Monte-Carlo :</label>
                            <input type="number" id="numMonteCarloSims" value="10000" min="1000" max="100000"
                                step="1000">
                            <br>
                            <label>Top combinaisons à afficher :</label>
                            <input type="number" id="topMonteCarlo" value="10" min="5" max="20">
                        </div>

                        <button onclick="generatePredictions()">Générer des Probabilités</button>
                    </div>

                    <!-- Zone d'affichage des explications des prédictions -->
                    <div id="predictionExplanations" class="info-box glass-card" style="margin: 20px 0;">
                    </div>

                    <!-- Indicateur de chargement pour les prédictions -->
                    <div class="loading" id="predLoading">
                        <div class="progress-container">
                            <div class="progress-bar" id="predProgressBar"></div>
                        </div>
                        <div class="progress-text" id="predProgressText">Initialisation de l'analyse probabiliste...
                        </div>
                        <div class="progress-stats">
                            <span id="predProgressStep">Étape 1/4</span>
                            <span class="progress-percentage" id="predProgressPercent">0%</span>
                            <span id="predProgressTime">Temps estimé: --</span>
                        </div>
                    </div>

                    <!-- Zone d'affichage des résultats des prédictions -->
                    <div id="predResults"></div>

                    <!-- Avertissement important -->
                    <div class="info-box" style="margin-top: 20px;">
                        Ces Probabilités sont purement statistiques. La loterie est un jeu de hasard où chaque tirage
                        est indépendant. Aucun algorithme ne peut garantir un gain.
                    </div>
                </div>
            </div>

            <!-- Onglet Apprentissage -->

            <div id="ml" class="tab-content">
                <div class="section">
                    <h2>Probabilités par Machine Learning</h2>
                    <p>Utilisez des algorithmes d'apprentissage automatique entraînés sur l'historique des tirages.</p>

                    <!-- Boîte d'information sur les algorithmes ML -->
                    <div class="info-box">
                        <h4>Algorithmes ML Implémentés</h4>
                        <p></p>
                        <div id="mlExplanationContent">
                            <p>Random Forest : Forêt de 100 arbres de décision
                            <p>
                                Gradient Boosting : Algorithme de boosting construisant séquentiellement des modèles
                                faibles pour minimiser la fonction de perte.
                            <p></p>
                            Régression Logistique : Modèle linéaire généralisé pour la classification avec fonction
                            logistique et régularisation <p></p>
                            LSTM (Deep Learning) : Un modèle de réseau neuronal récurrent adapté aux données
                            séquentielles.<p></p>
                            Ensemble Stacking : Combine plusieurs modèles pour améliorer la précision.
                            </ul>
                            </p>
                            <p>Features utilisées : fréquences historiques, temps depuis dernière apparition, patterns
                                statistiques, tendances temporelles
                        </div>
                    </div>

                    <!-- Contrôles pour la période d'entraînement -->
                    <div class="control-group">
                        <label>Période d'entraînement :</label>
                        <div class="period-options">
                            <button class="period-btn active" onclick="setMLPeriod('all')">Toutes les périodes</button>
                            <button class="period-btn" onclick="setMLPeriod('year')">Année</button>
                            <button class="period-btn" onclick="setMLPeriod('month')">Mois</button>
                            <button class="period-btn" onclick="setMLPeriod('custom')">Période personnalisée</button>
                        </div>

                        <!-- Sélecteur d'année pour ML -->
                        <div id="mlYearSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Année :</label>
                            <select id="mlYearSelect" onchange="applyMLPeriodFilter()">
                                <option value="">Sélectionnez une année</option>
                            </select>
                        </div>

                        <!-- Sélecteur de mois pour ML -->
                        <div id="mlMonthSelector" class="period-selector" style="display: none; margin-top: 10px;">
                            <label>Mois :</label>
                            <select id="mlMonthSelect" onchange="applyMLPeriodFilter()">
                                <option value="">Sélectionnez un mois</option>
                                <option value="01">Janvier</option>
                                <option value="02">Février</option>
                                <option value="03">Mars</option>
                                <option value="04">Avril</option>
                                <option value="05">Mai</option>
                                <option value="06">Juin</option>
                                <option value="07">Juillet</option>
                                <option value="08">Août</option>
                                <option value="09">Septembre</option>
                                <option value="10">Octobre</option>
                                <option value="11">Novembre</option>
                                <option value="12">Décembre</option>
                            </select>
                            <select id="mlMonthYearSelect" onchange="applyMLPeriodFilter()">
                                <option value="">Sélectionnez une année</option>
                            </select>
                        </div>

                        <!-- Sélecteur de période personnalisée pour ML -->
                        <div id="mlCustomPeriodSelector" class="period-selector"
                            style="display: none; margin-top: 10px;">
                            <label>Période personnalisée :</label>
                            <div class="date-inputs">
                                <input type="date" id="mlStartDate" onchange="applyMLPeriodFilter()">
                                <span>au</span>
                                <input type="date" id="mlEndDate" onchange="applyMLPeriodFilter()">
                            </div>
                        </div>
                    </div>

                    <!-- Contrôles pour la sélection et l'entraînement du modèle ML -->
                    <div class="control-group">
                        <label>Algorithme :</label>
                        <select id="mlModel">
                            <option value="rf">Random Forest</option>
                            <option value="gb">Gradient Boosting</option>
                            <option value="logistic">Régression Logistique</option>
                            <option value="ensemble">Ensemble (Stacking)</option>
                            <option value="lstm">LSTM (Deep Learning)</option>
                        </select>
                        <br>
                        <button onclick="trainMLModel()">Entraîner et Prédire</button>
                    </div>

                    <!-- Indicateur de chargement pour le ML -->
                    <div class="loading" id="mlLoading">
                        <div class="progress-container">
                            <div class="progress-bar" id="mlProgressBar"></div>
                            <!-- Pourcentage centré dans la barre de progression -->
                            <span class="progress-percentage" id="mlProgressPercent">0%</span>
                        </div>
                        <div class="progress-text" id="mlProgressText">Préparation du modèle de Machine Learning...
                        </div>
                        <div class="progress-stats">
                            <span id="mlProgressStep">Étape 1/5</span>
                            <span id="mlProgressTime">Temps estimé: --</span>
                        </div>

                        <div id="mlProgressDetails" style="margin-top: 10px; font-size: 0.9em; color: #bbb;"></div>
                    </div>

                    <!-- Grille pour les métriques ML -->
                    <div class="grid-2" id="mlMetrics"></div>
                    <!-- Zone d'affichage des résultats ML -->
                    <div id="mlResults"></div>

                    <!-- Explications détaillées du modèle ML -->
                    <div class="info-box" id="mlDetailedExplanation" style="margin-top: 20px; display: none;">
                        <h4>Explications Détaillées du Modèle</h4>
                        <div id="mlDetailedExplanationContent">
                            <p>Sélectionnez un modèle et lancez l'entraînement pour voir les explications détaillées...
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Onglet Clustering -->

            <div id="clusters" class="tab-content">
                <div class="section">
                    <h2>Analyse par Clustering K-Means</h2>
                    <p>Identifiez des groupes de numéros avec des comportements similaires.</p>

                    <!-- Boîte d'information sur le clustering -->
                    <div class="info-box">
                        <h4>Clustering K-means</h4>
                        <p>
                        <p>Cette technique est essentielle pour regrouper les numéros de tirage qui partagent des
                            profils historiques similaires (basés sur la fréquence, l'écart, la tendance). L'utilisateur
                            peut choisir des numéros au sein d'un "cluster gagnant".</p>
                        <strong>Analyse en Composantes Principales (PCA) :</strong> Outil de réduction de dimension.
                        Elle permet de transformer un grand nombre de caractéristiques statistiques en un ensemble
                        plus petit de variables non corrélées, tout en conservant la majeure partie de
                        l'information.
                    </div>

                    <!-- Contrôles pour le clustering -->
                    <div class="control-group">
                        <label>Nombre de clusters :</label>
                        <select id="numClusters">
                            <option value="2">2 clusters</option>
                            <option value="3">3 clusters</option>
                            <option value="4">4 clusters</option>
                            <option value="5" selected>5 clusters</option>
                            <option value="6">6 clusters</option>
                            <option value="7">7 clusters</option>
                            <option value="8">8 clusters</option>
                            <option value="9">9 clusters</option>
                            <option value="10">10 clusters</option>
                        </select>
                        <button onclick="performClustering()">Créer les Clusters</button>
                    </div>

                    <!-- Graphique de visualisation des clusters -->
                    <div class="chart-container">
                        <canvas id="clusterChart"></canvas>
                    </div>

                    <!-- Graphique de distribution des clusters -->
                    <div class="chart-container">
                        <canvas id="clusterDistributionChart"></canvas>
                    </div>

                    <!-- Zone d'affichage des résultats du clustering -->
                    <div id="clusterResults"></div>

                    <!-- Explication complémentaire -->
                    <div class="info-box">
                        <strong>Clustering K-Means :</strong> Cette technique regroupe les numéros ayant des
                        caractéristiques similaires (fréquence, écarts, tendances). Les numéros d'un même cluster
                        partagent des patterns communs dans l'historique.
                    </div>
                </div>
            </div>

            <!-- Onglet Statistiques -->

            <div id="statistics" class="tab-content">
                <div class="section">
                    <h2>Analyses Statistiques Avancées</h2>

                    <!-- Boîte d'information sur les analyses statistiques -->
                    <div class="info-box">
                        <h4>Analyse Statistique</h4>
                        <p>
                        <p>Techniques avancées pour l'analyse des données de tirage.
                    </div>

                    <!-- Contrôles pour le type d'analyse statistique -->
                    <div class="control-group">
                        <label>Type d'analyse :</label>
                        <select id="statType">
                            <option value="distribution">Distribution des Numéros</option>
                            <option value="parite">Analyse Parité (Pairs/Impairs)</option>
                            <option value="somme">Distribution des Sommes</option>
                            <option value="gaps">Analyse des Écarts</option>
                            <option value="consecutive">Numéros Consécutifs</option>
                        </select>
                        <button onclick="performStatAnalysis()">Lancer l'Analyse</button>
                    </div>

                    <!-- Graphique pour les analyses statistiques -->
                    <div class="chart-container">
                        <canvas id="statChart"></canvas>
                    </div>

                    <!-- Zone d'affichage des résultats statistiques -->
                    <div id="statResults"></div>
                </div>
            </div>

            <!-- Onglet Évaluation -->

            <div id="evaluation" class="tab-content">
                <div class="section">
                    <h2>Évaluer ma Grille de Loto</h2>
                    <p>Analysez votre grille personnelle selon plusieurs critères statistiques et obtenez un score
                        global.</p>

                    <!-- Boîte d'information sur l'évaluation -->
                    <div class="info-box">
                        <h4>Évaluation :</h4>
                        <p></p>
                        <p>Analyse complète de votre grille selon divers critères statistiques.</p>
                    </div>



                    <!-- Contrôles pour la sélection des numéros -->
                    <div class="control-group">
                        <div class="grid-selection">
                            <div class="grid-title">Sélectionnez vos 5 numéros principaux (1-49) :</div>
                            <!-- Grille de sélection des numéros principaux -->
                            <div class="number-grid-select" id="mainNumbersGrid"></div>

                            <!-- Affichage des numéros principaux sélectionnés -->
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Vos numéros sélectionnés :</div>
                                <div class="selected-numbers-display" id="selectedMainNumbers"></div>
                            </div>

                            <div class="grid-title">Sélectionnez votre numéro chance (1-10) :</div>
                            <!-- Grille de sélection du numéro chance -->
                            <div class="chance-grid-select" id="chanceNumbersGrid"></div>

                            <!-- Affichage du numéro chance sélectionné -->
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Votre numéro chance :</div>
                                <div class="selected-numbers-display" id="selectedChanceNumber"></div>
                            </div>
                        </div>

                        <!-- Boutons d'action -->
                        <button onclick="evaluateGrid()" style="margin-top: 15px;">Évaluer ma Grille</button>
                        <button onclick="generateRandomGrid()"
                            style="margin-top: 15px; background-color: var(--highlight-color);">Générer une Grille
                            Aléatoire</button>
                    </div>

                    <!-- Graphique d'évaluation -->
                    <div class="chart-container">
                        <canvas id="evaluationChart"></canvas>
                    </div>
                    <!-- Zone d'affichage des résultats de l'évaluation -->
                    <div id="evalResults" class="info-box glass-card"></div>
                </div>
            </div>

            <!-- Onglet Simulation -->

            <div id="simulation" class="tab-content">
                <div class="section">
                    <h2>Simulation Monte Carlo</h2>
                    <p>Simulez des milliers de tirages pour tester des stratégies et estimer des probabilités.</p>

                    <!-- Boîte d'information sur les simulations Monte Carlo -->
                    <div class="info-box">
                        <h4>Simulation Monte-Carlo</h4>
                        <p>Les simulations de Monte-Carlo (KMC) sont des algorithmes utilisés dans le but d'estimer la
                            probabilité d'occurrence d'un scénario dans lequel interviennent des paramètres aléatoires.
                            C'est une technique statistique permettant de comprendre l'influence de l'incertitude dans
                            les modèles de Probabilités.</p>
                        <p><strong>Distributions Statistiques Utilisées :</strong></p>
                        <p><strong>Poisson :</strong> Modélise la probabilité qu'un certain nombre d'événements
                            (apparitions d'un numéro) se produisent dans un intervalle de temps donné. Utile pour les
                            faibles fréquences (numéros "en retard").</p>
                        <p><strong>Binomiale :</strong> Modélise le nombre de succès (apparitions d'un numéro) dans une
                            séquence de n tirages indépendants, chacun ayant une probabilité p de succès.</p>
                        <p><strong>Dirichlet :</strong> Distribution complexe souvent utilisée pour modéliser des
                            proportions de catégories. Dans le contexte du Loto, elle peut modéliser la probabilité que
                            les cinq numéros choisis se répartissent de manière déséquilibrée sur les quatre dizaines.
                        </p>
                        <p><strong>Tests Statistiques :</strong></p>
                        <p><strong>Test T (Student) :</strong> Permet de comparer la moyenne d'une série de numéros avec
                            une valeur théorique pour déterminer si l'écart est significatif.</p>
                        <p><strong>Test du Chi-carré (χ²) :</strong> Le test essentiel pour le Loto. Il permet de
                            vérifier si la distribution observée des fréquences des numéros est conforme à une
                            distribution uniforme théorique.</p>
                    </div>

                    <!-- Contrôles pour la simulation -->
                    <div class="control-group">
                        <div class="grid-selection">
                            <div class="grid-title">Sélectionnez vos 5 numéros principaux (1-49) :</div>
                            <!-- Grille de sélection pour la simulation -->
                            <div class="number-grid-select" id="simMainNumbersGrid"></div>

                            <!-- Affichage des numéros sélectionnés pour la simulation -->
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Vos numéros sélectionnés :</div>
                                <div class="selected-numbers-display" id="simSelectedMainNumbers"></div>
                            </div>

                            <div class="grid-title">Sélectionnez votre numéro chance (1-10) :</div>
                            <!-- Grille de sélection du numéro chance pour la simulation -->
                            <div class="chance-grid-select" id="simChanceNumbersGrid"></div>

                            <!-- Affichage du numéro chance sélectionné pour la simulation -->
                            <div class="selected-numbers glass-card">
                                <div class="grid-title">Votre numéro chance :</div>
                                <div class="selected-numbers-display" id="simSelectedChanceNumber"></div>
                            </div>
                        </div>

                        <label>Nombre de simulations :</label>
                        <select id="numSims">
                            <option value="1000">1 000 simulations</option>
                            <option value="10000" selected>10 000 simulations</option>
                            <option value="100000">100 000 simulations</option>
                        </select>
                        <button onclick="runSimulation()">Lancer la Simulation</button>
                    </div>

                    <!-- Indicateur de chargement pour la simulation -->
                    <div class="loading" id="simLoading">
                        <div class="spinner"></div>
                        <p>Simulation en cours...</p>
                    </div>

                    <!-- Grille pour les métriques de simulation -->
                    <div class="grid-2" id="simMetrics"></div>

                    <!-- Graphique principal de simulation -->
                    <div class="chart-container">
                        <canvas id="simChart"></canvas>
                    </div>

                    <!-- Graphique de distribution des simulations -->
                    <div class="chart-container">
                        <canvas id="simDistributionChart"></canvas>
                    </div>

                    <!-- Zone d'affichage des résultats de simulation -->
                    <div id="simResults"></div>
                </div>
            </div>

            <!-- Onglet Matrice -->

            <div id="matrice" class="tab-content">
                <div class="section">
                    <h2> Architecte de Modèles - Matrice Personnalisée</h2>
                    <p>Composez votre propre architecture d'analyse en sélectionnant et combinant différents modèles et
                        algorithmes.</p>

                    <!-- Configuration de la Matrice -->
                    <div class="control-group glass-card">
                        <h3> Configuration de la Matrice</h3>

                        <div class="matrix-config">
                            <!-- Sélection des Modèles -->
                            <div class="model-selection">
                                <h4> Modèles Statistiques</h4>
                                <div class="checkbox-grid">
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixPoisson" data-model="poisson">
                                        <span class="checkmark"></span>
                                        Distribution de Poisson
                                        <div class="model-info">λ = fréquence historique</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixBinomial" data-model="binomial">
                                        <span class="checkmark"></span>
                                        Distribution Binomiale
                                        <div class="model-info">B(n,p) - Pairs/Impairs</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixZipf" data-model="zipf">
                                        <span class="checkmark"></span>
                                        Loi de Zipf
                                        <div class="model-info">Poids = 1/rang^α</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixDirichlet" data-model="dirichlet">
                                        <span class="checkmark"></span>
                                        Distribution de Dirichlet
                                        <div class="model-info">Répartition par dizaines</div>
                                    </label>
                                </div>
                            </div>

                            <!-- Algorithmes ML -->
                            <div class="model-selection">
                                <h4> Algorithmes Machine Learning</h4>
                                <div class="checkbox-grid">
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixRF" data-model="rf">
                                        <span class="checkmark"></span>
                                        Random Forest
                                        <div class="model-info">Forêt de 100 arbres</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixGB" data-model="gb">
                                        <span class="checkmark"></span>
                                        Gradient Boosting
                                        <div class="model-info">Boosting séquentiel</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixLSTM" data-model="lstm">
                                        <span class="checkmark"></span>
                                        LSTM
                                        <div class="model-info">Réseau neuronal temporel</div>
                                    </label>
                                </div>
                            </div>

                            <!-- Techniques Avancées -->
                            <div class="model-selection">
                                <h4> Techniques Avancées</h4>
                                <div class="checkbox-grid">
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixClustering" data-model="clustering">
                                        <span class="checkmark"></span>
                                        Clustering K-Means
                                        <div class="model-info">Groupes de similarité</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixMonteCarlo" data-model="montecarlo">
                                        <span class="checkmark"></span>
                                        Simulation Monte Carlo
                                        <div class="model-info">10,000+ tirages simulés</div>
                                    </label>

                                    <label class="checkbox-item">
                                        <input type="checkbox" id="matrixEnsemble" data-model="ensemble">
                                        <span class="checkmark"></span>
                                        Stacking Ensemble
                                        <div class="model-info">Combinaison de modèles</div>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Paramètres Avancés -->

                        <div class="advanced-settings">
                            <h4> Paramètres Avancés</h4>
                            <div class="settings-grid">
                                <div class="setting-item">
                                    <label>Pondération des modèles :</label>
                                    <select id="weightingMethod">
                                        <option value="equal">Égale</option>
                                        <option value="performance">Par performance</option>
                                        <option value="custom">Personnalisée</option>
                                    </select>
                                </div>

                                <div class="setting-item">
                                    <label>Nombre de combinaisons :</label>
                                    <select id="matrixNumPredictions">
                                        <option value="5">5 combinaisons</option>
                                        <option value="6" selected>6 combinaisons</option>
                                        <option value="15">15 combinaisons</option>
                                        <option value="20">20 combinaisons</option>
                                        <option value="25">25 combinaisons</option>
                                        <option value="30">30 combinaisons</option>
                                        <option value="40">40 combinaisons</option>
                                        <option value="50">50 combinaisons</option>
                                    </select>
                                </div>

                                <div class="setting-item">
                                    <label>Méthode de fusion :</label>
                                    <select id="fusionMethod">
                                        <option value="voting">Vote majoritaire</option>
                                        <option value="weighted">Pondérée</option>
                                        <option value="stacking">Stacking ML</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Boutons d'action -->
                        <div class="matrix-actions">
                            <button onclick="generateMatrixAnalysis()" class="primary-btn">
                                Générer l'Analyse Matricielle
                            </button>
                            <button onclick="saveMatrixConfiguration()" class="secondary-btn">
                                Sauvegarder la Configuration
                            </button>
                            <button onclick="loadMatrixConfiguration()" class="secondary-btn">
                                Charger une Configuration
                            </button>
                        </div>
                    </div>

                    <!-- Visualisation de la Matrice -->
                    <div class="matrix-visualization glass-card">
                        <h3> Visualisation de la Matrice</h3>
                        <div id="matrixGraph" class="chart-container" style="height: 300px;">
                            <canvas id="matrixArchitectureChart"></canvas>
                        </div>

                        <div class="matrix-stats">
                            <div class="stat-card">
                                <h4>Modèles Actifs</h4>
                                <div class="value" id="activeModelsCount">0</div>
                            </div>
                            <div class="stat-card">
                                <h4>Complexité</h4>
                                <div class="value" id="matrixComplexity">Faible</div>
                            </div>
                            <div class="stat-card">
                                <h4>Performance Estimée</h4>
                                <div class="value" id="estimatedPerformance">-</div>
                            </div>
                        </div>
                    </div>

                    <!-- Résultats de l'Analyse Matricielle -->
                    <div class="matrix-results">
                        <div class="loading" id="matrixLoading">
                            <div class="progress-container">
                                <div class="progress-bar" id="matrixProgressBar"></div>
                            </div>
                            <div class="progress-text" id="matrixProgressText">Initialisation de la matrice...</div>
                            <div class="progress-stats">
                                <span id="matrixProgressStep">Étape 1/6</span>
                                <span class="progress-percentage" id="matrixProgressPercent">0%</span>
                                <span id="matrixProgressTime">Temps estimé: --</span>
                            </div>
                        </div>

                        <div id="matrixResults" class="results-grid"></div>
                    </div>
                </div>
            </div>

            <!-- Onglet Programme -->

            <div id="programme" class="tab-content">
                <div class="section">
                    <h2>Programme</h2>
                    <p>Documentation technique, structure du programme et code source complet.</p>

                    <div class="control-group">
                        <h3>Documentation Technique</h3>
                        <div class="info-box">
                            <p><strong>Nom :</strong> ARÔME - Analyse Statistique de jeux de loterie</p>
                            <p><strong>Version :</strong> Github-8.5</p>
                            <p><strong>Dernière mise à jour :</strong> <span id="currentDate"></span></p>
                        </div>


                        <div class="section">
                            <h2> Analyse Technique Complète - Architecture ARÔME</h2>
                            <p style="font-size: 1.1em; line-height: 1.6; margin: 20px 0;">
                                Documentation exhaustive de l'architecture, des algorithmes et des implémentations
                                techniques du
                                programme ARÔME.
                        </div>

                        <!-- TABLE DES MATIÈRES -->

                        <div class="info-box"
                            style="/*! background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(102, 126, 234, 0.05) 100%); */ margin-bottom: 30px;">
                            <h3 style="color: var(--text-secondary); margin-bottom: 15px;">Table des Matières</h3>
                            <ol style="line-height: 2; margin-left: 20px;">
                                <li><a href="#architecture-generale">Architecture Générale du Système</a></li>
                                <li><a href="#stack-technique">Stack Technique et Dépendances</a></li>
                                <li><a href="#gestion-donnees">Gestion des Données et Parsing</a></li>
                                <li><a href="#modeles-probabilistes">Modèles Probabilistes - Implémentations
                                        Détaillées</a></li>
                                <li><a href="#machine-learning">Module Machine Learning Complet</a></li>
                                <li><a href="#techniques-avancees">Techniques Avancées et Optimisations</a></li>
                                <li><a href="#systeme-matriciel">Système Matriciel - Innovation Architecturale</a></li>
                                <li><a href="#interface-utilisateur">Interface Utilisateur et Visualisations</a></li>
                                <li><a href="#performance-optimisation">Performance et Optimisations Mémoire</a></li>
                                <li><a href="#qualite-code">Qualité du Code et Maintenabilité</a></li>
                            </ol>
                        </div>

                        <!-- 1. ARCHITECTURE GÉNÉRALE -->
                        <div id="architecture-generale" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                1. Architecture Générale du Système
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">1.1
                                Paradigme
                                Architectural</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                ARÔME adopte une <strong>architecture monopage (SPA - Single Page Application)</strong>
                                entièrement client-side, éliminant toute dépendance serveur pour l'exécution des
                                algorithmes.
                                Cette approche garantit :
                            </p>
                            <ul style="line-height: 1.8; margin-left: 30px; margin-bottom: 15px;">
                                <li><strong>Confidentialité totale</strong> : Aucune donnée utilisateur n'est transmise
                                    sur le
                                    réseau</li>
                                <li><strong>Performance native</strong> : Exploitation directe des ressources GPU/CPU du
                                    navigateur</li>
                                <li><strong>Disponibilité offline</strong> : Fonctionnement complet sans connexion
                                    internet
                                    après chargement initial</li>
                                <li><strong>Scalabilité illimitée</strong> : Pas de limitation serveur, chaque
                                    utilisateur
                                    exploite ses propres ressources</li>
                            </ul>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">1.2
                                Architecture
                                Modulaire en Couches</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Le système est organisé en <strong>6 couches fonctionnelles distinctes</strong> assurant
                                séparation des responsabilités et modularité :
                            </p>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Couche 1 - DATA LAYER</strong></p>
                                <p style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    • Parsing et validation des données CSV<br>
                                    • Structures : <code>historicalData</code>, <code>filteredDraws</code>,
                                    <code>mlFilteredDraws</code><br>
                                    • Fonctions : <code>loadRealData()</code>, <code>parseDrawDate()</code>,
                                    <code>recalculateFrequencies()</code><br>
                                    • Gestion des périodes temporelles et filtres personnalisés
                                </p>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Couche 2 - COMPUTATION LAYER</strong>
                                </p>
                                <p style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    • Implémentations algorithmiques pures<br>
                                    • Modèles probabilistes : Poisson, Binomiale, Zipf, Dirichlet, Gamma, Student,
                                    Chi²<br>
                                    • Algorithmes ML : Random Forest, Gradient Boosting, Logistic, LSTM, Ensemble<br>
                                    • Techniques avancées : K-Means, Monte-Carlo, Stacking
                                </p>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Couche 3 - ORCHESTRATION LAYER</strong>
                                </p>
                                <p style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    • Coordination des workflows complexes<br>
                                    • Système matriciel : sélection, pondération, fusion des modèles<br>
                                    • Gestion des progressions asynchrones<br>
                                    • Fonctions : <code>executeMatrixAnalysis()</code>,
                                    <code>fuseMatrixPredictions()</code>
                                </p>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Couche 4 - VISUALIZATION LAYER</strong>
                                </p>
                                <p style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    • Graphiques interactifs Chart.js (8+ types)<br>
                                    • Animations et transitions fluides<br>
                                    • Thème dark mode glassmorphism<br>
                                    • Responsive design adaptatif
                                </p>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Couche 5 - UI LAYER</strong></p>
                                <p style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    • Navigation multi-onglets (10 sections)<br>
                                    • Grilles de sélection interactives<br>
                                    • Système de recherche avancé<br>
                                    • Gestion événementielle complète
                                </p>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Couche 6 - UTILITIES LAYER</strong></p>
                                <p style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    • Fonctions utilitaires transversales<br>
                                    • Gestion couleurs, encodage, validation<br>
                                    • Helpers mathématiques : <code>weightedRandomSelection()</code>,
                                    <code>encodeDraw()</code><br>
                                    • Système de notifications et alertes
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">1.3 Flux de
                                Données
                                Principal</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Le flux de données suit un pipeline unidirectionnel optimisé :
                            </p>
                            <div
                                style="background: rgba(255,255,255,0.05); padding: 0px; border-radius: 8px; margin-bottom: 15px;">
                                <pre style="margin: 0; color: #4da3ff; line-height: 1.6;">
                                CSV Raw Data
                                    ↓
                                parseDrawDate() + Validation
                                    ↓
                                historicalData.draws (Structure normalisée)
                                    ↓
                                Filtres temporels → filteredDraws / mlFilteredDraws
                                    ↓
                                recalculateFrequencies() → Métriques statistiques
                                    ↓
                                Algorithmes (Probabilistes / ML / Avancés)
                                    ↓
                                Fusion matricielle (si applicable)
                                    ↓
                                Formatage résultats + Visualisations
                                    ↓
                                Affichage UI interactif</pre>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">1.4 Gestion
                                de
                                l'État Global</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                L'application maintient un <strong>état global cohérent</strong> via variables
                                JavaScript
                                globales :
                            </p>
                            <ul style="line-height: 1.8; margin-left: 30px; margin-bottom: 15px;">
                                <li><code>historicalData</code> : Objet central contenant draws, frequencies,
                                    chanceFrequencies
                                </li>
                                <li><code>filteredDraws</code> : Vue filtrée pour analyses générales (périodes
                                    personnalisables)
                                </li>
                                <li><code>mlFilteredDraws</code> : Vue dédiée ML (par défaut : 1 an glissant)</li>
                                <li><code>charts</code> : Registre des instances Chart.js pour mise à jour dynamique
                                </li>
                                <li><code>mlModels</code> : Cache des modèles ML entraînés</li>
                                <li><code>matrixConfiguration</code> : Configuration utilisateur du système matriciel
                                </li>
                                <li><code>selectedMainNumbers / selectedChanceNumber</code> : Sélections utilisateur
                                    grilles
                                </li>
                            </ul>
                        </div>

                        <!-- 2. STACK TECHNIQUE -->

                        <div id="stack-technique" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                2. Stack Technique et Dépendances
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">2.1
                                TensorFlow.js
                                v4.10.0 - Moteur ML</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;">
                                    <strong>Rôle</strong> : Bibliothèque de deep learning pour calculs tensoriels
                                    GPU/CPU et
                                    entraînement de réseaux neuronaux.
                                </p>
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Utilisation dans ARÔME
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Tensors API</strong> : <code>tf.tensor2d()</code>,
                                        <code>tf.tensor3d()</code>
                                        pour manipulation matricielle
                                    </li>
                                    <li><strong>Layers API</strong> : Construction modulaire modèles
                                        (<code>tf.layers.dense</code>, <code>tf.layers.lstm</code>)</li>
                                    <li><strong>Sequential Model</strong> : <code>tf.sequential()</code> pour réseaux
                                        feed-forward</li>
                                    <li><strong>Compilation</strong> : Optimizers (Adam), Loss functions
                                        (binaryCrossentropy),
                                        Metrics (accuracy)</li>
                                    <li><strong>Training</strong> : <code>model.fit()</code> avec callbacks
                                        personnalisés pour
                                        monitoring temps réel</li>
                                    <li><strong>Prediction</strong> : <code>model.predict()</code> avec gestion
                                        automatique
                                        GPU/CPU</li>
                                    <li><strong>Memory Management</strong> : <code>tf.dispose()</code> systématique pour
                                        éviter
                                        fuites mémoire GPU</li>
                                    <li><strong>Async Operations</strong> : <code>tf.nextFrame()</code> pour garantir
                                        réactivité
                                        UI pendant entraînement</li>
                                </ul>
                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #ff9800;">
                                    Architecture hybride CPU/GPU : TF.js détecte automatiquement disponibilité WebGL et
                                    bascule
                                    sur backend optimal.
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">2.2 Math.js
                                v11.8.0
                                - Calculs Symboliques</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;">
                                    <strong>Rôle</strong> : Bibliothèque mathématique avancée pour calculs symboliques,
                                    matriciels et statistiques haute précision.
                                </p>
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Utilisation dans ARÔME
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Distributions statistiques</strong> : Fonctions intégrées pour Poisson,
                                        Binomiale, Gamma</li>
                                    <li><strong>Opérations matricielles</strong> : Produits, inversions, décompositions
                                    </li>
                                    <li><strong>Fonctions spéciales</strong> : Gamma (Γ), Beta (B), exponentielle,
                                        logarithmique
                                    </li>
                                    <li><strong>Précision numérique</strong> : Calculs en virgule flottante double
                                        précision
                                        (64-bit)</li>
                                    <li><strong>Evaluation symbolique</strong> : Parser et évaluer expressions
                                        mathématiques
                                        complexes</li>
                                </ul>
                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #4caf50;">
                                    Math.js évite les approximations natives JavaScript pour garantir exactitude
                                    mathématique.
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">2.3
                                Chart.js v3.9.1
                                - Visualisations</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;">
                                    <strong>Rôle</strong> : Bibliothèque de graphiques interactifs HTML5 Canvas avec
                                    animations
                                    fluides.
                                </p>
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Types de graphiques
                                        implémentés
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Bar Chart</strong> : Fréquences, distributions, comparaisons
                                        statistiques</li>
                                    <li><strong>Line Chart</strong> : Évolutions temporelles, tendances</li>
                                    <li><strong>Radar Chart</strong> : Évaluation multi-critères des grilles</li>
                                    <li><strong>Scatter Chart</strong> : Clustering K-Means, projections PCA</li>
                                    <li><strong>Doughnut Chart</strong> : Répartitions proportionnelles, clusters</li>
                                    <li><strong>Pie Chart</strong> : Distributions catégorielles</li>
                                </ul>
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Personnalisations avancées
                                        :</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li>Thème dark mode cohérent (couleurs blanches sur fond sombre)</li>
                                    <li>Tooltips personnalisés avec callbacks</li>
                                    <li>Animations fluides (easing functions)</li>
                                    <li>Responsive design automatique</li>
                                    <li>Update dynamique sans rerender complet (<code>chart.update()</code>)</li>
                                </ul>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">2.4
                                Dépendances
                                Système</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Aucune dépendance externe à
                                        l'exécution :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li>Fichier HTML unique auto-contenu (4000+ lignes)</li>
                                    <li>CSS inline intégré (design system complet)</li>
                                    <li>JavaScript vanilla pur (pas de frameworks type React/Vue)</li>
                                    <li>Bibliothèques chargées via CDN (TF.js, Math.js, Chart.js)</li>
                                    <li>Données CSV intégrées dans le code source</li>
                                </ul>
                                <p style="line-height: 1.8; margin-top: 15px; font-weight: bold; color: #4da3ff;">
                                    Résultat : Application 100% portable, aucune installation requise, fonctionnement
                                    offline
                                    après premier chargement.
                                </p>
                            </div>
                        </div>

                        <!-- 3. GESTION DES DONNÉES -->

                        <div id="gestion-donnees" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                3. Gestion des Données et Parsing
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">3.1 Parsing
                                CSV
                                Robuste</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                La fonction <code>loadRealData()</code> implémente un parser CSV tolérant aux variations
                                de
                                format :
                            </p>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Pipeline de parsing :</strong></p>
                                <ol style="line-height: 1.8; margin-left: 20px; margin-top: 10px;">
                                    <li><strong>Nettoyage BOM</strong> : Suppression '\ufeff' (Byte Order Mark UTF-8)
                                    </li>
                                    <li><strong>Split lignes</strong> : Regex /[\r\n]+/ pour compatibilité Windows/Unix
                                    </li>
                                    <li><strong>Détection délimiteur</strong> : Auto-détection ';' ou ','</li>
                                    <li><strong>Extraction headers</strong> : Normalisation lowercase + trim</li>
                                    <li><strong>Validation structure</strong> : Vérification colonnes requises (date,
                                        boule_1-5,
                                        numero_chance)</li>
                                    <li><strong>Parsing valeurs</strong> : parseInt avec validation 1-49 pour boules,
                                        1-10 pour
                                        chance</li>
                                    <li><strong>Validation intégrité</strong> : Vérification 5 numéros uniques par
                                        tirage</li>
                                    <li><strong>Tri chronologique</strong> : Ordre décroissant (plus récent en premier)
                                    </li>
                                </ol>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">3.2
                                Fonction
                                parseDrawDate() - Parsing Multi-Format</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Gestion robuste des formats de dates variables :
                            </p>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formats supportés :</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li>DD/MM/YY → 13/10/25 → Date(2025, 9, 13)</li>
                                    <li>DD/MM/YYYY → 13/10/2025 → Date(2025, 9, 13)</li>
                                </ul>
                                <p style="line-height: 1.8; margin-top: 15px; margin-bottom: 10px;"><strong>Logique
                                        intelligente
                                        année 2 chiffres :</strong></p>
                                <pre>if (year < 100) {
                                year += (year < 50) ? 2000 : 1900;  // 25 → 2025, 98 → 1998
                            }</pre>
                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #ff9800;">
                                    Validation stricte : Rejet dates invalides (30/02, 32/01, etc.) avec fallback
                                    Date
                                    courante.
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">3.3
                                Structure de
                                Données Normalisée</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                L'objet <code>historicalData</code> centralise toutes les informations :
                            </p>
                            <pre>historicalData = {
                            draws: [
                                {
                                    date: "24/11/25",           // String format original
                                    numbers: [22, 28, 29, 36, 47],  // Array[5] triés
                                    chance: 1                   // Number 1-10
                                },
                                // ... 400+ tirages historiques
                            ],
                            
                            frequencies: {
                                1: 45,   // Nombre d'apparitions du numéro 1
                                2: 52,
                                // ... 49 entrées
                            },
                            
                            chanceFrequencies: {
                                1: 38,   // Nombre d'apparitions du numéro chance 1
                                2: 41,
                                // ... 10 entrées
                            }
                        }</pre>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">3.4 Système
                                de
                                Filtres Temporels</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Deux systèmes de filtrage indépendants pour analyses générales et ML :
                            </p>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0 0 10px 0; line-height: 1.8;"><strong>A) Filtres Généraux
                                        (filteredDraws)</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Tous les tirages</strong> : Pas de filtre (défaut)</li>
                                    <li><strong>Année</strong> : Sélection année spécifique (ex: 2024)</li>
                                    <li><strong>Mois</strong> : Sélection mois + année (ex: Janvier 2025)</li>
                                    <li><strong>Période personnalisée</strong> : Date début + date fin</li>
                                </ul>
                                <p style="margin: 15px 0 0 0; line-height: 1.8; font-style: italic;">
                                    → Fonction : <code>applyPeriodFilter()</code> +
                                    <code>recalculateFrequencies()</code>
                                </p>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0 0 10px 0; line-height: 1.8;"><strong>B) Filtres ML
                                        (mlFilteredDraws)</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Défaut intelligent</strong> : 1 an glissant depuis dernier tirage</li>
                                    <li><strong>Année</strong> : Année spécifique pour entraînement</li>
                                    <li><strong>Mois</strong> : Mois + année</li>
                                    <li><strong>Période personnalisée</strong> : Contrôle total sur dataset entraînement
                                    </li>
                                </ul>
                                <p style="margin: 15px 0 0 0; line-height: 1.8; font-style: italic;">
                                    → Fonction : <code>applyMLPeriodFilter()</code> avec fallback 100 derniers tirages
                                    si vide
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">3.5
                                Recalcul
                                Dynamique des Fréquences</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                La fonction <code>recalculateFrequencies()</code> recalcule métriques après chaque
                                changement de
                                filtre :
                            </p>
                            <pre>function recalculateFrequencies() {
                                // Réinitialisation
                                historicalData.frequencies = {};
                                historicalData.chanceFrequencies = {};
                                
                                // Parcours tirages filtrés
                                filteredDraws.forEach(draw => {
                                    // Incrément compteurs numéros principaux
                                    draw.numbers.forEach(num => {
                                        historicalData.frequencies[num] = 
                                            (historicalData.frequencies[num] || 0) + 1;
                                    });
                                    
                                    // Incrément compteur chance
                                    historicalData.chanceFrequencies[draw.chance] = 
                                        (historicalData.chanceFrequencies[draw.chance] || 0) + 1;
                                });
                            }</pre>
                            <p style="line-height: 1.8; margin-top: 15px; color: #4da3ff;">
                                Complexité : O(n×m) où n = tirages filtrés, m = 5 numéros → Performance linéaire
                                optimale
                            </p>
                        </div>

                        <!-- 4. MODÈLES PROBABILISTES -->
                        <div id="modeles-probabilistes" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                4. Modèles Probabilistes - Implémentations Détaillées
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.1
                                Distribution de
                                Poisson</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    P(X=k) = (λ^k × e^(-λ)) / k!<br>
                                    où λ = fréquence historique relative du numéro
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation
                                        poissonPrediction()
                                        :</strong></p>
                                <pre>function poissonPrediction(frequencies, numPredictions = 5) {
                                const predictions = [];
                                const lambda = {};
                                const totalDraws = Object.values(frequencies).reduce((a,b) => a + b, 0);
                                
                                // Calcul λ pour chaque numéro (fréquence relative)
                                for (let i = 1; i <= 49; i++) {
                                    lambda[i] = (frequencies[i] || 0) / totalDraws;
                                }
                                
                                // Génération prédictions
                                for (let pred = 0; pred < numPredictions; pred++) {
                                    const weights = [];
                                    for (let i = 1; i <= 49; i++) {
                                        // Poids = λ × e^(-λ) pour éviter sur-représentation
                                        const weight = lambda[i] * Math.exp(-lambda[i]);
                                        weights.push({ 
                                            number: i, 
                                            weight: weight > 0 ? weight : 0.0001 
                                        });
                                    }
                                    
                                    // Sélection pondérée
                                    const selected = weightedRandomSelection(weights, 5);
                                    predictions.push(selected);
                                }
                                
                                return predictions;
                            }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Justification mathématique
                                        :</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li>La pondération <code>λ × e^(-λ)</code> correspond à <strong>P(X=1)</strong> dans
                                        la loi
                                        de Poisson</li>
                                    <li>Cette formule pénalise les numéros très fréquents (évite effet "boule de
                                        cristal")</li>
                                    <li>Favorise numéros avec fréquences moyennes optimales</li>
                                    <li>Évite sélection systématique des tops fréquents (répartition équilibrée)</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #667eea;">
                                    <strong>Avantage clé</strong> : Modèle simple mais efficace pour identifier
                                    numéros
                                    "moyennement fréquents" souvent négligés.
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.2
                                Distribution
                                Binomiale</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    P(X=k) = C(n,k) × p^k × (1-p)^(n-k)<br>
                                    où n=5 (numéros par tirage), p = probabilité empirique d'un pair
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation
                                        binomialPrediction()
                                        :</strong></p>
                                <pre>function binomialPrediction(frequencies, numPredictions = 5) {
                                const predictions = [];
                                
                                // 1. Calcul probabilités empiriques pairs/impairs
                                let totalEven = 0, totalOdd = 0;
                                for (let i = 1; i <= 49; i++) {
                                    const freq = frequencies[i] || 0;
                                    if (i % 2 === 0) totalEven += freq;
                                    else totalOdd += freq;
                                }
                                
                                const total = totalEven + totalOdd;
                                const pEven = totalEven / total;  // P(pair)
                                const pOdd = totalOdd / total;     // P(impair)
                                
                                // 2. Séparation numéros pairs/impairs avec fréquences
                                const evenNumbers = [], oddNumbers = [];
                                for (let i = 1; i <= 49; i++) {
                                    const freq = frequencies[i] || 0;
                                    const obj = { number: i, weight: freq + 1 };
                                    if (i % 2 === 0) evenNumbers.push(obj);
                                    else oddNumbers.push(obj);
                                }
                                
                                // 3. Génération prédictions selon loi binomiale
                                for (let pred = 0; pred < numPredictions; pred++) {
                                    const selected = [];
                                    
                                    // Simulation binomiale : combien de pairs parmi 5 ?
                                    let numEven = 0;
                                    for (let i = 0; i < 5; i++) {
                                        if (Math.random() < pEven) numEven++;
                                    }
                                    const numOdd = 5 - numEven;
                                    
                                    // Sélection pondérée pairs
                                    if (numEven > 0) {
                                        const selectedEven = weightedRandomSelection(
                                            evenNumbers, 
                                            Math.min(numEven, evenNumbers.length)
                                        );
                                        selected.push(...selectedEven);
                                    }
                                    
                                    // Sélection pondérée impairs
                                    if (numOdd > 0) {
                                        const availableOdd = oddNumbers.filter(
                                            n => !selected.includes(n.number)
                                        );
                                        const selectedOdd = weightedRandomSelection(
                                            availableOdd, 
                                            Math.min(numOdd, availableOdd.length)
                                        );
                                        selected.push(...selectedOdd);
                                    }
                                    
                                    // Compléter si nécessaire
                                    while (selected.length < 5) {
                                        const random = Math.floor(Math.random() * 49) + 1;
                                        if (!selected.includes(random)) selected.push(random);
                                    }
                                    
                                    predictions.push(selected.sort((a,b) => a - b));
                                }
                                
                                return { 
                                    predictions, 
                                    stats: { 
                                        pEven: (pEven * 100).toFixed(1) + '%',
                                        pOdd: (pOdd * 100).toFixed(1) + '%',
                                        expectedEvenPerDraw: (5 * pEven).toFixed(1),
                                        expectedOddPerDraw: (5 * pOdd).toFixed(1)
                                    }
                                };
                            }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Points techniques clés
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Simulation binomiale réelle</strong> : Chaque numéro tire indépendamment
                                        selon
                                        P(pair)</li>
                                    <li><strong>Équilibre naturel</strong> : Pas de forçage 2-3 ou 3-2, suit
                                        distribution
                                        empirique</li>
                                    <li><strong>Pondération interne</strong> : Sélection au sein pairs/impairs selon
                                        fréquences
                                        historiques</li>
                                    <li><strong>Robustesse</strong> : Gestion cas limites (pas assez de pairs/impairs
                                        disponibles)</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #4caf50;">
                                    <strong>Usage optimal</strong> : Respecte équilibre pairs/impairs historique tout
                                    en
                                    introduisant variabilité naturelle.
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.3 Loi de
                                Zipf
                            </h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    f(r) = 1 / r^s<br>
                                    où r = rang du numéro (1 = plus fréquent), s ≈ 1.0
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation
                                        zipfPrediction()
                                        :</strong></p>
                                <pre>function zipfPrediction(frequencies, numPredictions = 5) {
                                const predictions = [];
                                
                                // 1. Tri numéros par fréquence décroissante (attribution rangs)
                                const sortedNumbers = Object.entries(frequencies)
                                    .filter(([num]) => num >= 1 && num <= 49)
                                    .sort((a, b) => b[1] - a[1])  // Tri décroissant
                                    .map((entry, index) => ({
                                        number: parseInt(entry[0]),
                                        rank: index + 1,           // Rang commence à 1
                                        frequency: entry[1]
                                    }));
                                
                                // 2. Calcul poids Zipf : 1/rang^1.0
                                const weights = sortedNumbers.map(item => ({
                                    number: item.number,
                                    weight: 1 / Math.pow(item.rank, 1.0)
                                }));
                                
                                // 3. Normalisation poids (somme = 1)
                                const totalWeight = weights.reduce((sum, item) => 
                                    sum + item.weight, 0
                                );
                                weights.forEach(item => 
                                    item.weight = item.weight / totalWeight
                                );
                                
                                // 4. Génération prédictions
                                for (let pred = 0; pred < numPredictions; pred++) {
                                    const selected = weightedRandomSelection(weights, 5);
                                    predictions.push(selected);
                                }
                                
                                return predictions;
                            }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Caractéristiques Zipf
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Hiérarchie stricte</strong> : Numéro rang 1 a 2× plus de chances que
                                        rang 2</li>
                                    <li><strong>Favorise tops</strong> : 80% des prédictions concentrées sur top 20%
                                    </li>
                                    <li><strong>Loi puissance</strong> : Décroissance rapide mais longue traîne</li>
                                    <li><strong>Paramètre s=1.0</strong> : Distribution "classique" Zipf (ajustable si
                                        besoin)
                                    </li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #ff9800;">
                                    <strong>Limite</strong> : Tendance conservatrice (favorise historique), moins
                                    adapté si
                                    recherche de "surprises".
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.4
                                Distribution de
                                Dirichlet</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    f(x₁,...,xₖ; α₁,...,αₖ) = (1/B(α)) × Π xᵢ^(αᵢ-1)<br>
                                    où B(α) = fonction Bêta multivariée
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation
                                        dirichletPrediction()
                                        :</strong></p>
                                <pre>function dirichletPrediction(frequencies, numPredictions = 5) {
                                const predictions = [];
                                
                                // 1. Partition numéros par dizaines
                                const decades = {
                                    '1-10': [],  '11-20': [], '21-30': [], 
                                    '31-40': [], '41-49': []
                                };
                                
                                for (let i = 1; i <= 49; i++) {
                                    const freq = frequencies[i] || 0;
                                    const obj = { num: i, freq };
                                    
                                    if (i <= 10) decades['1-10'].push(obj);
                                    else if (i <= 20) decades['11-20'].push(obj);
                                    else if (i <= 30) decades['21-30'].push(obj);
                                    else if (i <= 40) decades['31-40'].push(obj);
                                    else decades['41-49'].push(obj);
                                }
                                
                                // 2. Calcul paramètres α (fréquences totales par dizaine)
                                const alphas = {};
                                for (const [decade, nums] of Object.entries(decades)) {
                                    const totalFreq = nums.reduce((sum, n) => sum + n.freq, 0);
                                    alphas[decade] = totalFreq + 1;  // +1 régularisation
                                }
                                
                                // 3. Normalisation α (somme = 1 pour distribution)
                                const totalAlpha = Object.values(alphas).reduce((a,b) => a + b, 0);
                                for (const decade in alphas) {
                                    alphas[decade] = alphas[decade] / totalAlpha;
                                }
                                
                                // 4. Génération prédictions selon répartition Dirichlet
                                for (let pred = 0; pred < numPredictions; pred++) {
                                    const selected = [];
                                    const decadeNames = Object.keys(decades);
                                    const numPerDecade = [0, 0, 0, 0, 0];  // Compteurs
                                    
                                    // 4a. Simulation Dirichlet : tirer dizaine pour chaque position
                                    for (let i = 0; i < 5; i++) {
                                        let random = Math.random();
                                        let cumulative = 0;
                                        
                                        for (let d = 0; d < decadeNames.length; d++) {
                                            cumulative += alphas[decadeNames[d]];
                                            if (random <= cumulative) {
                                                numPerDecade[d]++;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // 4b. Sélection numéros dans chaque dizaine
                                    for (let d = 0; d < decadeNames.length; d++) {
                                        const decadeName = decadeNames[d];
                                        const numsInDecade = decades[decadeName];
                                        const count = numPerDecade[d];
                                        
                                        for (let c = 0; c < count && selected.length < 5; c++) {
                                            const weights = numsInDecade
                                                .filter(n => !selected.includes(n.num))
                                                .map(n => ({ 
                                                    number: n.num, 
                                                    weight: n.freq + 1 
                                                }));
                                            
                                            if (weights.length > 0) {
                                                const selectedNums = weightedRandomSelection(weights, 1);
                                                selected.push(...selectedNums);
                                            }
                                        }
                                    }
                                    
                                    // 4c. Compléter si nécessaire
                                    while (selected.length < 5) {
                                        const random = Math.floor(Math.random() * 49) + 1;
                                        if (!selected.includes(random)) selected.push(random);
                                    }
                                    
                                    predictions.push(selected.sort((a,b) => a - b));
                                }
                                
                                return {
                                    predictions,
                                    alphas,
                                    interpretation: Object.entries(alphas)
                                        .sort((a,b) => b[1] - a[1])
                                        .map(([decade, weight]) => 
                                            `${decade}: ${(weight * 100).toFixed(1)}%`
                                        )
                                };
                            }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Innovation Dirichlet
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Répartition intelligente</strong> : Assure couverture équilibrée des
                                        dizaines
                                    </li>
                                    <li><strong>Respect proportions historiques</strong> : Pas de forçage arbitraire
                                    </li>
                                    <li><strong>Pondération interne</strong> : Au sein d'une dizaine, favorise numéros
                                        fréquents
                                    </li>
                                    <li><strong>Évite concentration</strong> : Réduit risque "tous les numéros dans
                                        1-10"</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #4caf50;">
                                    <strong>Cas d'usage idéal</strong> : Joueur cherchant diversité géographique sur
                                    grille
                                    (numéros répartis).
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.5
                                Distribution
                                Gamma</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    f(x; k, θ) = x^(k-1) × e^(-x/θ) / (θ^k × Γ(k))<br>
                                    où k = nombre apparitions, θ = temps moyen attente / k
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation
                                        gammaPrediction()
                                        :</strong></p>
                                <pre>function gammaPrediction(frequencies, numPredictions = 5) {
                                    const predictions = [];
                                    
                                    // 1. Calcul temps moyen attente pour chaque numéro
                                    const waitTimes = {};
                                    const totalDraws = Object.values(frequencies)
                                        .reduce((a,b) => a + b, 0) / 5;
                                    
                                    for (let i = 1; i <= 49; i++) {
                                        const freq = frequencies[i] || 0;
                                        // Temps moyen entre apparitions
                                        waitTimes[i] = freq > 0 ? 
                                            totalDraws / freq : 
                                            totalDraws * 2;  // Pénalité pour jamais tirés
                                    }
                                    
                                    // 2. Modélisation Gamma : calcul scores
                                    const gammaScores = [];
                                    for (let i = 1; i <= 49; i++) {
                                        const freq = frequencies[i] || 0;
                                        const avgWait = waitTimes[i];
                                        
                                        // Paramètres Gamma
                                        const k = Math.max(1, freq);        // Shape (nombre occurrences)
                                        const theta = avgWait / k;          // Scale
                                        
                                        // PDF Gamma simplifié (sans Γ(k) complet)
                                        const gammaScore = Math.pow(avgWait, k - 1) * 
                                                        Math.exp(-avgWait / theta) / 
                                                        Math.pow(theta, k);
                                        
                                        gammaScores.push({
                                            number: i,
                                            score: gammaScore,
                                            avgWait: avgWait.toFixed(1),
                                            frequency: freq,
                                            params: { k, theta: theta.toFixed(2) }
                                        });
                                    }
                                    
                                    // 3. Tri par score Gamma décroissant
                                    gammaScores.sort((a,b) => b.score - a.score);
                                    
                                    // 4. Normalisation scores pour pondération
                                    const maxScore = gammaScores[0].score;
                                    const weights = gammaScores.map(item => ({
                                        number: item.number,
                                        weight: (item.score / maxScore) * 100
                                    }));
                                    
                                    // 5. Génération prédictions
                                    for (let pred = 0; pred < numPredictions; pred++) {
                                        const selected = weightedRandomSelection(weights, 5);
                                        predictions.push(selected);
                                    }
                                    
                                    return {
                                        predictions,
                                        stats: {
                                            avgWaitTime: (Object.values(waitTimes)
                                                .reduce((a,b) => a + b, 0) / 49)
                                                .toFixed(1) + " tirages",
                                            totalDraws: totalDraws.toFixed(0),
                                            topNumbers: gammaScores.slice(0, 5).map(s =>
                                                `#${s.number} (attente: ${s.avgWait} tirages, freq: ${s.frequency})`
                                            )
                                        }
                                    };
                                }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Logique Gamma :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Concept "numéros en retard"</strong> : Identifie numéros avec temps
                                        attente
                                        élevé</li>
                                    <li><strong>Équilibrage fréquence/attente</strong> : Score = f(fréquence historique,
                                        temps
                                        écoulé)</li>
                                    <li><strong>Pénalité absence</strong> : Numéros jamais tirés → temps attente × 2
                                    </li>
                                    <li><strong>Probabilité réapparition</strong> : Favorise numéros "dus
                                        statistiquement"</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #ff9800;">
                                    <strong>Limite philosophique</strong> : Hypothèse "retour à la moyenne"
                                    critiquable si
                                    tirages parfaitement indépendants.
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.6 Test T
                                de
                                Student</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    t = (X̄ - μ) / (s/√n)<br>
                                    où X̄ = fréquence observée, μ = fréquence moyenne globale
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation
                                        studentTestPrediction()
                                        :</strong></p>
                                <pre>function studentTestPrediction(frequencies, numPredictions = 5) {
                                const predictions = [];
                                const values = Object.values(frequencies);
                                const n = values.length;
                                
                                // 1. Calcul statistiques descriptives
                                const mean = values.reduce((a,b) => a + b, 0) / n;
                                const variance = values.reduce((sum, val) => 
                                    sum + Math.pow(val - mean, 2), 0
                                ) / (n - 1);
                                const stdDev = Math.sqrt(variance);
                                
                                // 2. Calcul t-scores pour chaque numéro
                                const tScores = [];
                                for (let i = 1; i <= 49; i++) {
                                    const observed = frequencies[i] || 0;
                                    const tScore = Math.abs((observed - mean) / (stdDev / Math.sqrt(n)));
                                    
                                    tScores.push({
                                        number: i,
                                        tScore,
                                        deviation: observed - mean
                                    });
                                }
                                
                                // 3. Tri par t-score décroissant (plus significatifs)
                                tScores.sort((a,b) => b.tScore - a.tScore);
                                
                                // 4. Stratégie mixte : sur-représentés + sous-représentés
                                for (let pred = 0; pred < numPredictions; pred++) {
                                    const selected = [];
                                    
                                    // 4a. Sélection 3 sur-représentés (top 10)
                                    const overRep = tScores
                                        .filter(t => t.deviation > 0)
                                        .slice(0, 10);
                                    
                                    for (let i = 0; i < 3; i++) {
                                        const idx = Math.floor(Math.random() * Math.min(overRep.length, 10));
                                        if (overRep[idx] && !selected.includes(overRep[idx].number)) {
                                            selected.push(overRep[idx].number);
                                        }
                                    }
                                    
                                    // 4b. Compléter avec sous-représentés (top 10)
                                    const underRep = tScores
                                        .filter(t => t.deviation < 0)
                                        .slice(0, 10);
                                    
                                    while (selected.length < 5) {
                                        const idx = Math.floor(Math.random() * Math.min(underRep.length, 10));
                                        if (underRep[idx] && !selected.includes(underRep[idx].number)) {
                                            selected.push(underRep[idx].number);
                                        }
                                    }
                                    
                                    predictions.push(selected.sort((a,b) => a - b));
                                }
                                
                                return {
                                    predictions,
                                    stats: {
                                        mean: mean.toFixed(2),
                                        stdDev: stdDev.toFixed(2),
                                        mostSignificant: tScores.slice(0, 5).map(t =>
                                            `#${t.number} (t=${t.tScore.toFixed(2)})`
                                        )
                                    }
                                };
                            }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Stratégie Student :</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Détection anomalies</strong> : Identifie numéros significativement
                                        écartés de la
                                        moyenne</li>
                                    <li><strong>Mix équilibré</strong> : 60% sur-représentés + 40% sous-représentés</li>
                                    <li><strong>Robustesse statistique</strong> : T-score robuste aux outliers</li>
                                    <li><strong>Interprétation</strong> : Top 5 t-scores = numéros "statistiquement
                                        remarquables"</li>
                                </ul>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">4.7 Test du
                                Chi-Carré</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    χ² = Σ [(O_i - E_i)² / E_i]<br>
                                    où O_i = fréquence observée, E_i = fréquence attendue
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Implémentation chiSquareTest()
                                        :</strong></p>
                                <pre>function chiSquareTest(frequencies) {
                                const values = Object.values(frequencies);
                                const totalDraws = values.reduce((a, b) => a + b, 0);
                                const expectedFreq = totalDraws / 49; // Fréquence attendue uniforme
                                
                                // Calcul du χ²
                                let chiSquare = 0;
                                for (let i = 1; i <= 49; i++) {
                                    const observed = frequencies[i] || 0;
                                    chiSquare += Math.pow(observed - expectedFreq, 2) / expectedFreq;
                                }
                                
                                const degreesOfFreedom = 48; // 49 numéros - 1
                                const criticalValue = 65.17; // Seuil α=0.05, ddl=48
                                const pValue = calculatePValue(chiSquare, degreesOfFreedom);
                                
                                return {
                                    chiSquare: chiSquare.toFixed(2),
                                    isUniform: chiSquare < criticalValue,
                                    pValue: pValue.toFixed(4),
                                    interpretation: chiSquare < criticalValue 
                                        ? "Distribution uniforme (pas de biais détecté)" 
                                        : "Distribution non-uniforme (biais possible)"
                                };
                            }</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Tests d'hypothèses :</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>H₀ (hypothèse nulle)</strong> : Distribution uniforme des numéros</li>
                                    <li><strong>H₁ (hypothèse alternative)</strong> : Distribution non uniforme</li>
                                    <li><strong>Seuil de significativité</strong> : α = 0.05 (5%)</li>
                                    <li><strong>Valeur critique</strong> : χ²₀.₀₅,₄₈ = 65.17</li>
                                    <li><strong>Décision</strong> : Rejeter H₀ si χ² > 65.17</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #4caf50;">
                                    <strong>Usage clé</strong> : Test fondamental pour détecter si certains numéros sont
                                    sur/sous-représentés.
                                </p>
                            </div>
                        </div>

                        <!-- 5. MODULE MACHINE LEARNING -->
                        <div id="machine-learning" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                5. Module Machine Learning Complet
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.1
                                Architecture
                                TensorFlow.js</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Le module ML utilise <strong>TensorFlow.js v4.10.0</strong> pour créer des réseaux
                                neuronaux
                                exécutés directement dans le navigateur :
                            </p>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Modèle Dense de Base :</strong></p>
                                <pre>function createDenseModel(units1 = 64, units2 = 32) {
                                const model = tf.sequential();
                                
                                // Couche 1 : 64 neurones ReLU
                                model.add(tf.layers.dense({
                                    units: units1,
                                    activation: 'relu',
                                    inputShape: [49] // 49 features (un par numéro)
                                }));
                                
                                // Couche 2 : 32 neurones ReLU
                                model.add(tf.layers.dense({
                                    units: units2,
                                    activation: 'relu'
                                }));
                                
                                // Couche de sortie : 49 sorties sigmoid (probabilités)
                                model.add(tf.layers.dense({
                                    units: 49,
                                    activation: 'sigmoid'
                                }));
                                
                                // Compilation
                                model.compile({
                                    optimizer: 'adam',                  // Adaptive Moment Estimation
                                    loss: 'binaryCrossentropy',        // Perte pour classification multi-label
                                    metrics: ['accuracy']               // Métrique de précision
                                });
                                
                                return model;
                            }</pre>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.2
                                Préparation des
                                Données ML</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Fonction <code>prepareMLData()</code> - Transforme les tirages historiques en datasets
                                d'entraînement :
                            </p>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Pipeline de préparation :</strong></p>
                                <ol style="line-height: 1.8; margin-left: 20px; margin-top: 10px;">
                                    <li><strong>Encodage one-hot</strong> : Tirage → Vecteur binaire [49 dimensions]
                                    </li>
                                    <li><strong>Création paires temporelles</strong> : (tirage_n-1, tirage_n)</li>
                                    <li><strong>Split train/test</strong> : 80% entraînement, 20% validation</li>
                                    <li><strong>Normalisation</strong> : Déjà binaire (0 ou 1)</li>
                                </ol>

                                <pre>// Exemple d'encodage
                                Tirage {numbers: [5, 12, 23, 34, 47], chance: 3}
                                    ↓
                                Vecteur [0,0,0,0,1,0,0,0,0,0,0,1,...,1,0] // Position 5, 12, 23, 34, 47 = 1</pre>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.3 Random
                                Forest
                                (Forêt Aléatoire)</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Principe :</strong> Ensemble
                                    de 5-10
                                    petits réseaux neuronaux entraînés sur des sous-ensembles bootstrap.</p>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Algorithme :</strong></p>
                                <pre>Pour chaque arbre i = 1..N_trees :
                                    1. Bootstrap : Échantillon aléatoire avec remise
                                    2. Entraîner modèle dense (32-16 neurones)
                                    3. Stocker le modèle

                                Prédiction finale = Moyenne(prédictions de tous les arbres)</pre>

                                <p style="line-height: 1.8; margin-top: 15px; color: #667eea;">
                                    <strong>Avantages</strong> : Robuste au surapprentissage, variance réduite
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.4
                                Gradient
                                Boosting</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Principe :</strong>
                                    Construction
                                    séquentielle de modèles, chaque nouveau modèle corrige les erreurs du précédent.</p>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule itérative :</strong>
                                </p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    F_m(x) = F_{m-1}(x) + η × h_m(x)<br>
                                    où η = learning rate (0.5), h_m = nouveau modèle faible
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Processus :</strong></p>
                                <ol style="line-height: 1.8; margin-left: 20px;">
                                    <li>Initialiser F₀(x) = moyenne des labels</li>
                                    <li>Pour m = 1..M estimateurs :</li>
                                    <ul style="margin-left: 20px;">
                                        <li>Calculer résidus : r_i = y_i - F_{m-1}(x_i)</li>
                                        <li>Entraîner h_m sur les résidus</li>
                                        <li>Mettre à jour : F_m(x) = F_{m-1}(x) + η × h_m(x)</li>
                                    </ul>
                                </ol>

                                <p style="line-height: 1.8; margin-top: 15px; color: #4caf50;">
                                    <strong>Performance</strong> : Souvent le meilleur modèle individuel (~85%
                                    précision)
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.5 LSTM
                                (Long
                                Short-Term Memory)</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Architecture :</strong> Réseau
                                    neuronal récurrent spécialisé dans les séquences temporelles.</p>

                                <pre>model = tf.sequential();

                            // Couche LSTM : 64 unités avec mémoire long terme
                            model.add(tf.layers.lstm({
                                units: 64,
                                inputShape: [1, 49], // [timesteps, features]
                                returnSequences: false,
                                dropout: 0.2 // Régularisation
                            }));

                            // Couche de sortie
                            model.add(tf.layers.dense({
                                units: 49,
                                activation: 'sigmoid'
                            }));</pre>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Portes LSTM :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Porte d'oubli</strong> : f_t = σ(W_f · [h_{t-1}, x_t] + b_f)</li>
                                    <li><strong>Porte d'entrée</strong> : i_t = σ(W_i · [h_{t-1}, x_t] + b_i)</li>
                                    <li><strong>Porte de sortie</strong> : o_t = σ(W_o · [h_{t-1}, x_t] + b_o)</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; color: #667eea;">
                                    <strong>Usage</strong> : Capture les dépendances temporelles sur 10+ tirages
                                    consécutifs
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.6
                                Ensemble
                                Stacking</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Architecture à 2 niveaux
                                        :</strong>
                                </p>

                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    NIVEAU 1 (Modèles de base)<br>
                                    ├── Random Forest (prédiction₁)<br>
                                    ├── Gradient Boosting (prédiction₂)<br>
                                    ├── Régression Logistique (prédiction₃)<br>
                                    └── LSTM (prédiction₄)<br>
                                    <br>
                                    NIVEAU 2 (Méta-modèle)<br>
                                    └── Combinaison pondérée → Prédiction finale
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Formule de fusion :</strong>
                                </p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    P_final(x) = Σ w_i × P_i(x)<br>
                                    où Σ w_i = 1 (poids normalisés)
                                </div>

                                <p style="line-height: 1.8; margin-top: 15px; color: #f44336;">
                                    <strong>Performance</strong> : Jusqu'à 88% de précision en combinant les forces de
                                    chaque
                                    modèle
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">5.7
                                Optimisations
                                et Callbacks</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                L'entraînement utilise des callbacks avancés pour monitoring temps réel :
                            </p>

                            <pre>await model.fit(xs, ys, {
                            epochs: 30,
                            batchSize: 8,
                            shuffle: true,
                            callbacks: {
                                onEpochEnd: async (epoch, logs) => {
                                    // Mise à jour UI
                                    updateProgress(epoch, logs.loss, logs.acc);
                                    
                                    // Libérer frame pour réactivité
                                    await tf.nextFrame();
                                }
                            }
                        });</pre>

                            <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Techniques d'optimisation
                                    :</strong></p>
                            <ul style="line-height: 1.8; margin-left: 20px;">
                                <li><strong>Adam Optimizer</strong> : Taux d'apprentissage adaptatif (lr=0.001)</li>
                                <li><strong>Batch Normalization</strong> : Stabilisation de l'entraînement</li>
                                <li><strong>Dropout 0.2</strong> : Régularisation contre surapprentissage</li>
                                <li><strong>Early Stopping</strong> : Arrêt si perte stagne 5 époques</li>
                                <li><strong>Memory Management</strong> : tf.dispose() systématique</li>
                            </ul>
                        </div>

                        <!-- 6. TECHNIQUES AVANCÉES -->
                        <div id="techniques-avancees" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                6. Techniques Avancées et Optimisations
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">6.1
                                Clustering
                                K-Means - Implémentation Complète</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Principe algorithmique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    Objectif : argmin_S Σ_{i=1}^k Σ_{x∈S_i} ||x - μ_i||²<br>
                                    où μ_i = centroïde du cluster i
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Algorithme itératif :</strong>
                                </p>
                                <ol style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>Initialisation</strong> : k centroïdes aléatoires ou via K-Means++</li>
                                    <li><strong>Affectation</strong> : Assigner chaque point au centroïde le plus proche
                                    </li>
                                    <li><strong>Mise à jour</strong> : Recalculer les centroïdes comme moyenne des
                                        points
                                        assignés</li>
                                    <li><strong>Convergence</strong> : Répéter 2-3 jusqu'à stabilisation (changement <
                                            ε)</li>
                                </ol>

                                <p style="line-height: 1.8; margin-top: 15px; color: #4caf50;">
                                    <strong>Application ARÔME</strong> : Regroupement de numéros avec patterns
                                    statistiques
                                    similaires (fréquence, écarts, tendances)
                                </p>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">6.2
                                Simulation
                                Monte-Carlo Avancée - Importance Sampling</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Principe mathématique
                                        :</strong></p>
                                <div
                                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    E[f(X)] ≈ (1/N) × Σ f(X_i) × w(X_i)<br>
                                    où w(X_i) = π(X_i) / q(X_i) (poids d'importance)
                                </div>

                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Distribution composite q(x)
                                        :</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>40% Fréquences</strong> : q₁(x) ∝ Freq_historique(x) + ε</li>
                                    <li><strong>30% Écarts</strong> : q₂(x) ∝ exp(-Gap(x)/τ)</li>
                                    <li><strong>30% Tendances</strong> : q₃(x) ∝ Freq_récente(x)</li>
                                </ul>

                                <p style="line-height: 1.8; margin-top: 15px; font-style: italic; color: #2196f3;">
                                    <strong>Avantage clé</strong> : Réduction de variance par échantillonnage
                                    préférentiel dans
                                    les zones à haute probabilité
                                </p>
                            </div>
                        </div>

                        <!-- 7. SYSTÈME MATRICIEL -->
                        <div id="systeme-matriciel" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                7. Système Matriciel - Innovation Architecturale
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">7.1 Concept
                                Fondamental</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Le système matriciel représente une <strong>innovation architecturale majeure</strong>
                                permettant la composition modulaire de pipelines d'analyse personnalisés.
                            </p>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>Principe : Synergie > Somme des
                                        parties</strong>
                                </p>
                                <p style="margin: 15px 0 0 20px; line-height: 1.8;">
                                    La combinaison intelligente de multiples modèles génère des prédictions plus
                                    robustes que
                                    chaque modèle individuel grâce à :
                                </p>
                                <ul style="line-height: 1.8; margin-left: 40px; margin-top: 10px;">
                                    <li><strong>Diversité des modèles</strong> : Capture de patterns complémentaires
                                    </li>
                                    <li><strong>Réduction du biais</strong> : Compensation des faiblesses individuelles
                                    </li>
                                    <li><strong>Stabilité accrue</strong> : Diminution de la variance globale</li>
                                </ul>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">7.2
                                Architecture en
                                3 Couches</h4>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>COUCHE 1 - Modèles Statistiques</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px; margin-top: 10px;">
                                    <li>Poisson, Binomiale, Zipf, Dirichlet</li>
                                    <li>Gamma, Student, Chi-Carré</li>
                                    <li>Basés sur distributions probabilistes théoriques</li>
                                </ul>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>COUCHE 2 - Algorithmes Machine
                                        Learning</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px; margin-top: 10px;">
                                    <li>Random Forest, Gradient Boosting</li>
                                    <li>LSTM (Deep Learning)</li>
                                    <li>Apprentissage supervisé sur historique réel</li>
                                </ul>
                            </div>

                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="margin: 0; line-height: 1.8;"><strong>COUCHE 3 - Techniques Avancées</strong>
                                </p>
                                <ul style="line-height: 1.8; margin-left: 20px; margin-top: 10px;">
                                    <li>Clustering K-Means, Monte-Carlo</li>
                                    <li>Ensemble Stacking</li>
                                    <li>Méta-apprentissage et optimisation combinée</li>
                                </ul>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">7.3
                                Méthodes de
                                Fusion des Prédictions</h4>

                            <p style="line-height: 1.8; margin-bottom: 15px;"><strong>A) Vote Majoritaire
                                    (Voting)</strong></p>
                            <div
                                style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                P_final(x) = mode({P₁(x), P₂(x), ..., Pₙ(x)})<br>
                                Sélection des 5 numéros les plus votés parmi tous les modèles
                            </div>

                            <p style="line-height: 1.8; margin-bottom: 15px;"><strong>B) Fusion Pondérée
                                    (Weighted)</strong></p>
                            <div
                                style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                P_final(x) = Σ w_i × P_i(x)<br>
                                où Σ w_i = 1 (poids normalisés selon performance historique)
                            </div>

                            <p style="line-height: 1.8; margin-bottom: 15px;"><strong>C) Stacking ML
                                    (Meta-Learning)</strong>
                            </p>
                            <div
                                style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                Niveau 1: Prédictions de base → Features méta<br>
                                Niveau 2: Méta-modèle entraîné sur les prédictions niveau 1
                            </div>
                        </div>

                        <!-- 8. INTERFACE UTILISATEUR -->
                        <div id="interface-utilisateur" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                8. Interface Utilisateur et Visualisations
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">8.1 Design
                                System
                                Complet</h4>
                            <ul style="line-height: 1.8; margin-left: 20px;">
                                <li><strong>Thème Dark Mode Glassmorphism</strong> : Arrière-plans semi-transparents
                                    avec effet
                                    de flou</li>
                                <li><strong>Palette cohérente</strong> : Variables CSS globales pour cohérence visuelle
                                </li>
                                <li><strong>Typographie Inter</strong> : Police système moderne et lisible</li>
                                <li><strong>Animations fluides</strong> : Transitions CSS 0.3s ease pour tous les
                                    éléments
                                    interactifs</li>
                            </ul>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">8.2
                                Navigation
                                Multi-Onglets (10 Sections)</h4>
                            <ol style="line-height: 1.8; margin-left: 20px;">
                                <li><strong>Accueil</strong> : Vue d'ensemble et configuration période</li>
                                <li><strong>Fréquences</strong> : Analyse histogrammes numéros/chance</li>
                                <li><strong>Probabilités</strong> : 8+ modèles statistiques</li>
                                <li><strong>Clustering</strong> : Visualisation K-Means interactive</li>
                                <li><strong>Statistiques</strong> : Tests avancés et distributions</li>
                                <li><strong>Machine Learning</strong> : Entraînement et prédictions ML</li>
                                <li><strong>Évaluation</strong> : Scoring multi-critères grilles</li>
                                <li><strong>Simulation</strong> : Monte-Carlo 100,000+ tirages</li>
                                <li><strong>Matrice</strong> : Système expert composition</li>
                                <li><strong>Programme</strong> : Documentation technique complète</li>
                            </ol>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">8.3
                                Graphiques
                                Chart.js - Configuration Détaillée</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Types implémentés :</strong></p>
                            <ul style="line-height: 1.8; margin-left: 20px;">
                                <li><strong>Bar Chart</strong> : Fréquences, distributions comparatives</li>
                                <li><strong>Line Chart</strong> : Évolutions temporelles, tendances</li>
                                <li><strong>Radar Chart</strong> : Évaluation multi-critères (5 axes)</li>
                                <li><strong>Scatter Chart</strong> : Clustering 2D, projections PCA</li>
                                <li><strong>Doughnut Chart</strong> : Répartitions proportionnelles clusters</li>
                                <li><strong>Pie Chart</strong> : Distributions catégorielles simples</li>
                            </ul>

                            <p style="line-height: 1.8; margin-top: 15px; color: #4da3ff;">
                                <strong>Personnalisations</strong> : Thème cohérent, tooltips avancés, animations
                                fluides,
                                responsive automatique
                            </p>
                        </div>

                        <!-- 9. PERFORMANCE ET OPTIMISATION -->
                        <div id="performance-optimisation" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                9. Performance et Optimisations Mémoire
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">9.1 Gestion
                                Mémoire
                                TensorFlow.js</h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <p style="line-height: 1.8; margin-bottom: 10px;"><strong>Stratégies critiques
                                        :</strong></p>
                                <ul style="line-height: 1.8; margin-left: 20px;">
                                    <li><strong>tf.dispose()</strong> : Libération explicite systématique de tous les
                                        tenseurs
                                    </li>
                                    <li><strong>tf.tidy()</strong> : Nettoyage automatique scope local</li>
                                    <li><strong>tf.nextFrame()</strong> : Libération thread UI entre epochs</li>
                                    <li><strong>Batch processing</strong> : Traitement par lots (batch_size=8-32)</li>
                                </ul>

                                <pre>// Exemple de gestion mémoire optimale
                        const result = tf.tidy(() => {
                            const xs = tf.tensor2d(features);
                            const prediction = model.predict(xs);
                            return prediction.arraySync(); // Extrait données avant dispose
                        }); // xs et prediction automatiquement libérés</pre>
                            </div>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">9.2
                                Optimisations
                                Algorithmiques</h4>
                            <ul style="line-height: 1.8; margin-left: 20px;">
                                <li><strong>Complexité linéaire</strong> : O(n) pour parsing CSV et calculs fréquences
                                </li>
                                <li><strong>Mémoïzation</strong> : Cache résultats calculs répétitifs (encodage tirages)
                                </li>
                                <li><strong>Lazy loading</strong> : Chargement graphiques uniquement lors affichage
                                    onglet</li>
                                <li><strong>Debouncing</strong> : Limitation fréquence recalculs lors filtrage</li>
                            </ul>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">9.3
                                Asynchronisme
                                et Réactivité UI</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                Toutes les opérations longues (ML, simulations) utilisent <code>async/await</code> avec
                                callbacks de progression :
                            </p>
                            <pre>await model.fit(xs, ys, {
                            callbacks: {
                                onEpochEnd: async (epoch, logs) => {
                                    updateProgressBar(epoch, logs);
                                    await tf.nextFrame(); //  CRITIQUE pour UI responsive
                                }
                            }
                        });</pre>
                        </div>

                        <!-- 10. QUALITÉ DU CODE -->
                        <div id="qualite-code" class="info-box" style="margin-bottom: 30px;">
                            <h3
                                style="color: var(--text-secondary); margin-bottom: 20px; font-size: 1.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                10. Qualité du Code et Maintenabilité
                            </h3>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">10.1
                                Standards de
                                Codage</h4>
                            <ul style="line-height: 1.8; margin-left: 20px;">
                                <li><strong>Nommage explicite</strong> : Variables et fonctions auto-documentées</li>
                                <li><strong>Commentaires JSDoc</strong> : Documentation inline pour fonctions complexes
                                </li>
                                <li><strong>Séparation responsabilités</strong> : Architecture en couches distinctes
                                </li>
                                <li><strong>DRY Principle</strong> : Factorisation fonctions utilitaires transversales
                                </li>
                            </ul>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">10.2
                                Gestion des
                                Erreurs</h4>
                            <pre>try {
                                const data = await loadRealData();
                                if (!data || data.length === 0) {
                                    throw new Error("Aucune donnée valide");
                                }
                                processData(data);
                            } catch (error) {
                                console.error('❌ Erreur chargement:', error);
                                alert('Erreur: ' + error.message);
                                // Fallback sur données simulées
                                initApp();
                            }</pre>

                            <h4 style="color: var(--text-secondary); margin-top: 20px; margin-bottom: 10px;">10.3
                                Métriques </h4>
                            <div
                                style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                <div
                                    style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                                    <p style="margin: 0; line-height: 1.8;"><strong> Points forts</strong></p>
                                    <ul style="line-height: 1.8; margin-left: 20px; margin-top: 10px;">
                                        <li>Fichier unique auto-contenu (4000+ lignes)</li>
                                        <li>Aucune dépendance externe runtime</li>
                                        <li>100% JavaScript vanilla (pas de framework)</li>
                                        <li>Architecture modulaire claire (6 couches)</li>
                                    </ul>


                                </div>
                            </div>
                        </div>

                        <!-- CONCLUSION -->

                        <div class="info-box"
                            style="/*! background: var(--glass-bg); */ padding: 20px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 15px;">
                            <h3 style="color: var(--text-secondary); margin-bottom: 15px;"> Conclusion Technique</h3>
                            <p style="line-height: 1.8;">
                                ARÔME représente une <strong>synthèse réussie</strong> entre rigueur mathématique et
                                innovation
                                technologique.
                                L'application démontre qu'il est possible de créer des outils d'analyse statistique
                                avancés
                                entièrement client-side,
                                sans compromis sur la puissance de calcul grâce à TensorFlow.js et Math.js.
                            </p>
                            <p style="line-height: 1.8; margin-top: 15px;">
                                <strong>Points d'excellence :</strong> Architecture modulaire extensible, gestion
                                mémoire optimisée,
                                interface utilisateur moderne et intuitive, documentation technique exhaustive.
                            <div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Onglet Index -->

            <div id="index" class="tab-content">

                <!-- Dans <div id="index" class="tab-content"> -->
                <div style="margin: 20px 0;">
                    <input type="text" id="indexSearchInput" placeholder="🔍 Rechercher dans l'index..." style="width: 100%; padding: 15px; border-radius: 8px; 
                            border: 1px solid rgba(255,255,255,0.2); 
                            background: rgba(255,255,255,0.05); color: white; 
                            font-size: 1rem;">
                </div>

                <div class="section">
                    <h2> Répertoir </h2>
                    <p style="font-size: 1.05em; margin-bottom: 30px;">
                        Catalogue exhaustif des modèles statistiques, algorithmes de machine learning et techniques
                        d'analyse implémentés dans la plateforme.
                    </p>

                    <!-- Conteneur pour afficher tous les résultats -->
                    <div id="indexFullResults"></div>
                </div>
            </div>

            <script>

                // ============================================================================
                // VARIABLES GLOBALES ET CONFIGURATION
                // ============================================================================

                let charts = {};                    // Stockage des graphiques Chart.js
                let historicalData = null;          // Données historiques des tirages
                let realDrawData = [];              // Données réelles intégrées
                let isRealDataLoaded = false;       // Indicateur de chargement des données


                // Modèles de Machine Learning
                let mlModels = {                    // Objet contenant les modèles ML
                    rf: null,                       // Random Forest
                    gb: null,                       // Gradient Boosting  
                    logistic: null,                 // Régression Logistique
                    ensemble: null,                 // Ensemble Stacking
                    lstm: null                      // LSTM Deep Learning
                };

                // Sélections utilisateur
                let selectedMainNumbers = [];       // Numéros principaux sélectionnés
                let mlCurrentPeriod = 'all';        // Période d'entraînement ML
                let mlFilteredDraws = [];           // Tirages filtrés pour ML
                let selectedChanceNumber = null;    // Numéro chance sélectionné
                let simSelectedMainNumbers = [];    // Numéros pour simulation
                let simSelectedChanceNumber = null; // Chance pour simulation

                // ============================================================================
                // FONCTION DE PARSING DE DATE ROBUSTE
                // ============================================================================

                /**
                 * Parse les dates au format DD/MM/YY ou DD/MM/YYYY
                 * @param {string} dateStr - Date au format "13/10/25" ou "13/10/2025"
                 * @returns {Date} - Objet Date valide
                 */
                function parseDrawDate(dateStr) {
                    if (!dateStr || typeof dateStr !== 'string') {
                        console.warn(' Date invalide:', dateStr);
                        return new Date(); // fallback à aujourd'hui
                    }

                    // Format attendu : DD/MM/YY ou DD/MM/YYYY
                    const parts = dateStr.trim().split('/');

                    if (parts.length !== 3) {
                        console.warn(' Format date incorrect:', dateStr);
                        return new Date(dateStr); // tentative de parsing natif
                    }

                    let day = parseInt(parts[0], 10);
                    let month = parseInt(parts[1], 10) - 1; // Mois en JS : 0-11
                    let year = parseInt(parts[2], 10);

                    // Gérer l'année sur 2 chiffres (25 → 2025)
                    if (year < 100) {
                        year += (year < 50) ? 2000 : 1900;
                    }

                    const date = new Date(year, month, day);

                    // Vérification de validité
                    if (isNaN(date.getTime())) {
                        console.warn(' Date invalide après parsing:', dateStr);
                        return new Date();
                    }

                    return date;
                }

                // ============================================================================
                // FONCTIONS UTILITAIRES MANQUANTES (CRITIQUES)
                // ============================================================================

                /**
                 * Sélection aléatoire pondérée de nombres uniques
                 * Utilisée par : Poisson, Zipf, Binomiale, Gamma, Dirichlet
                 * @param {Array} weights - Tableau d'objets {number, weight}
                 * @param {number} count - Nombre d'éléments à sélectionner
                 * @returns {Array} - Tableau de nombres triés
                 */
                function weightedRandomSelection(weights, count) {
                    // Validation des entrées
                    if (!Array.isArray(weights) || weights.length === 0) {
                        console.error('weightedRandomSelection: weights invalide');
                        return [];
                    }

                    if (count <= 0 || count > weights.length) {
                        console.warn(`weightedRandomSelection: count=${count} ajusté à ${Math.min(count, weights.length)}`);
                        count = Math.min(Math.max(1, count), weights.length);
                    }

                    const selected = [];
                    const available = [...weights]; // Copie pour ne pas modifier l'original

                    for (let i = 0; i < count; i++) {
                        if (available.length === 0) {
                            console.warn('weightedRandomSelection: plus de choix disponibles');
                            break;
                        }

                        // Calcul du poids total
                        const totalWeight = available.reduce((sum, item) => {
                            const weight = item.weight || 0;
                            return sum + Math.max(0, weight); // Poids négatifs = 0
                        }, 0);

                        // Si tous les poids sont nuls, sélection uniforme
                        if (totalWeight === 0) {
                            const randomIndex = Math.floor(Math.random() * available.length);
                            selected.push(available[randomIndex].number);
                            available.splice(randomIndex, 1);
                            continue;
                        }

                        // Sélection pondérée par roulette
                        let random = Math.random() * totalWeight;

                        for (let j = 0; j < available.length; j++) {
                            random -= Math.max(0, available[j].weight || 0);

                            if (random <= 0) {
                                selected.push(available[j].number);
                                available.splice(j, 1);
                                break;
                            }
                        }
                    }

                    // Tri croissant pour cohérence avec le Loto
                    return selected.sort((a, b) => a - b);
                }

                /**
                 * Simulation Monte-Carlo pour prédictions
                 * Génère des combinaisons basées sur des simulations massives
                 * @param {Object} frequencies - Fréquences historiques {numero: count}
                 * @param {number} numSimulations - Nombre de simulations (défaut: 10000)
                 * @param {number} topCombinations - Nombre de meilleures combinaisons à retourner
                 * @returns {Object} - {predictions, stats}
                 */
                function monteCarloSimulation(frequencies, numSimulations = 10000, topCombinations = 10) {
                    console.log(` Démarrage simulation Monte-Carlo: ${numSimulations} itérations`);

                    // 1. Calcul des probabilités empiriques
                    const totalDraws = Object.values(frequencies).reduce((a, b) => a + b, 0);
                    const probabilities = {};

                    for (let i = 1; i <= 49; i++) {
                        const freq = frequencies[i] || 0;
                        probabilities[i] = freq / totalDraws;
                    }

                    // 2. Stockage des combinaisons simulées
                    const combinationsCount = new Map();

                    // 3. Simulations
                    for (let sim = 0; sim < numSimulations; sim++) {
                        const combination = [];

                        // Tirage pondéré de 5 numéros
                        const weights = [];
                        for (let i = 1; i <= 49; i++) {
                            weights.push({
                                number: i,
                                weight: (frequencies[i] || 0) + 1 // +1 pour éviter poids nul
                            });
                        }

                        const drawnNumbers = weightedRandomSelection(weights, 5);

                        // Clé unique pour la combinaison (triée)
                        const key = drawnNumbers.sort((a, b) => a - b).join('-');
                        combinationsCount.set(key, (combinationsCount.get(key) || 0) + 1);
                    }

                    // 4. Tri des combinaisons par fréquence d'apparition
                    const sortedCombinations = Array.from(combinationsCount.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, topCombinations);

                    // 5. Formatage des résultats
                    const predictions = sortedCombinations.map(([key, count]) => {
                        const numbers = key.split('-').map(n => parseInt(n));
                        const probability = (count / numSimulations * 100).toFixed(4);

                        return {
                            main: numbers,
                            chance: Math.floor(Math.random() * 10) + 1, // Chance aléatoire
                            frequency: count,
                            probability: probability + '%',
                            score: count
                        };
                    });

                    // 6. Statistiques globales
                    const uniqueCombinations = combinationsCount.size;
                    const avgOccurrence = numSimulations / uniqueCombinations;
                    const topScore = sortedCombinations[0][1];

                    const stats = {
                        totalSimulations: numSimulations,
                        uniqueCombinations: uniqueCombinations,
                        avgOccurrence: avgOccurrence.toFixed(2),
                        topScore: topScore,
                        topProbability: ((topScore / numSimulations) * 100).toFixed(4) + '%',
                        coverageRate: ((uniqueCombinations / numSimulations) * 100).toFixed(2) + '%'
                    };

                    console.log(' Simulation Monte-Carlo terminée:', stats);

                    return {
                        predictions: predictions,
                        stats: stats,
                        allCombinations: sortedCombinations
                    };
                }

                /**
                 * Simulation Monte-Carlo optimisée avec méthode d'importance sampling
                 * Version avancée avec réduction de variance
                 */
                function monteCarloAdvanced(frequencies, numSimulations = 10000, topCombinations = 10) {
                    console.log(` Monte-Carlo Avancé: ${numSimulations} simulations avec importance sampling`);

                    // 1. Calcul des statistiques historiques
                    const stats = {
                        frequencies: {},
                        gaps: {}, // Écarts depuis dernière apparition
                        trends: {} // Tendances récentes
                    };

                    // Analyse des 50 derniers tirages pour tendances
                    const recentDraws = filteredDraws.slice(0, 50);
                    for (let i = 1; i <= 49; i++) {
                        stats.frequencies[i] = frequencies[i] || 0;

                        // Calcul de l'écart (gap)
                        let gap = 0;
                        for (const draw of filteredDraws) {
                            gap++;
                            if (draw.numbers.includes(i)) break;
                        }
                        stats.gaps[i] = gap;

                        // Tendance récente (poids sur 50 derniers tirages)
                        stats.trends[i] = recentDraws.filter(draw =>
                            draw.numbers.includes(i)
                        ).length;
                    }

                    // 2. Calcul des poids d'importance
                    const importanceWeights = {};
                    for (let i = 1; i <= 49; i++) {
                        const freqWeight = stats.frequencies[i] / filteredDraws.length;
                        const gapWeight = Math.exp(-stats.gaps[i] / 10); // Décroissance exponentielle
                        const trendWeight = stats.trends[i] / 50;

                        // Combinaison pondérée (40% freq, 30% gap, 30% trend)
                        importanceWeights[i] = (
                            0.4 * freqWeight +
                            0.3 * gapWeight +
                            0.3 * trendWeight
                        );
                    }

                    // Normalisation
                    const totalWeight = Object.values(importanceWeights).reduce((a, b) => a + b, 0);
                    for (let i = 1; i <= 49; i++) {
                        importanceWeights[i] = (importanceWeights[i] / totalWeight) * 100;
                    }

                    // 3. Simulations avec importance sampling
                    const combinationsScore = new Map();

                    for (let sim = 0; sim < numSimulations; sim++) {
                        const weights = [];
                        for (let i = 1; i <= 49; i++) {
                            weights.push({
                                number: i,
                                weight: importanceWeights[i] * 1000 // Échelle pour précision
                            });
                        }

                        const combination = weightedRandomSelection(weights, 5);
                        const key = combination.sort((a, b) => a - b).join('-');

                        // Score basé sur les poids combinés
                        const comboScore = combination.reduce((sum, num) =>
                            sum + importanceWeights[num], 0
                        );

                        if (!combinationsScore.has(key)) {
                            combinationsScore.set(key, {
                                count: 0,
                                totalScore: 0,
                                numbers: combination
                            });
                        }

                        const entry = combinationsScore.get(key);
                        entry.count++;
                        entry.totalScore += comboScore;
                    }

                    // 4. Classement par score moyen (qualité × fréquence)
                    const rankedCombinations = Array.from(combinationsScore.entries())
                        .map(([key, data]) => ({
                            key: key,
                            numbers: data.numbers,
                            frequency: data.count,
                            avgScore: data.totalScore / data.count,
                            finalScore: data.count * (data.totalScore / data.count) // Produit
                        }))
                        .sort((a, b) => b.finalScore - a.finalScore)
                        .slice(0, topCombinations);

                    // 5. Formatage des résultats
                    const predictions = rankedCombinations.map((combo, index) => ({
                        main: combo.numbers,
                        chance: Math.floor(Math.random() * 10) + 1,
                        frequency: combo.frequency,
                        avgScore: combo.avgScore.toFixed(2),
                        rank: index + 1,
                        probability: ((combo.frequency / numSimulations) * 100).toFixed(4) + '%'
                    }));

                    return {
                        predictions: predictions,
                        stats: {
                            totalSimulations: numSimulations,
                            uniqueCombinations: combinationsScore.size,
                            method: 'Importance Sampling',
                            weights: importanceWeights
                        }
                    };
                }

                // Test rapide au chargement
                console.log('Fonctions utilitaires chargées:', {
                    weightedRandomSelection: typeof weightedRandomSelection,
                    monteCarloSimulation: typeof monteCarloSimulation,
                    monteCarloAdvanced: typeof monteCarloAdvanced
                });


                // Gestion des périodes
                let currentPeriod = 'all';          // Période courante
                let filteredDraws = [];             // Tirages filtrés
                let availableYears = [];            // Années disponibles


                // ============================================================================
                // VARIABLES GLOBALES POUR LA MATRICE
                // ============================================================================

                let matrixConfiguration = {
                    statisticalModels: [],
                    mlModels: [],
                    advancedTechniques: [],
                    weighting: 'equal',
                    fusion: 'voting',
                    numPredictions: 10
                };

                let matrixCharts = {

                };

                // ============================================================================
                // DONNÉES RÉELLES INTÉGRÉES
                // ============================================================================

                const realLotoDataCSV =
                    `date;boule_1;boule_2;boule_3;boule_4;boule_5;numero_chance
                
                Mercredi 26/11/2025;9;14;16;26;33;5
                Lundi 24/11/2025;22;28;29;36;47;1
                22/11/25;7;10;34;40;45;6
                19/11/25;46;26;33;45;24;2
                17/11/25;26;45;28;17;7;6	
                15/11/25;11;5;23;22;24;3
                12/11/25;8;29;33;37;3;2	
                10/11/25;8;37;9;16;45;2	
                08/11/25;16;32;48;36;27;8	
                05/11/25;45;29;31;23;19;4	
                03/11/25;32;3;49;29;2;2	
                01/11/25;3;33;17;24;26;6	
                29/10/25;7;6;45;34;35;8	
                27/10/25;48;47;23;45;10;8	
                25/10/25;6;16;4;5;35;1	
                22/10/25;49;29;31;4;39;	1	
                20/10/25;38;24;12;43;34;1	
                18/10/25;17;49;47;11;19;1	
                15/10/25;17;1;22;9;48;5	
                13/10/25;2;11;36;45;49;7
                11/10/25;5;3;40;32;12;4
                08/10/25;5;47;39;10;25;7
                06/10/25;22;10;30;1;26;9
                04/10/25;6;45;31;29;4;8
                01/10/25;10;5;41;35;44;7
                29/09/25;27;32;44;5;17;4
                27/09/25;45;46;3;19;11;4
                24/09/25;3;32;21;23;31;4
                22/09/25;10;41;5;29;47;4
                20/09/25;36;18;10;39;47;7
                17/09/25;2;25;47;32;37;3
                15/09/25;30;2;10;32;17;5
                13/09/25;29;31;6;41;28;10
                10/09/25;18;49;14;24;17;7
                08/09/25;30;42;21;10;22;8
                06/09/25;26;21;18;17;4;1
                03/09/25;31;30;24;2;36;5
                01/09/25;44;38;33;25;4;4
                30/08/25;23;15;34;39;4;10
                27/08/25;7;12;31;20;40;6
                25/08/25;32;22;42;21;14;2
                23/08/25;49;23;15;20;30;9
                20/08/25;2;27;36;40;1;7
                18/08/25;8;27;21;2;26;6
                16/08/25;31;5;18;45;4;7
                13/08/25;47;9;31;36;42;1
                11/08/25;40;30;44;1;10;2
                09/08/25;19;6;38;21;15;8
                06/08/25;5;23;18;19;49;8
                04/08/25;6;43;10;31;34;5
                02/08/25;14;22;15;31;48;2
                30/07/25;13;20;3;41;37;3
                28/07/25;25;6;22;27;30;5
                26/07/25;1;19;44;32;9;3
                23/07/25;18;30;5;43;29;2
                21/07/25;5;9;26;16;33;8
                19/07/25;25;18;19;45;24;1
                16/07/25;3;34;45;41;36;4
                14/07/25;37;28;27;6;20;3
                12/07/25;39;49;36;48;13;7
                09/07/25;36;1;45;22;25;4
                07/07/25;18;41;27;26;3;6
                05/07/25;32;46;37;25;42;10
                02/07/25;25;19;29;38;30;10
                30/06/25;17;12;8;10;18;4
                28/06/25;4;2;20;3;28;6
                25/06/25;32;26;2;5;44;10
                23/06/25;20;42;38;44;25;10
                21/06/25;34;25;49;18;20;2
                18/06/25;9;36;13;24;19;3
                16/06/25;1;2;13;39;4;1
                14/06/25;25;21;31;44;16;8
                11/06/25;9;19;7;18;15;6
                09/06/25;25;38;5;34;12;10
                07/06/25;7;30;40;37;45;1
                04/06/25;2;45;41;18;38;8
                02/06/25;25;36;29;8;13;2
                31/05/25;4;11;27;37;39;3
                28/05/25;26;32;25;38;4;4
                26/05/25;41;24;36;33;45;7
                24/05/25;49;39;45;14;32;9
                21/05/25;11;49;10;18;7;3
                19/05/25;8;30;43;42;33;4
                17/05/25;18;13;9;12;14;3
                14/05/25;34;42;31;12;43;10
                12/05/25;12;24;6;16;2;4
                10/05/25;49;12;42;29;13;9
                07/05/25;32;36;1;41;46;9
                05/05/25;8;34;38;47;9;3
                03/05/25;38;39;37;19;42;5
                30/04/25;8;31;42;3;5;8
                28/04/25;6;3;14;35;36;2
                26/04/25;39;15;23;45;3;9
                23/04/25;5;3;35;20;15;8
                21/04/25;5;13;30;48;8;5
                19/04/25;19;11;32;16;20;6
                16/04/25;13;38;27;40;39;10
                14/04/25;33;40;25;31;37;9
                12/04/25;3;18;10;13;47;1
                09/04/25;36;16;12;47;46;9
                07/04/25;21;34;13;38;2;1
                05/04/25;14;30;22;8;27;7
                02/04/25;45;5;34;15;4;9
                31/03/25;3;4;28;16;38;4
                29/03/25;14;31;41;7;12;5
                26/03/25;4;41;21;19;11;7
                24/03/25;35;29;47;46;21;1
                22/03/25;3;49;36;20;23;6
                19/03/25;15;14;3;45;12;3
                17/03/25;16;32;26;9;20;7
                15/03/25;27;6;31;21;40;7
                12/03/25;21;10;24;32;16;7
                10/03/25;23;24;13;15;39;1
                08/03/25;18;2;10;3;11;2
                05/03/25;47;28;7;26;30;4
                03/03/25;41;13;28;6;4;1
                01/03/25;14;28;33;9;8;4
                26/02/25;44;11;3;15;17;9
                24/02/25;32;5;13;38;46;5
                22/02/25;28;30;23;39;25;7
                19/02/25;42;23;16;32;28;5
                17/02/25;40;3;14;20;34;6
                15/02/25;48;42;13;49;6;3
                12/02/25;1;37;41;30;23;5
                10/02/25;39;44;12;29;2;6
                08/02/25;49;26;11;43;42;8
                05/02/25;14;8;24;28;5;9
                03/02/25;29;48;32;27;44;8
                01/02/25;34;46;11;30;36;5
                29/01/25;29;41;17;27;19;2
                27/01/25;24;39;48;3;10;3
                25/01/25;45;35;44;5;19;8
                22/01/25;29;36;23;44;38;9
                20/01/25;19;28;36;40;6;2
                18/01/25;11;1;4;33;44;7
                15/01/25;1;22;40;27;28;2
                13/01/25;31;3;24;41;7;2
                11/01/25;42;20;6;29;41;9
                08/01/25;14;34;38;24;26;8
                06/01/25;3;31;8;16;42;7
                04/01/25;17;20;9;19;29;2
                01/01/25;8;11;2;25;21;4
                30/12/24;13;31;29;1;21;10
                28/12/24;31;7;37;39;13;6
                25/12/24;46;6;22;44;13;8
                23/12/24;22;17;38;2;13;7
                21/12/24;41;16;6;28;36;8
                18/12/24;8;27;26;46;14;2
                16/12/24;43;5;26;36;6;3
                14/12/24;30;22;44;40;24;7
                11/12/24;28;24;8;43;19;6
                09/12/24;38;5;9;25;6;6
                07/12/24;9;21;24;30;28;9
                04/12/24;40;21;7;34;3;1
                02/12/24;48;16;22;41;4;10
                30/11/24;21;4;10;38;19;1
                27/11/24;15;7;31;35;20;6
                25/11/24;13;7;37;49;3;5
                23/11/24;37;33;36;34;20;2
                20/11/24;35;37;45;48;27;5
                18/11/24;17;12;3;8;6;9
                16/11/24;46;5;29;7;19;4
                13/11/24;9;12;32;39;13;10
                11/11/24;8;35;46;6;11;6
                09/11/24;36;12;35;23;26;8
                06/11/24;26;8;23;15;6;5
                04/11/24;17;15;16;39;35;2
                02/11/24;31;49;43;21;1;6
                30/10/24;4;44;10;29;8;1
                28/10/24;21;39;43;9;41;3
                26/10/24;9;17;30;20;11;8
                23/10/24;27;1;34;44;40;2
                21/10/24;7;34;19;15;11;7
                19/10/24;10;2;44;46;45;5
                16/10/24;1;25;48;21;35;3
                14/10/24;42;18;47;41;20;2
                12/10/24;35;33;43;6;37;6
                09/10/24;5;26;22;31;33;7
                07/10/24;49;26;5;7;1;8
                05/10/24;30;16;7;13;43;6
                02/10/24;2;10;4;49;12;9
                30/09/24;1;33;49;24;17;9
                28/09/24;47;39;4;42;45;1
                25/09/24;5;25;10;6;1;9
                23/09/24;9;40;28;27;7;6
                21/09/24;32;30;4;2;19;9
                18/09/24;2;44;42;47;23;5
                16/09/24;27;31;48;30;17;8
                14/09/24;15;32;11;49;6;4
                11/09/24;28;30;10;39;24;5
                09/09/24;18;8;41;17;3;3
                07/09/24;48;43;31;9;15;9
                04/09/24;4;2;26;22;40;8
                02/09/24;27;12;26;6;5;6
                31/08/24;43;18;28;40;14;1
                28/08/24;42;30;11;33;37;3
                26/08/24;6;28;3;12;24;2
                24/08/24;13;29;30;20;36;5
                21/08/24;3;20;15;31;19;7
                19/08/24;10;18;20;19;28;5
                17/08/24;3;4;22;48;49;1
                14/08/24;25;17;46;28;23;5
                12/08/24;16;18;45;38;31;8
                10/08/24;36;31;37;28;17;10
                07/08/24;27;47;24;39;46;9
                05/08/24;24;21;7;31;27;3
                03/08/24;47;4;2;14;34;2
                31/07/24;25;3;45;47;49;7
                29/07/24;20;22;32;34;31;7
                27/07/24;21;8;28;42;47;4
                24/07/24;40;11;18;8;47;2
                22/07/24;49;35;25;27;42;9
                20/07/24;5;30;16;47;15;7
                17/07/24;35;40;17;6;47;4
                15/07/24;4;10;30;38;24;10
                13/07/24;21;5;6;24;42;8
                10/07/24;16;3;5;39;11;9
                08/07/24;7;42;31;8;24;6
                06/07/24;46;13;47;18;34;5
                03/07/24;4;1;24;21;42;3
                01/07/24;22;7;28;6;3;7
                29/06/24;17;24;30;43;1;7
                26/06/24;21;10;38;41;25;8
                24/06/24;48;47;6;45;1;6
                22/06/24;10;34;25;38;29;3
                19/06/24;35;11;18;46;30;2
                17/06/24;28;6;11;46;25;2
                15/06/24;8;16;42;30;40;2
                12/06/24;28;3;6;33;13;4
                10/06/24;47;5;34;28;39;8
                08/06/24;35;39;18;43;31;7
                05/06/24;4;6;35;47;7;1
                03/06/24;9;15;39;49;48;7
                01/06/24;27;2;48;43;3;8
                29/05/24;10;19;28;38;37;7
                27/05/24;41;19;32;42;47;1
                25/05/24;19;26;42;18;20;1
                22/05/24;46;23;21;32;20;10
                20/05/24;12;32;36;6;29;8
                18/05/24;14;34;37;15;45;2
                15/05/24;21;16;9;20;15;1
                13/05/24;26;13;25;12;18;4
                11/05/24;6;39;24;13;43;8
                08/05/24;7;34;6;3;36;7
                06/05/24;1;4;35;39;21;5
                04/05/24;2;16;19;12;6;3
                01/05/24;17;42;25;5;15;7
                29/04/24;49;47;20;3;30;7
                27/04/24;18;34;27;14;44;6
                24/04/24;38;25;40;41;39;7
                22/04/24;48;20;39;8;47;1
                20/04/24;13;10;22;24;16;7
                17/04/24;48;6;8;17;24;10
                15/04/24;24;2;21;36;31;6
                13/04/24;45;7;29;19;38;8
                10/04/24;18;1;33;9;39;2
                08/04/24;2;22;46;21;49;9
                06/04/24;27;2;36;43;6;5
                03/04/24;26;46;5;12;36;4
                01/04/24;9;17;15;12;26;8
                30/03/24;40;41;28;8;42;2
                27/03/24;28;45;2;15;23;7
                25/03/24;37;1;22;26;31;5
                23/03/24;47;49;20;34;32;1
                20/03/24;24;46;3;22;32;5
                18/03/24;36;48;30;20;40;8
                16/03/24;12;10;37;25;49;2
                13/03/24;5;29;4;10;13;1
                11/03/24;18;48;36;16;45;10
                09/03/24;29;28;25;7;35;2
                06/03/24;12;8;43;46;49;8
                04/03/24;25;8;18;27;37;8
                02/03/24;20;13;27;26;17;4
                28/02/24;2;38;46;27;43;3
                26/02/24;7;45;30;8;20;10
                24/02/24;14;45;37;22;25;3
                21/02/24;42;22;9;33;45;3
                19/02/24;35;23;16;42;8;2
                17/02/24;2;19;13;23;36;3
                14/02/24;28;15;3;46;36;2
                12/02/24;36;40;5;30;43;1
                10/02/24;44;15;37;34;40;8
                07/02/24;24;13;23;6;34;4
                05/02/24;36;3;33;34;42;2
                03/02/24;42;4;23;15;12;1
                31/01/24;34;2;13;15;31;8
                29/01/24;27;26;8;9;15;4
                27/01/24;47;2;14;33;30;5
                24/01/24;25;9;34;31;32;5
                22/01/24;32;29;37;20;5;9
                20/01/24;19;41;42;43;45;2
                17/01/24;29;8;37;22;39;10
                15/01/24;11;7;15;23;19;4
                13/01/24;12;15;21;29;48;6
                10/01/24;12;28;32;45;38;9
                08/01/24;6;48;11;49;46;2
                06/01/24;49;19;22;40;45;2
                03/01/24;36;1;45;9;14;3
                01/01/24;4;41;16;13;6;10
                30/12/23;36;12;7;11;38;6
                27/12/23;16;41;26;28;13;8
                25/12/23;9;32;7;47;1;1
                23/12/23;39;28;26;5;29;10
                20/12/23;2;3;29;30;31;10
                18/12/23;30;3;15;41;16;9
                16/12/23;1;15;12;30;44;1
                13/12/23;4;19;22;18;7;10
                11/12/23;25;48;16;12;49;10
                09/12/23;40;34;36;28;15;10
                06/12/23;29;1;43;37;27;7
                04/12/23;41;44;38;8;10;2
                02/12/23;25;19;12;11;28;4
                29/11/23;21;30;6;31;10;1
                27/11/23;19;8;46;26;9;9
                25/11/23;1;9;19;13;11;8
                22/11/23;18;45;41;4;17;2
                20/11/23;30;15;34;46;41;2
                18/11/23;12;21;48;29;20;3
                15/11/23;22;7;16;30;2;1
                13/11/23;46;39;23;45;13;7
                11/11/23;17;22;35;25;19;6
                08/11/23;2;49;1;36;14;9
                06/11/23;18;10;40;34;31;10
                04/11/23;20;13;46;40;25;7
                01/11/23;32;46;27;1;16;1
                30/10/23;30;34;8;1;13;4
                28/10/23;31;38;22;32;34;2
                25/10/23;22;12;30;35;33;10
                23/10/23;10;3;40;26;22;4
                21/10/23;47;14;28;3;25;10
                18/10/23;22;13;46;49;3;1
                16/10/23;6;7;37;25;47;9
                14/10/23;13;14;27;4;20;1
                11/10/23;10;16;15;6;24;8
                09/10/23;9;16;32;30;23;6
                07/10/23;5;12;42;9;26;2
                04/10/23;26;21;40;27;31;1
                02/10/23;6;40;17;15;3;1
                30/09/23;33;48;25;23;41;1
                27/09/23;44;14;30;25;17;3
                25/09/23;4;13;27;46;21;4
                23/09/23;26;28;40;37;6;8
                20/09/23;48;19;37;16;29;1
                18/09/23;5;30;40;35;17;6
                16/09/23;42;43;32;40;15;4
                13/09/23;11;27;30;48;49;8
                11/09/23;31;44;40;13;28;6
                09/09/23;15;7;3;42;4;4
                06/09/23;47;30;15;33;4;10
                04/09/23;27;13;2;11;36;10
                02/09/23;10;33;47;1;7;10
                30/08/23;46;31;20;45;39;10
                28/08/23;9;35;23;37;28;7
                26/08/23;15;14;21;34;45;5
                23/08/23;46;29;25;8;34;7
                21/08/23;3;17;4;36;22;6
                19/08/23;27;8;32;11;4;10
                16/08/23;24;41;19;35;27;9
                14/08/23;44;13;3;27;49;9
                12/08/23;9;20;44;1;39;9
                09/08/23;6;31;45;14;3;9
                07/08/23;11;1;15;48;47;7
                05/08/23;40;42;2;7;10;2
                02/08/23;18;12;32;9;23;9
                31/07/23;1;47;22;33;4;1
                29/07/23;1;49;29;18;37;4
                26/07/23;17;49;18;28;11;7
                24/07/23;12;1;31;45;17;7
                22/07/23;37;33;42;36;31;3
                19/07/23;35;5;39;19;11;9
                17/07/23;47;6;20;9;41;9
                15/07/23;7;32;42;45;12;6
                12/07/23;31;18;34;27;26;8
                10/07/23;14;3;10;44;8;2
                08/07/23;6;19;48;32;10;5
                05/07/23;22;8;19;7;15;5
                03/07/23;42;23;2;8;35;7
                01/07/23;24;7;18;15;9;10
                28/06/23;49;34;36;12;42;10
                26/06/23;14;21;48;16;26;3
                24/06/23;30;40;3;21;2;4
                21/06/23;20;35;27;19;12;4
                19/06/23;39;42;38;29;49;3
                17/06/23;28;43;29;38;44;3
                14/06/23;14;9;16;12;33;2
                12/06/23;12;26;28;19;21;2
                10/06/23;28;16;11;32;49;10
                07/06/23;41;28;3;4;23;8
                05/06/23;3;46;25;10;13;5
                03/06/23;46;44;37;2;39;4
                31/05/23;43;9;40;28;13;3
                29/05/23;12;38;28;24;36;3
                27/05/23;25;24;31;34;9;9
                24/05/23;20;11;36;17;28;10
                22/05/23;43;33;42;22;37;4
                20/05/23;25;18;3;8;37;6
                17/05/23;8;2;11;47;40;7
                15/05/23;12;9;48;7;29;4
                13/05/23;43;6;25;34;9;5
                10/05/23;45;12;44;15;9;1
                08/05/23;43;47;16;39;4;5
                06/05/23;47;25;42;2;30;10
                03/05/23;17;23;13;20;45;8
                01/05/23;15;41;33;44;5;10
                29/04/23;40;48;36;22;3;5
                26/04/23;3;18;24;11;14;10
                24/04/23;41;23;25;1;49;2
                22/04/23;12;26;48;13;35;1
                19/04/23;43;41;5;46;34;5
                17/04/23;3;18;42;13;43;9
                15/04/23;32;17;15;19;29;10
                12/04/23;18;26;10;30;15;7
                10/04/23;45;24;15;10;49;2
                08/04/23;19;35;48;3;42;10
                05/04/23;31;33;16;29;39;2
                03/04/23;49;15;39;31;46;4
                01/04/23;44;48;17;12;35;8
                29/03/23;34;1;32;14;11;9
                27/03/23;1;11;23;41;34;9
                25/03/23;3;34;29;7;11;4
                22/03/23;24;38;33;12;20;2
                20/03/23;38;19;10;26;7;8
                18/03/23;7;31;8;48;32;5
                15/03/23;37;20;15;5;17;2
                13/03/23;47;45;35;42;19;2
                11/03/23;6;34;14;33;18;6
                08/03/23;10;7;46;16;35;5
                06/03/23;24;38;41;18;5;7
                04/03/23;42;40;35;25;12;6
                01/03/23;18;39;45;14;21;8
                27/02/23;5;37;14;6;2;1
                25/02/23;34;19;3;1;43;3
                22/02/23;37;35;3;24;31;4
                20/02/23;35;43;41;22;16;7
                18/02/23;12;24;1;13;5;9
                15/02/23;20;24;5;44;28;6
                13/02/23;20;8;33;27;35;2
                11/02/23;43;9;15;47;45;9
                08/02/23;44;24;16;21;34;7
                06/02/23;32;13;5;21;6;3
                04/02/23;42;26;31;13;16;2
                01/02/23;12;48;38;35;9;5
                30/01/23;35;27;8;30;34;5
                28/01/23;15;44;5;30;45;5
                25/01/23;32;26;44;18;21;10
                23/01/23;28;6;10;35;32;9
                21/01/23;41;4;45;18;24;6
                18/01/23;7;35;48;39;11;8
                16/01/23;5;31;10;19;28;4
                14/01/23;22;36;40;13;14;9
                11/01/23;8;16;17;3;47;9
                09/01/23;38;1;48;30;20;3
                07/01/23;8;43;7;21;34;6
                04/01/23;3;5;49;38;25;10
                02/01/23;49;39;45;41;1;5
                31/12/22;35;39;16;11;23;8
                28/12/22;29;1;3;35;8;8
                26/12/22;6;23;32;49;48;4
                24/12/22;12;41;47;46;6;6
                21/12/22;11;22;15;12;21;7
                19/12/22;43;35;6;31;36;4
                17/12/22;46;27;42;23;8;3
                14/12/22;15;37;4;20;6;10
                12/12/22;46;25;47;2;35;10
                10/12/22;6;43;29;13;27;2
                07/12/22;2;12;38;15;10;5
                05/12/22;36;45;9;24;17;7
                03/12/22;32;19;34;26;27;9
                30/11/22;44;18;28;49;30;5
                28/11/22;24;46;9;2;13;6
                26/11/22;5;7;28;23;2;5
                23/11/22;46;36;45;15;19;4
                21/11/22;45;33;47;15;23;7
                19/11/22;40;24;19;1;28;8
                16/11/22;1;8;48;38;3;1
                14/11/22;28;23;34;44;14;5
                12/11/22;14;44;34;25;4;7
                09/11/22;15;2;1;41;30;9
                07/11/22;24;8;9;40;31;7
                05/11/22;40;6;38;23;32;10
                02/11/22;45;7;38;4;26;2
                31/10/22;34;25;45;44;4;7
                29/10/22;33;28;48;44;26;4
                26/10/22;45;30;4;2;23;5
                24/10/22;43;28;33;37;29;1
                22/10/22;12;2;25;35;7;10
                19/10/22;35;16;38;46;25;8
                17/10/22;38;49;20;16;40;2
                15/10/22;31;16;27;24;46;1
                12/10/22;17;44;7;40;39;3
                10/10/22;19;40;32;13;46;7
                08/10/22;17;20;48;16;34;7
                05/10/22;32;23;39;35;14;7
                03/10/22;20;40;31;7;23;1
                01/10/22;8;7;35;36;26;2
                28/09/22;12;39;26;14;29;10
                26/09/22;29;49;35;18;39;1
                24/09/22;25;6;32;7;4;10
                21/09/22;3;12;22;9;37;10
                19/09/22;5;7;44;15;33;1
                17/09/22;12;17;1;20;3;3
                14/09/22;40;10;38;26;45;1
                12/09/22;4;49;20;7;21;10
                10/09/22;25;3;8;49;24;5
                07/09/22;20;35;30;3;29;9
                05/09/22;5;1;35;27;40;4
                03/09/22;35;24;44;38;32;6
                31/08/22;9;39;10;15;45;7
                29/08/22;5;10;28;34;22;4
                27/08/22;32;39;22;11;34;3
                24/08/22;39;42;36;27;22;10
                22/08/22;39;46;2;9;44;9
                20/08/22;21;38;17;1;46;2
                17/08/22;16;5;14;29;17;3
                15/08/22;34;4;48;42;22;3
                13/08/22;17;38;37;11;39;2
                10/08/22;15;35;11;28;9;2
                08/08/22;41;22;3;37;40;2
                06/08/22;37;28;23;38;6;1
                03/08/22;45;10;5;40;32;5
                01/08/22;38;1;4;23;30;6
                30/07/22;14;21;24;2;38;6
                27/07/22;13;43;31;47;46;10
                25/07/22;26;42;13;7;24;2
                23/07/22;15;47;39;25;41;9
                20/07/22;29;21;31;47;17;4
                18/07/22;18;29;49;37;5;8
                16/07/22;3;33;4;49;14;3
                13/07/22;30;48;7;31;46;3
                11/07/22;10;5;49;47;1;1
                09/07/22;37;24;34;9;8;2
                06/07/22;43;16;10;25;44;4
                04/07/22;18;20;4;12;26;8
                02/07/22;32;20;22;46;34;9
                29/06/22;16;47;43;24;26;9
                27/06/22;34;31;36;24;37;1
                25/06/22;2;47;40;31;49;9
                22/06/22;17;40;10;27;23;2
                20/06/22;27;47;23;48;14;3
                18/06/22;31;1;12;32;28;9
                15/06/22;11;37;44;13;21;6
                13/06/22;44;45;46;43;31;10
                11/06/22;7;28;4;11;10;8
                08/06/22;38;33;39;27;26;5
                06/06/22;20;5;22;23;18;5
                04/06/22;9;23;17;42;6;5
                01/06/22;33;4;35;22;2;7
                30/05/22;22;12;38;13;14;2
                28/05/22;20;27;21;26;7;7
                25/05/22;37;30;24;27;45;10
                23/05/22;30;26;48;41;47;6
                21/05/22;1;12;41;7;21;4
                18/05/22;14;23;22;45;36;7
                16/05/22;21;33;4;14;32;1
                14/05/22;4;44;29;32;24;4
                11/05/22;23;45;7;2;46;10
                09/05/22;6;33;7;9;15;2
                07/05/22;23;37;38;7;15;3
                04/05/22;37;30;17;12;41;2
                02/05/22;46;20;13;47;8;7
                30/04/22;6;27;5;21;47;9
                27/04/22;8;13;1;43;31;10
                25/04/22;31;36;42;23;8;7
                23/04/22;44;20;11;9;42;4
                20/04/22;45;46;4;13;33;7
                18/04/22;10;39;33;9;47;5
                16/04/22;4;41;30;27;21;6
                13/04/22;36;29;44;46;35;8
                11/04/22;32;3;22;18;17;10
                09/04/22;3;15;13;29;40;10
                06/04/22;6;20;48;12;38;7
                04/04/22;23;22;33;36;10;6
                02/04/22;15;6;11;28;24;10
                30/03/22;12;34;16;26;10;7
                28/03/22;16;48;21;5;26;10
                26/03/22;40;10;37;34;12;5
                23/03/22;20;2;29;39;18;10
                21/03/22;10;26;46;35;5;9
                19/03/22;44;38;33;49;41;7
                16/03/22;1;49;12;39;24;3
                14/03/22;11;5;32;49;9;6
                12/03/22;16;47;33;21;5;5
                09/03/22;32;8;21;41;25;4
                07/03/22;8;27;29;15;41;4
                05/03/22;37;26;36;14;1;3
                02/03/22;46;4;3;43;22;6
                28/02/22;43;9;21;36;27;2
                26/02/22;29;39;28;22;30;3
                23/02/22;33;15;6;12;14;8
                21/02/22;2;6;10;32;17;5
                19/02/22;32;24;49;39;40;1
                16/02/22;22;24;41;21;32;2
                14/02/22;26;13;29;15;20;5
                12/02/22;45;22;28;40;37;10
                09/02/22;44;48;31;46;21;1
                07/02/22;37;15;18;31;46;3
                05/02/22;48;31;24;11;38;9
                02/02/22;11;37;49;28;40;4
                31/01/22;25;32;31;36;10;8
                29/01/22;42;29;25;46;8;9
                26/01/22;14;16;33;38;45;10
                24/01/22;15;38;7;4;40;2
                22/01/22;26;3;39;17;30;8
                19/01/22;44;27;41;8;43;6
                17/01/22;4;27;5;15;22;9
                15/01/22;19;10;30;13;47;8
                12/01/22;23;20;1;26;44;4
                10/01/22;14;43;34;41;35;9
                08/01/22;22;42;43;17;25;10
                05/01/22;17;45;30;32;6;4
                03/01/22;33;36;34;38;22;5
                01/01/22;30;36;14;6;39;5
                29/12/21;21;18;33;49;48;7
                27/12/21;32;20;6;12;14;8
                25/12/21;6;25;48;21;37;10
                22/12/21;41;20;46;11;24;1
                20/12/21;22;23;12;47;25;1
                18/12/21;10;46;2;31;38;8
                15/12/21;34;47;11;37;38;8
                13/12/21;23;38;36;18;19;1
                11/12/21;16;45;34;42;26;9
                08/12/21;28;26;1;30;16;4
                06/12/21;29;16;36;7;15;6
                04/12/21;23;18;34;5;44;5
                01/12/21;26;18;3;49;46;6
                29/11/21;30;26;35;44;31;4
                27/11/21;25;28;46;12;27;4
                24/11/21;14;34;39;24;47;8
                22/11/21;19;12;8;41;16;5
                20/11/21;44;9;18;17;42;8
                17/11/21;37;40;36;4;43;6
                15/11/21;34;7;8;41;42;8
                13/11/21;39;13;12;31;26;6
                10/11/21;31;12;9;40;41;2
                08/11/21;44;32;11;48;7;3
                06/11/21;19;2;18;22;4;3
                03/11/21;7;39;31;38;42;10
                01/11/21;47;27;26;43;1;6
                30/10/21;46;11;43;12;30;9
                27/10/21;41;16;44;27;15;9
                25/10/21;31;48;43;37;3;10
                23/10/21;6;36;35;10;48;9
                20/10/21;26;35;16;22;42;4
                18/10/21;41;27;36;35;9;6
                16/10/21;23;15;46;5;37;10
                13/10/21;21;20;19;43;49;10
                11/10/21;26;7;1;9;28;3
                09/10/21;22;29;19;15;34;3
                06/10/21;44;34;20;8;41;2
                04/10/21;44;15;5;19;7;1
                02/10/21;6;46;35;20;8;9
                29/09/21;6;39;28;13;33;10
                27/09/21;12;26;31;40;37;3
                25/09/21;20;35;49;18;16;1
                22/09/21;5;40;13;14;9;1
                20/09/21;12;10;45;15;31;5
                18/09/21;39;38;21;2;9;2
                15/09/21;48;22;4;30;27;7
                13/09/21;4;30;24;21;40;4
                11/09/21;5;3;49;33;15;8
                08/09/21;7;34;27;12;15;4
                06/09/21;3;31;36;13;40;9
                04/09/21;41;49;30;45;35;3
                01/09/21;49;27;32;24;17;7
                30/08/21;32;34;18;44;3;9
                28/08/21;48;43;46;11;8;9
                25/08/21;19;9;29;26;3;8
                23/08/21;13;22;31;11;21;6
                21/08/21;46;8;2;19;29;2
                18/08/21;4;7;12;24;25;2
                16/08/21;22;27;13;10;49;4
                14/08/21;4;28;42;49;35;7
                11/08/21;43;13;21;5;6;4
                09/08/21;37;43;45;28;38;3
                07/08/21;7;24;36;6;47;10
                04/08/21;21;36;22;20;44;10
                02/08/21;24;44;46;42;7;2
                31/07/21;22;6;46;7;17;3
                28/07/21;1;28;3;29;8;6
                26/07/21;42;5;34;21;37;10
                24/07/21;24;40;5;31;22;9
                21/07/21;27;25;6;37;32;9
                19/07/21;3;28;15;4;2;5
                17/07/21;31;8;47;11;17;6
                14/07/21;36;18;38;31;29;10
                12/07/21;38;31;8;37;30;1
                10/07/21;43;3;38;42;46;1
                07/07/21;37;18;8;44;46;2
                05/07/21;43;36;3;32;45;2
                03/07/21;33;48;13;2;19;2
                30/06/21;8;44;6;48;31;9
                28/06/21;4;28;48;8;15;1
                26/06/21;37;24;38;13;45;6
                23/06/21;1;16;6;3;40;1
                21/06/21;44;21;25;18;47;10
                19/06/21;3;44;46;27;14;6
                16/06/21;22;23;35;46;3;9
                14/06/21;40;12;47;21;19;7
                12/06/21;9;2;5;29;10;1
                09/06/21;16;33;41;2;24;8
                07/06/21;6;28;34;7;11;8
                05/06/21;45;16;6;37;25;9
                02/06/21;33;34;25;3;26;6
                31/05/21;25;3;13;32;47;9
                29/05/21;32;4;36;44;9;3
                26/05/21;20;1;22;5;42;6
                24/05/21;11;44;47;29;7;9
                22/05/21;9;2;45;19;7;10
                19/05/21;28;17;41;3;23;3
                17/05/21;23;42;3;17;47;4
                15/05/21;7;31;29;24;47;3
                12/05/21;19;11;22;36;9;1
                10/05/21;44;12;13;17;27;10
                08/05/21;41;35;40;6;24;6
                05/05/21;36;48;46;41;8;6
                03/05/21;44;8;11;48;37;6
                01/05/21;27;25;5;34;38;7
                28/04/21;4;15;10;49;12;6
                26/04/21;2;34;41;32;8;6
                24/04/21;41;12;26;42;36;7
                21/04/21;45;31;6;49;39;4
                19/04/21;49;17;36;44;27;1
                17/04/21;38;37;17;34;30;1
                14/04/21;27;25;20;23;47;6
                12/04/21;43;14;26;7;11;7
                10/04/21;9;35;15;8;4;8
                07/04/21;35;19;9;16;43;4
                05/04/21;32;22;2;12;15;8
                03/04/21;17;1;38;2;45;2
                31/03/21;2;27;24;35;22;5
                29/03/21;41;28;18;13;38;1
                27/03/21;16;11;18;8;10;5
                24/03/21;22;38;28;37;9;10
                22/03/21;15;6;34;39;24;4
                20/03/21;42;18;14;4;27;3
                17/03/21;45;18;46;3;30;3
                15/03/21;29;38;33;15;41;2
                13/03/21;47;22;19;4;10;8
                10/03/21;26;42;33;20;34;9
                08/03/21;24;8;38;19;40;10
                06/03/21;11;22;3;13;30;8
                03/03/21;38;8;41;49;19;7
                01/03/21;4;14;21;47;8;9
                27/02/21;4;29;42;43;11;10
                24/02/21;47;18;41;10;19;2
                22/02/21;3;37;26;15;24;7
                20/02/21;21;36;19;39;49;5
                17/02/21;34;31;35;41;29;8
                15/02/21;13;22;17;6;12;7
                13/02/21;13;17;31;28;9;10
                10/02/21;44;13;29;15;33;4
                08/02/21;19;10;9;29;5;8
                06/02/21;44;42;15;9;47;10
                03/02/21;17;31;26;37;21;10
                01/02/21;1;18;45;17;21;9
                30/01/21;17;5;33;9;37;4
                27/01/21;27;44;25;23;6;6
                25/01/21;13;31;49;7;3;5
                23/01/21;1;19;13;24;48;5
                20/01/21;21;11;22;40;32;9
                18/01/21;5;43;10;48;25;10
                16/01/21;44;20;14;22;36;2
                13/01/21;32;42;30;17;41;5
                11/01/21;33;46;8;17;1;5
                09/01/21;49;12;27;11;7;1
                06/01/21;41;21;32;47;11;9
                04/01/21;31;39;30;49;19;8
                02/01/21;5;27;7;24;41;10
                30/12/20;36;20;13;31;38;1
                28/12/20;41;34;42;22;1;5
                26/12/20;31;3;40;35;2;7
                23/12/20;5;3;39;31;38;9
                21/12/20;10;31;36;37;44;5
                19/12/20;30;29;49;23;10;5
                16/12/20;21;6;41;17;16;9
                14/12/20;47;48;13;34;2;6
                12/12/20;14;31;9;45;23;6
                09/12/20;47;17;48;39;24;7
                07/12/20;45;27;48;4;38;4
                05/12/20;34;20;14;35;9;1
                02/12/20;23;14;40;46;27;1
                30/11/20;28;9;26;29;18;3
                28/11/20;9;25;2;47;35;10
                25/11/20;1;26;14;31;10;4
                23/11/20;15;20;12;6;1;1
                21/11/20;49;17;44;5;46;4
                18/11/20;28;11;14;43;41;8
                16/11/20;7;47;16;33;42;7
                14/11/20;40;26;17;24;43;9
                11/11/20;15;17;10;37;16;9
                09/11/20;26;18;41;38;5;10
                07/11/20;45;5;48;42;30;9
                04/11/20;29;10;16;14;9;1
                02/11/20;42;43;38;33;31;3
                31/10/20;22;35;9;28;13;5
                28/10/20;25;43;30;2;19;9
                26/10/20;33;7;8;12;22;5
                24/10/20;8;25;4;12;45;2
                21/10/20;35;48;33;21;15;1
                19/10/20;7;35;48;28;25;1
                17/10/20;28;23;24;9;20;4
                14/10/20;19;42;32;26;39;6
                12/10/20;18;7;21;42;11;3
                10/10/20;48;26;31;47;42;8
                07/10/20;17;30;6;49;19;2
                05/10/20;6;22;19;5;9;5
                03/10/20;31;36;9;33;18;2
                30/09/20;26;24;49;32;2;5
                28/09/20;33;22;44;6;35;2
                26/09/20;4;31;49;8;39;9
                23/09/20;11;5;25;23;33;5
                21/09/20;46;41;38;19;16;9
                19/09/20;33;42;27;46;32;7
                16/09/20;28;19;49;23;17;7
                14/09/20;23;49;5;13;32;2
                12/09/20;16;46;12;21;24;2
                09/09/20;24;48;20;29;45;3
                07/09/20;37;35;31;44;14;7
                05/09/20;22;15;19;24;46;3
                02/09/20;14;23;21;47;3;3
                31/08/20;7;16;17;4;11;10
                29/08/20;23;15;38;21;39;4
                26/08/20;13;45;4;40;31;3
                24/08/20;28;18;22;37;19;2
                22/08/20;7;11;5;32;33;5
                19/08/20;35;11;13;4;34;1
                17/08/20;6;1;39;48;40;6
                15/08/20;5;41;3;42;15;7
                12/08/20;17;47;30;3;44;3
                10/08/20;28;38;2;1;11;6
                08/08/20;35;42;49;4;6;9
                05/08/20;46;32;22;15;17;8
                03/08/20;43;48;42;23;30;7
                01/08/20;17;18;25;38;9;9
                29/07/20;47;46;7;19;39;5
                27/07/20;19;24;45;15;25;3
                25/07/20;18;10;6;15;48;4
                22/07/20;4;28;38;20;18;1
                20/07/20;8;42;22;28;26;2
                18/07/20;11;42;22;34;43;4
                15/07/20;6;12;4;35;44;3
                13/07/20;24;3;35;46;2;8
                11/07/20;32;6;35;28;40;7
                08/07/20;30;48;37;9;26;8
                06/07/20;2;11;42;30;35;6
                04/07/20;23;13;27;44;36;6
                01/07/20;44;47;5;13;14;8
                29/06/20;21;29;20;47;46;7
                27/06/20;1;39;2;6;27;4
                24/06/20;36;8;31;34;17;7
                22/06/20;9;36;5;21;39;5
                20/06/20;8;24;33;38;14;5
                17/06/20;26;13;10;20;46;1
                15/06/20;22;49;26;2;47;2
                13/06/20;25;32;6;5;28;4
                10/06/20;47;36;20;11;9;2
                08/06/20;8;22;26;46;2;1
                06/06/20;14;7;43;44;29;5
                03/06/20;12;13;26;44;16;6
                01/06/20;24;26;2;36;32;7
                30/05/20;5;14;42;44;16;9
                27/05/20;29;6;12;44;31;6
                25/05/20;9;26;30;42;36;4
                23/05/20;22;28;3;23;29;2
                20/05/20;45;14;39;20;47;8
                18/05/20;20;30;35;14;10;9
                16/05/20;26;27;41;46;19;4
                13/05/20;43;4;17;38;49;8
                11/05/20;34;5;33;3;17;10
                09/05/20;48;39;29;47;35;7
                06/05/20;48;36;14;15;10;3
                04/05/20;39;8;9;33;15;10
                02/05/20;43;22;12;30;9;4
                29/04/20;25;29;47;5;7;1
                27/04/20;41;11;19;29;14;9
                25/04/20;49;6;24;13;10;3
                22/04/20;28;30;43;40;41;7
                20/04/20;37;5;9;7;41;6
                18/04/20;45;1;33;47;27;8
                15/04/20;16;1;31;48;3;6
                13/04/20;42;1;19;23;17;9
                11/04/20;8;43;1;48;41;7
                08/04/20;16;9;19;26;6;9
                06/04/20;23;29;18;35;7;4
                04/04/20;40;2;35;39;42;9
                01/04/20;41;48;42;28;3;6
                30/03/20;21;37;12;17;23;7
                28/03/20;35;23;26;32;22;5
                25/03/20;40;45;24;32;34;1
                23/03/20;28;49;5;48;21;2
                21/03/20;16;37;8;7;42;8
                18/03/20;48;10;46;28;29;9
                16/03/20;44;16;4;40;23;3
                14/03/20;28;41;38;31;43;10
                11/03/20;38;45;5;14;46;1
                09/03/20;26;41;5;33;42;7
                07/03/20;5;35;37;4;24;2
                04/03/20;10;17;33;30;49;4
                02/03/20;42;26;21;39;40;5
                29/02/20;37;24;19;10;5;6
                26/02/20;20;6;30;32;45;4
                24/02/20;20;15;27;9;47;7
                22/02/20;4;39;26;5;24;4
                19/02/20;40;16;21;41;46;2
                17/02/20;44;39;7;41;19;1
                15/02/20;48;4;25;5;45;7
                12/02/20;47;38;17;30;43;5
                10/02/20;15;49;37;25;38;8
                08/02/20;47;31;12;45;7;10
                05/02/20;30;21;6;11;29;4
                03/02/20;49;20;7;31;33;4
                01/02/20;36;25;22;21;16;9
                29/01/20;31;30;6;14;45;8
                27/01/20;27;12;10;7;41;1
                25/01/20;36;17;30;7;11;5
                22/01/20;25;28;42;26;12;10
                20/01/20;13;38;31;30;26;1
                18/01/20;12;1;33;13;2;9
                15/01/20;35;19;8;22;46;2
                13/01/20;16;11;25;32;14;9
                11/01/20;48;14;2;23;13;3
                08/01/20;17;44;29;16;37;8
                06/01/20;49;10;19;26;30;3
                04/01/20;22;9;43;31;34;5
                01/01/20;11;7;32;24;4;10
                30/12/19;12;38;34;32;48;6
                28/12/19;24;48;49;18;8;8
                25/12/19;36;40;45;24;15;9
                23/12/19;37;36;32;20;7;2
                21/12/19;48;23;27;19;22;2
                18/12/19;23;6;17;5;7;9
                16/12/19;38;26;39;35;10;6
                14/12/19;3;48;17;4;38;9
                11/12/19;25;33;48;1;40;8
                09/12/19;1;34;15;24;25;8
                07/12/19;40;29;44;38;10;8
                04/12/19;8;30;26;35;40;2
                02/12/19;39;28;14;11;42;9
                30/11/19;7;25;17;48;16;3
                27/11/19;44;2;15;29;18;4
                25/11/19;44;41;35;33;38;8
                23/11/19;4;27;28;9;22;4
                20/11/19;22;23;7;30;37;3
                18/11/19;31;44;6;15;12;7
                16/11/19;10;49;30;12;29;9
                13/11/19;22;13;10;35;19;1
                11/11/19;28;14;27;13;25;5
                09/11/19;26;24;6;18;29;3
                06/11/19;43;27;23;44;42;10
                02/11/19;41;1;18;16;13;3
                30/10/19;46;13;48;2;22;1
                28/10/19;46;17;36;35;18;4
                26/10/19;11;30;44;13;20;9
                23/10/19;49;44;31;33;40;1
                21/10/19;13;42;40;48;3;4
                19/10/19;36;23;24;31;32;8
                16/10/19;19;30;5;18;35;2
                14/10/19;16;48;18;24;6;9
                12/10/19;27;16;12;37;10;9
                09/10/19;14;39;17;44;36;5
                07/10/19;19;4;2;35;11;5
                05/10/19;30;2;38;16;31;5
                02/10/19;33;37;32;35;49;3
                30/09/19;43;2;33;23;47;2
                28/09/19;18;15;12;19;40;5
                25/09/19;7;1;26;22;15;3
                23/09/19;36;20;42;34;29;4
                21/09/19;15;42;41;44;8;10
                18/09/19;16;6;36;5;3;10
                16/09/19;42;35;31;32;13;5
                14/09/19;28;23;18;26;19;9
                11/09/19;35;19;6;27;14;10
                09/09/19;42;2;44;28;5;8
                07/09/19;16;12;27;30;2;2
                04/09/19;25;2;4;7;35;3
                02/09/19;6;2;44;33;21;4
                31/08/19;47;21;25;19;38;4
                28/08/19;14;25;47;7;42;5
                26/08/19;4;21;46;27;47;6
                24/08/19;23;31;15;38;17;4
                21/08/19;17;3;38;1;25;8
                19/08/19;14;31;7;28;2;3
                17/08/19;1;21;28;8;37;2
                14/08/19;45;17;27;48;34;2
                12/08/19;31;30;9;20;34;10
                10/08/19;37;4;12;9;18;3
                07/08/19;26;28;36;29;5;4
                05/08/19;5;45;22;26;33;9
                03/08/19;10;4;5;23;7;4
                31/07/19;32;18;8;36;30;5
                29/07/19;6;29;3;47;21;3
                27/07/19;25;28;39;47;31;8
                24/07/19;39;25;10;32;40;10
                22/07/19;28;37;44;11;7;3
                20/07/19;21;17;29;35;18;6
                17/07/19;26;4;27;47;28;8
                15/07/19;10;1;19;13;3;4
                13/07/19;27;18;49;37;48;10
                10/07/19;7;21;29;35;47;6
                08/07/19;26;11;38;20;33;10
                06/07/19;13;6;2;27;12;10
                03/07/19;39;38;8;31;45;8
                01/07/19;38;23;41;3;17;3
                29/06/19;46;42;1;4;3;3
                26/06/19;4;47;43;30;7;10
                24/06/19;33;16;1;32;45;6
                22/06/19;13;20;10;25;27;2
                19/06/19;45;46;4;36;18;5
                17/06/19;20;49;31;12;13;2
                15/06/19;2;13;20;30;37;6
                12/06/19;25;31;45;38;3;9
                10/06/19;9;24;18;49;39;8
                08/06/19;14;41;9;10;45;1
                05/06/19;28;47;26;38;17;7
                03/06/19;42;12;9;41;33;1
                01/06/19;35;26;13;45;20;3
                29/05/19;36;48;14;13;6;2
                27/05/19;33;13;28;18;42;9
                25/05/19;42;47;2;13;43;10
                22/05/19;1;48;27;49;37;1
                20/05/19;32;14;43;29;41;1
                18/05/19;19;4;10;42;46;5
                15/05/19;38;44;46;27;42;1
                13/05/19;15;24;37;40;41;4
                11/05/19;24;44;34;19;45;2
                08/05/19;2;16;4;20;35;5
                06/05/19;23;38;5;24;35;3
                04/05/19;38;18;3;24;29;9
                01/05/19;26;48;25;16;34;8
                29/04/19;33;43;39;6;29;2
                27/04/19;27;17;26;25;33;2
                24/04/19;3;11;35;13;15;3
                22/04/19;39;7;21;29;5;7
                20/04/19;4;30;15;49;45;3
                17/04/19;29;17;34;48;8;3
                15/04/19;32;44;40;17;38;6
                13/04/19;17;9;1;24;46;8
                10/04/19;22;23;14;42;16;5
                08/04/19;24;9;26;15;13;9
                06/04/19;19;26;13;27;24;7
                03/04/19;16;38;18;45;10;3
                01/04/19;32;14;35;46;11;10
                30/03/19;15;44;41;3;2;3
                27/03/19;49;45;25;10;19;1
                25/03/19;46;47;23;22;24;2
                23/03/19;12;1;40;28;26;6
                20/03/19;13;3;21;2;40;8
                18/03/19;38;23;45;24;44;6
                16/03/19;33;19;1;31;22;1
                13/03/19;29;5;20;8;32;3
                11/03/19;25;24;16;6;5;1
                09/03/19;32;47;43;35;15;10
                06/03/19;14;23;15;44;46;5
                04/03/19;4;15;11;36;33;2
                02/03/19;46;42;38;25;16;9
                27/02/19;14;1;34;19;4;2
                25/02/19;7;44;37;48;38;7
                23/02/19;3;45;13;4;44;5
                20/02/19;25;29;8;34;15;1
                18/02/19;18;9;11;33;7;9
                16/02/19;8;7;25;11;46;7
                13/02/19;43;41;29;14;7;3
                11/02/19;43;15;13;48;25;5
                09/02/19;47;40;45;42;3;9
                06/02/19;4;15;21;26;22;10
                04/02/19;40;12;37;24;42;1
                02/02/19;32;27;5;7;35;3
                30/01/19;20;47;15;11;30;9
                28/01/19;37;15;30;6;47;6
                26/01/19;30;14;12;16;42;2
                23/01/19;25;17;41;24;38;10
                21/01/19;17;26;30;47;20;6
                19/01/19;37;10;39;16;34;7
                16/01/19;15;11;10;1;31;3
                14/01/19;35;33;44;1;11;10
                12/01/19;19;24;11;34;25;8
                09/01/19;6;19;46;21;15;10
                07/01/19;1;19;12;31;7;10
                05/01/19;48;18;40;7;6;7
                02/01/19;36;12;29;2;26;7
                31/12/18;43;24;34;27;14;10
                29/12/18;26;30;42;38;12;5
                26/12/18;45;9;5;24;11;10
                24/12/18;10;22;34;43;46;2
                22/12/18;44;46;31;11;22;5
                19/12/18;21;3;25;10;11;3
                17/12/18;2;9;25;35;30;9
                15/12/18;38;1;3;32;30;6
                12/12/18;39;21;45;12;44;5
                10/12/18;8;34;16;13;37;10
                08/12/18;25;38;11;29;14;8
                05/12/18;6;19;41;17;18;9
                03/12/18;1;15;9;19;39;5
                01/12/18;15;6;3;23;39;2
                28/11/18;3;38;30;10;15;6
                26/11/18;36;30;34;14;21;2
                24/11/18;15;11;5;22;10;5
                21/11/18;22;45;20;21;23;10
                19/11/18;33;46;21;20;28;7
                17/11/18;42;20;27;22;12;7
                14/11/18;36;41;15;49;48;5
                12/11/18;13;14;37;21;15;7
                10/11/18;20;43;18;44;30;7
                07/11/18;33;27;3;20;6;8
                05/11/18;9;11;39;29;32;8
                03/11/18;6;29;8;9;39;2
                31/10/18;34;14;2;28;38;4
                29/10/18;9;42;24;43;22;7
                27/10/18;26;21;36;29;35;9
                24/10/18;28;45;34;36;9;6
                22/10/18;10;4;29;19;47;6
                20/10/18;7;17;31;12;48;8
                17/10/18;33;13;7;2;41;1
                15/10/18;8;14;25;19;49;5
                13/10/18;1;36;45;4;22;8
                10/10/18;5;24;38;29;4;3
                08/10/18;46;1;4;23;24;2
                06/10/18;49;39;8;48;1;9
                03/10/18;31;24;11;20;32;8
                01/10/18;6;1;40;7;2;4
                29/09/18;31;7;15;10;17;4
                26/09/18;40;18;15;36;10;3
                24/09/18;12;30;17;8;6;3
                22/09/18;14;37;39;18;38;9
                19/09/18;15;42;4;27;25;5
                17/09/18;43;42;8;15;26;5
                15/09/18;11;26;1;46;13;5
                12/09/18;11;33;24;35;4;9
                10/09/18;27;20;19;46;38;10
                08/09/18;6;19;22;34;20;10
                05/09/18;7;39;34;6;15;1
                03/09/18;18;2;15;1;41;10
                01/09/18;32;35;11;41;42;6
                29/08/18;17;45;19;40;31;1
                27/08/18;40;17;24;18;10;2
                25/08/18;29;6;15;44;16;3
                22/08/18;16;42;12;6;40;3
                20/08/18;15;48;42;18;40;10
                18/08/18;33;37;31;16;49;8
                15/08/18;40;21;47;27;6;8
                13/08/18;10;19;21;2;40;6
                11/08/18;41;27;44;46;14;5
                08/08/18;5;19;29;15;24;8
                06/08/18;30;4;37;32;23;6
                04/08/18;41;23;9;32;38;3
                01/08/18;47;15;45;35;17;4
                30/07/18;33;7;13;41;43;2
                28/07/18;7;23;13;18;21;10
                25/07/18;35;27;22;20;30;3
                23/07/18;7;20;41;40;11;6
                21/07/18;44;18;9;28;1;10
                18/07/18;18;26;27;43;35;7
                16/07/18;36;31;9;16;3;1
                14/07/18;47;37;45;3;20;3
                11/07/18;11;46;1;22;42;4
                09/07/18;9;21;19;36;40;1
                07/07/18;41;3;34;11;10;10
                04/07/18;41;23;16;20;45;5
                02/07/18;48;38;36;45;16;8
                30/06/18;5;36;23;29;45;7
                27/06/18;26;11;9;41;8;10
                25/06/18;14;9;21;13;32;5
                23/06/18;41;32;49;10;36;10
                20/06/18;43;33;8;30;6;3
                18/06/18;34;2;7;13;44;8
                16/06/18;35;17;8;43;19;9
                13/06/18;20;48;15;29;49;1
                11/06/18;44;41;49;25;14;4
                09/06/18;7;16;5;9;12;10
                06/06/18;43;5;33;6;47;2
                04/06/18;8;38;48;16;35;2
                02/06/18;18;13;31;7;35;4
                30/05/18;4;44;41;36;33;6
                28/05/18;35;10;25;21;23;10
                26/05/18;26;24;2;43;3;8
                23/05/18;14;29;3;36;25;9
                21/05/18;20;4;46;16;5;5
                19/05/18;5;47;30;45;12;9
                16/05/18;44;37;7;23;41;8
                14/05/18;40;33;23;1;5;8
                12/05/18;6;23;9;47;5;10
                09/05/18;10;23;35;34;5;6
                07/05/18;43;13;10;23;46;6
                05/05/18;9;30;47;41;15;5
                02/05/18;8;1;14;10;21;10
                30/04/18;43;48;49;36;7;7
                28/04/18;36;14;40;31;47;2
                25/04/18;21;23;5;10;36;1
                23/04/18;2;33;20;29;32;8
                21/04/18;26;20;2;11;39;5
                18/04/18;18;11;38;17;46;8
                16/04/18;16;25;6;21;26;5
                14/04/18;24;5;49;36;1;7
                11/04/18;40;46;32;17;1;8
                09/04/18;1;32;20;28;42;6
                07/04/18;26;34;10;45;7;7
                04/04/18;19;40;22;45;36;6
                02/04/18;28;34;18;13;14;2
                31/03/18;42;2;41;18;31;8
                28/03/18;43;39;15;5;45;10
                26/03/18;27;17;37;10;4;10
                24/03/18;31;11;44;35;26;9
                21/03/18;31;45;21;30;29;2
                19/03/18;20;15;27;46;24;10
                17/03/18;48;43;36;30;13;9
                14/03/18;36;46;13;4;3;10
                12/03/18;27;7;10;38;13;8
                10/03/18;5;47;23;21;18;6
                07/03/18;13;6;18;36;37;5
                05/03/18;44;38;25;17;41;9
                03/03/18;3;4;8;2;31;9
                28/02/18;42;5;49;31;28;7
                26/02/18;13;34;39;42;37;3
                24/02/18;12;6;9;31;43;3
                21/02/18;12;41;2;28;16;1
                19/02/18;32;9;8;29;28;2
                17/02/18;49;48;14;22;38;9
                14/02/18;13;3;44;19;5;4
                12/02/18;27;35;48;3;32;9
                10/02/18;19;31;2;40;42;5
                07/02/18;44;13;17;48;33;3
                05/02/18;7;29;1;30;45;7
                03/02/18;22;9;23;38;13;4
                31/01/18;29;26;16;4;49;1
                29/01/18;11;32;27;36;21;6
                27/01/18;45;10;9;34;39;10
                24/01/18;9;37;35;23;28;5
                22/01/18;31;11;16;1;14;2
                20/01/18;44;32;27;38;46;7
                17/01/18;16;25;40;49;4;3
                15/01/18;15;28;22;2;5;2
                13/01/18;48;35;20;31;36;10
                10/01/18;7;49;18;9;16;3
                08/01/18;8;44;37;43;45;2
                06/01/18;45;40;17;6;31;9
                03/01/18;34;44;27;23;4;4
                01/01/18;7;43;10;9;14;1
                30/12/17;40;28;35;13;12;8
                27/12/17;22;6;48;7;14;8
                25/12/17;3;31;6;10;29;8
                23/12/17;4;6;44;8;48;10
                20/12/17;6;11;13;24;10;9
                18/12/17;11;39;48;10;29;9
                16/12/17;48;20;15;9;49;6
                13/12/17;17;49;24;43;28;8
                11/12/17;47;34;26;43;29;4
                09/12/17;48;49;10;46;23;8
                06/12/17;27;12;38;7;30;1
                04/12/17;43;32;15;23;41;8
                02/12/17;24;45;39;33;35;1
                29/11/17;8;20;3;12;13;4
                27/11/17;36;5;6;39;46;6
                25/11/17;43;1;48;2;47;10
                22/11/17;30;1;10;2;39;8
                20/11/17;6;30;40;43;35;3
                18/11/17;13;9;17;37;48;1
                15/11/17;12;10;16;35;14;6
                13/11/17;30;29;24;3;43;5
                11/11/17;40;47;48;1;36;3
                08/11/17;37;41;13;26;2;5
                06/11/17;30;45;49;27;48;1
                04/11/17;23;7;38;35;6;7
                01/11/17;18;8;26;9;32;1
                30/10/17;32;42;12;44;34;5
                28/10/17;22;12;47;5;29;8
                25/10/17;9;3;19;41;43;8
                23/10/17;12;21;47;44;25;3
                21/10/17;2;42;6;20;21;8
                18/10/17;5;13;25;12;24;7
                16/10/17;39;48;30;5;32;8
                14/10/17;18;20;38;43;47;3
                11/10/17;44;48;6;29;15;4
                09/10/17;47;30;6;15;3;9
                07/10/17;41;44;8;37;46;3
                04/10/17;45;34;20;30;1;9
                02/10/17;1;11;28;12;20;7
                30/09/17;16;44;3;38;27;7
                27/09/17;13;10;16;42;35;4
                25/09/17;37;16;17;33;34;6
                23/09/17;15;33;22;19;37;4
                20/09/17;37;6;4;17;22;6
                18/09/17;12;25;37;29;34;9
                16/09/17;37;46;4;18;16;5
                13/09/17;18;45;4;25;33;1
                11/09/17;23;42;48;45;12;9
                09/09/17;44;13;19;15;39;1
                06/09/17;49;46;28;19;39;4
                04/09/17;33;6;27;1;35;9
                02/09/17;10;14;1;40;18;7
                30/08/17;29;26;7;12;47;9
                28/08/17;6;8;20;24;42;6
                26/08/17;10;40;35;32;38;3
                23/08/17;32;23;16;1;4;7
                21/08/17;8;36;43;27;14;5
                19/08/17;39;8;40;21;7;7
                16/08/17;31;29;25;19;41;4
                14/08/17;13;15;39;2;9;4
                12/08/17;13;36;41;15;5;10
                09/08/17;32;38;36;31;49;1
                07/08/17;38;24;42;21;14;4
                05/08/17;3;25;30;13;37;2
                02/08/17;34;30;9;12;32;7
                31/07/17;45;37;47;25;31;7
                29/07/17;24;41;45;23;10;1
                26/07/17;13;44;35;3;25;2
                24/07/17;14;11;38;21;35;3
                22/07/17;40;30;16;5;28;9
                19/07/17;16;26;6;8;9;7
                17/07/17;40;41;5;33;16;2
                15/07/17;34;37;24;48;29;2
                12/07/17;3;16;31;43;18;5
                10/07/17;23;43;17;21;18;4
                08/07/17;9;30;46;43;31;10
                05/07/17;18;29;17;34;8;6
                03/07/17;48;8;10;28;2;2
                01/07/17;26;47;16;33;21;8
                28/06/17;48;30;37;29;9;1
                26/06/17;1;49;5;29;38;9
                24/06/17;48;27;23;35;24;5
                21/06/17;12;22;34;18;39;6
                19/06/17;25;43;18;47;40;9
                17/06/17;26;25;40;14;39;3
                14/06/17;44;43;49;41;31;5
                12/06/17;5;29;4;7;27;5
                10/06/17;49;34;37;36;8;10
                07/06/17;22;43;36;40;21;5
                05/06/17;49;12;17;41;21;7
                03/06/17;23;45;36;34;44;3
                31/05/17;1;36;9;41;27;1
                29/05/17;40;43;39;41;1;9
                27/05/17;9;8;28;40;17;8
                24/05/17;17;22;18;8;30;5
                22/05/17;27;21;22;7;31;10
                20/05/17;33;31;28;34;42;3
                17/05/17;25;44;6;30;22;7
                15/05/17;22;13;1;27;5;1
                13/05/17;16;13;9;28;47;10
                10/05/17;30;22;20;43;12;9
                08/05/17;33;7;47;22;43;6
                06/05/17;27;41;34;6;45;5
                03/05/17;20;15;27;46;6;3
                01/05/17;18;46;37;16;35;6
                29/04/17;48;37;46;44;34;9
                26/04/17;27;6;8;14;16;5
                24/04/17;7;42;28;45;41;9
                22/04/17;17;21;31;1;46;5
                19/04/17;47;39;38;41;48;9
                17/04/17;8;36;46;4;33;7
                15/04/17;28;29;41;40;49;5
                12/04/17;48;18;3;28;40;7
                10/04/17;11;3;20;14;1;2
                08/04/17;17;44;18;45;29;5
                05/04/17;10;40;42;20;6;10
                03/04/17;34;16;44;3;9;3
                01/04/17;46;2;44;9;25;9
                29/03/17;35;14;10;26;25;5
                27/03/17;2;49;9;38;18;8
                25/03/17;2;5;8;43;49;1
                22/03/17;43;25;28;2;11;5
                20/03/17;42;39;28;13;40;1
                18/03/17;33;18;1;30;6;2
                15/03/17;25;5;46;36;31;8
                13/03/17;16;21;34;48;24;3
                11/03/17;1;39;31;13;42;7
                08/03/17;40;16;46;42;47;2
                06/03/17;26;10;6;41;3;9
                04/03/17;28;14;37;32;4;4
                01/03/17;33;31;16;46;20;5
                27/02/17;3;37;16;17;47;5
                25/02/17;40;32;43;11;48;2
                22/02/17;17;25;22;35;43;10
                20/02/17;20;29;43;41;15;10
                18/02/17;32;23;49;1;3;4
                15/02/17;8;16;21;14;24;10
                13/02/17;5;16;39;44;18;3
                11/02/17;37;17;29;15;1;3
                08/02/17;17;33;37;40;19;6
                06/02/17;19;31;33;40;30;2
                04/02/17;32;22;1;35;37;7
                01/02/17;45;24;17;46;9;7
                30/01/17;4;22;40;23;32;4
                28/01/17;6;5;10;2;26;5
                25/01/17;10;19;20;28;4;2
                23/01/17;15;5;17;49;31;9
                21/01/17;40;36;32;8;31;6
                18/01/17;48;29;34;5;47;4
                16/01/17;35;32;14;37;26;5
                14/01/17;19;18;44;37;16;1
                11/01/17;30;13;28;22;19;3
                09/01/17;21;16;6;42;2;7
                07/01/17;33;46;24;21;22;8
                04/01/17;17;36;16;26;38;7
                02/01/17;31;38;11;19;40;5
                31/12/16;45;49;43;33;4;8
                28/12/16;34;35;16;39;15;4
                26/12/16;3;16;27;29;37;6
                24/12/16;22;48;7;20;35;1
                21/12/16;25;42;17;39;22;6
                19/12/16;17;40;41;26;3;7
                17/12/16;13;5;16;32;2;5
                14/12/16;10;9;44;14;46;7
                12/12/16;12;14;11;6;36;6
                10/12/16;41;43;27;24;28;9
                07/12/16;5;44;7;2;45;3
                05/12/16;29;30;23;6;26;4
                03/12/16;11;13;38;4;44;7
                30/11/16;9;33;31;3;40;5
                28/11/16;41;45;20;10;38;6
                26/11/16;9;21;44;6;11;7
                23/11/16;47;7;25;2;12;7
                21/11/16;7;18;12;45;3;8
                19/11/16;34;48;41;46;36;7
                16/11/16;37;48;1;26;24;7
                14/11/16;41;6;14;16;26;2
                12/11/16;29;11;19;16;2;8
                09/11/16;3;22;47;14;8;5
                07/11/16;1;46;21;6;31;6
                05/11/16;16;42;21;6;34;5
                02/11/16;26;1;49;7;14;10
                31/10/16;11;35;16;29;41;4
                29/10/16;21;36;44;26;14;4
                26/10/16;1;46;20;40;35;10
                24/10/16;18;29;36;17;23;7
                22/10/16;29;41;3;43;35;8
                19/10/16;32;28;29;26;38;1
                17/10/16;8;31;48;39;22;4
                15/10/16;47;30;41;32;39;7
                12/10/16;2;19;34;47;23;2
                10/10/16;18;19;3;48;9;2
                08/10/16;5;26;28;46;35;9
                05/10/16;18;28;15;2;43;3
                03/10/16;46;43;7;22;8;10
                01/10/16;13;42;8;16;23;1
                28/09/16;44;46;29;42;45;3
                26/09/16;4;23;26;19;27;7
                24/09/16;33;32;31;41;43;10
                21/09/16;30;15;40;13;20;10
                19/09/16;41;37;20;18;45;10
                17/09/16;12;3;4;34;25;2
                14/09/16;29;18;37;7;47;7
                12/09/16;6;5;11;13;22;10
                10/09/16;46;38;29;31;19;6
                07/09/16;26;34;38;13;42;9
                05/09/16;43;48;7;42;30;4
                03/09/16;36;24;45;49;47;5
                31/08/16;12;26;19;47;10;1
                29/08/16;44;36;49;25;48;2
                27/08/16;45;21;2;31;23;8
                24/08/16;3;4;34;41;42;2
                22/08/16;21;44;42;12;34;7
                20/08/16;35;10;28;43;15;9
                17/08/16;12;21;35;24;40;4
                15/08/16;16;31;25;27;26;7
                13/08/16;33;1;9;6;46;6
                10/08/16;49;30;19;17;7;3
                08/08/16;1;26;2;36;3;7
                06/08/16;44;12;7;25;31;10
                03/08/16;18;27;39;44;24;3
                01/08/16;45;29;36;42;24;7
                30/07/16;30;9;22;46;23;9
                27/07/16;34;7;44;19;8;6
                25/07/16;3;29;46;5;1;4
                23/07/16;2;27;33;21;15;10
                20/07/16;32;1;13;29;46;1
                18/07/16;29;25;2;39;20;7
                16/07/16;45;21;46;48;11;4
                13/07/16;30;28;47;34;7;10
                11/07/16;36;35;2;25;27;4
                09/07/16;46;15;6;39;3;10
                06/07/16;26;38;47;13;16;8
                04/07/16;12;10;25;22;47;1
                02/07/16;8;24;31;17;16;5
                29/06/16;17;22;9;14;48;10
                27/06/16;22;23;8;41;24;7
                25/06/16;16;20;19;35;49;3
                22/06/16;4;27;10;36;5;9
                20/06/16;38;4;45;13;43;10
                18/06/16;18;33;10;20;39;3
                15/06/16;34;2;8;5;33;10
                13/06/16;28;36;5;21;8;8
                11/06/16;7;17;22;46;44;6
                08/06/16;45;6;8;49;33;9
                06/06/16;23;32;48;47;25;5
                04/06/16;39;2;16;19;25;1
                01/06/16;27;35;26;44;22;10
                30/05/16;6;38;7;13;40;3
                28/05/16;19;3;1;14;13;6
                25/05/16;20;12;36;21;4;3
                23/05/16;41;48;22;26;7;2
                21/05/16;41;26;23;12;48;4
                18/05/16;22;1;40;38;49;9
                16/05/16;36;38;31;6;16;1
                14/05/16;42;28;30;1;27;5
                11/05/16;31;44;29;19;15;10
                09/05/16;24;29;4;11;14;1
                07/05/16;35;33;42;20;14;4
                04/05/16;15;7;42;8;24;9
                02/05/16;47;36;43;48;26;6
                30/04/16;49;29;2;30;36;7
                27/04/16;9;36;25;45;44;10
                25/04/16;39;19;13;18;22;6
                23/04/16;26;15;22;2;17;7
                20/04/16;12;15;36;41;13;9
                18/04/16;47;29;24;38;26;7
                16/04/16;33;25;36;39;40;9
                13/04/16;31;49;34;2;4;4
                11/04/16;34;29;4;26;25;2
                09/04/16;42;49;39;14;16;6
                06/04/16;21;19;28;24;44;5
                04/04/16;36;7;48;11;8;3
                02/04/16;29;34;18;22;19;1
                30/03/16;43;20;46;35;23;6
                28/03/16;26;2;28;4;15;2
                26/03/16;14;3;20;17;1;1
                23/03/16;14;19;17;8;5;9
                21/03/16;3;34;42;37;10;2
                19/03/16;49;13;4;36;18;5
                16/03/16;43;18;11;7;9;10
                14/03/16;19;39;27;14;36;8
                12/03/16;27;17;9;25;46;6
                09/03/16;40;22;20;19;41;2
                07/03/16;11;6;49;41;12;1
                05/03/16;34;5;14;49;23;6
                02/03/16;40;48;44;20;34;2
                29/02/16;13;3;1;24;45;1
                27/02/16;11;47;13;10;28;6
                24/02/16;20;18;44;1;49;7
                22/02/16;23;2;5;48;26;5
                20/02/16;9;33;34;41;20;8
                17/02/16;29;17;40;34;2;10
                15/02/16;37;21;38;4;10;5
                13/02/16;38;30;27;41;10;4
                10/02/16;44;46;1;27;48;10
                08/02/16;30;1;28;39;11;6
                06/02/16;44;25;2;41;28;9
                03/02/16;5;44;24;28;25;3
                01/02/16;18;36;13;40;48;4
                30/01/16;1;3;31;11;49;1
                27/01/16;31;44;48;37;32;9
                25/01/16;12;4;38;10;41;3
                23/01/16;42;3;15;41;33;3
                20/01/16;34;21;9;42;31;8
                18/01/16;2;5;3;10;1;4
                16/01/16;17;45;26;27;13;6
                13/01/16;30;11;35;33;3;2
                11/01/16;41;29;19;43;14;9
                09/01/16;22;39;4;49;45;6
                06/01/16;49;22;14;5;2;4
                04/01/16;34;43;23;15;40;3
                02/01/16;19;44;37;46;10;10
                30/12/15;16;2;34;25;1;5
                28/12/15;10;12;7;20;45;7
                26/12/15;15;21;20;38;43;1
                23/12/15;13;17;28;46;42;2
                21/12/15;11;19;33;41;7;3
                19/12/15;4;25;42;39;38;7
                16/12/15;46;41;24;35;22;10
                14/12/15;31;49;7;20;11;7
                12/12/15;13;40;2;34;15;8
                09/12/15;6;34;12;49;10;7
                07/12/15;22;28;42;37;14;10
                05/12/15;9;26;47;20;27;7
                02/12/15;39;9;3;45;10;7
                30/11/15;27;19;5;35;40;9
                28/11/15;30;19;37;12;46;9
                25/11/15;24;18;22;41;7;3
                23/11/15;47;12;14;37;20;6
                21/11/15;43;24;12;18;16;10
                18/11/15;25;23;5;1;47;1
                16/11/15;28;47;40;12;42;1
                14/11/15;34;29;47;10;37;10
                11/11/15;17;1;6;13;15;2
                09/11/15;25;32;8;37;39;10
                07/11/15;7;32;4;23;28;1
                04/11/15;32;11;8;21;15;6
                02/11/15;21;32;8;48;7;4
                31/10/15;33;36;48;43;34;10
                28/10/15;49;2;17;30;5;2
                26/10/15;17;19;23;4;49;3
                24/10/15;7;12;39;29;11;2
                21/10/15;25;35;22;26;31;6
                19/10/15;36;33;31;48;47;7
                17/10/15;22;33;14;46;9;8
                14/10/15;38;20;33;6;35;2
                12/10/15;1;16;49;3;4;4
                10/10/15;41;23;15;30;45;7
                07/10/15;29;27;2;14;28;9
                05/10/15;27;28;13;31;42;6
                03/10/15;27;18;8;37;20;4
                30/09/15;16;18;15;35;26;7
                28/09/15;23;39;37;36;49;8
                26/09/15;14;13;4;24;21;1
                23/09/15;35;49;18;20;31;3
                21/09/15;42;47;28;27;12;5
                19/09/15;2;25;43;16;33;9
                16/09/15;7;34;42;11;17;6
                14/09/15;3;43;48;37;49;2
                12/09/15;41;1;30;38;31;10
                09/09/15;3;19;10;44;41;7
                07/09/15;5;19;21;32;29;3
                05/09/15;24;45;14;25;42;9
                02/09/15;29;6;9;17;28;2
                31/08/15;12;41;38;1;31;4
                29/08/15;43;40;2;38;23;8
                26/08/15;44;26;41;15;37;8
                24/08/15;6;5;17;42;30;1
                22/08/15;19;4;20;29;49;9
                19/08/15;21;6;45;34;38;4
                17/08/15;29;9;26;36;42;1
                15/08/15;49;13;6;25;47;4
                12/08/15;15;43;1;24;8;2
                10/08/15;37;44;14;12;28;5
                08/08/15;12;8;11;35;33;9
                05/08/15;34;10;22;36;9;4
                03/08/15;48;10;49;1;39;1
                01/08/15;9;31;24;34;23;9
                29/07/15;22;2;3;42;36;9
                27/07/15;14;28;37;41;6;5
                25/07/15;43;7;5;10;13;4
                22/07/15;36;30;33;31;24;1
                20/07/15;31;17;2;24;29;1
                18/07/15;45;41;37;35;18;3
                15/07/15;46;2;30;43;14;8
                13/07/15;22;39;31;37;29;8
                11/07/15;14;26;4;23;36;1
                08/07/15;5;39;32;42;20;7
                06/07/15;17;12;36;35;43;3
                04/07/15;4;49;38;29;40;3
                01/07/15;49;5;19;18;38;10
                29/06/15;14;16;2;12;42;7
                27/06/15;47;14;42;40;29;4
                24/06/15;29;49;38;25;41;2
                22/06/15;35;43;37;24;38;2
                20/06/15;32;8;3;13;37;4
                17/06/15;44;30;26;48;41;1
                15/06/15;35;19;37;22;16;2
                13/06/15;16;11;29;15;46;4
                10/06/15;12;46;40;8;19;8
                08/06/15;41;3;8;9;44;10
                06/06/15;4;24;29;47;30;3
                03/06/15;12;18;30;25;47;2
                01/06/15;3;38;4;49;12;2
                30/05/15;43;6;30;47;45;5
                27/05/15;22;32;42;8;29;3
                25/05/15;44;35;49;15;29;3
                23/05/15;45;41;12;26;19;7
                20/05/15;12;10;22;37;41;10
                18/05/15;38;41;39;2;10;5
                16/05/15;39;8;22;46;23;3
                13/05/15;45;22;37;15;6;5
                11/05/15;49;1;34;28;31;4
                09/05/15;4;46;8;29;40;3
                06/05/15;35;32;29;7;34;10
                04/05/15;14;30;48;8;49;1
                02/05/15;46;33;30;19;3;5
                29/04/15;42;20;2;35;49;3
                27/04/15;15;28;43;41;5;4
                25/04/15;30;20;29;10;27;6
                22/04/15;10;43;21;25;45;5
                20/04/15;10;37;28;15;2;2
                18/04/15;44;1;49;38;20;3
                15/04/15;43;6;10;30;39;5
                13/04/15;41;9;43;48;36;2
                11/04/15;45;41;5;17;33;9
                08/04/15;15;36;38;30;2;2
                06/04/15;31;16;33;17;1;3
                04/04/15;33;15;23;28;39;1
                01/04/15;13;21;25;20;41;4
                30/03/15;4;20;13;10;32;1
                28/03/15;20;19;40;39;27;8
                25/03/15;43;10;20;9;17;7
                23/03/15;48;49;3;1;20;7
                21/03/15;28;47;41;22;21;5
                18/03/15;26;15;10;4;30;5
                16/03/15;35;11;49;7;48;7
                14/03/15;30;39;3;14;8;10
                11/03/15;49;2;35;1;36;4
                09/03/15;35;31;26;34;28;5
                07/03/15;48;9;18;43;3;2
                04/03/15;32;16;8;23;34;4
                02/03/15;17;11;27;48;23;1
                28/02/15;14;46;5;30;36;6
                25/02/15;44;47;20;30;29;1
                23/02/15;40;3;22;4;28;2
                21/02/15;3;45;47;13;27;4
                18/02/15;44;21;29;9;25;7
                16/02/15;36;14;9;1;20;2
                14/02/15;27;41;38;26;2;7
                11/02/15;13;40;24;17;45;3
                09/02/15;40;49;34;27;4;2
                07/02/15;21;29;7;37;19;2
                04/02/15;49;9;28;24;35;4
                02/02/15;17;16;14;1;11;10
                31/01/15;14;31;46;25;4;5
                28/01/15;41;12;33;9;16;1
                26/01/15;18;17;27;35;40;6
                24/01/15;36;44;21;13;5;1
                21/01/15;19;6;34;49;42;10
                19/01/15;25;4;18;7;35;4
                17/01/15;43;19;30;39;40;4
                14/01/15;23;18;7;2;21;6
                12/01/15;20;15;27;13;34;1
                10/01/15;18;5;33;2;23;4
                07/01/15;20;29;21;33;7;1
                05/01/15;37;8;49;31;45;7
                03/01/15;31;32;12;28;48;3
                31/12/14;46;43;41;37;34;10
                29/12/14;30;26;44;27;49;1
                27/12/14;20;48;34;39;4;10
                24/12/14;31;36;4;22;18;7
                22/12/14;34;35;23;16;6;8
                20/12/14;19;10;26;21;22;9
                17/12/14;32;46;6;8;13;10
                15/12/14;23;47;41;42;15;4
                13/12/14;43;13;10;20;38;1
                10/12/14;27;11;16;3;8;6
                08/12/14;10;14;43;32;47;10
                06/12/14;43;37;20;10;18;8
                03/12/14;49;26;28;31;11;7
                01/12/14;43;49;40;48;44;8
                29/11/14;18;44;2;47;49;2
                26/11/14;5;34;47;12;20;3
                24/11/14;18;47;49;32;17;3
                22/11/14;22;1;44;9;26;10
                19/11/14;41;18;13;14;29;3
                17/11/14;23;47;16;48;35;10
                15/11/14;28;16;39;23;3;10
                12/11/14;27;13;19;40;23;5
                10/11/14;24;23;30;6;18;7
                08/11/14;40;14;46;27;7;5
                05/11/14;27;24;37;46;1;1
                03/11/14;34;45;18;44;24;8
                01/11/14;48;29;2;36;9;10
                29/10/14;32;18;17;6;29;9
                27/10/14;13;32;12;28;33;6
                25/10/14;14;39;24;49;47;4
                22/10/14;10;19;47;35;33;2
                20/10/14;30;40;13;21;26;5
                18/10/14;1;43;24;15;27;7
                15/10/14;28;9;37;41;46;10
                13/10/14;29;15;1;12;30;1
                11/10/14;24;19;10;28;15;9
                08/10/14;13;4;21;43;23;10
                06/10/14;20;22;46;40;9;7
                04/10/14;14;45;29;12;41;7
                01/10/14;17;42;44;27;16;8
                29/09/14;41;28;17;4;33;5
                27/09/14;26;29;9;35;38;5
                24/09/14;16;49;10;38;25;9
                22/09/14;44;31;26;1;13;6
                20/09/14;34;31;25;46;22;6
                17/09/14;23;18;10;6;3;4
                15/09/14;16;44;2;10;35;6
                13/09/14;7;28;27;23;33;1
                10/09/14;6;16;31;26;40;7
                08/09/14;1;40;17;43;42;10
                06/09/14;42;14;15;13;3;7
                03/09/14;10;38;20;4;13;4
                01/09/14;42;22;47;16;38;1
                30/08/14;25;40;30;36;6;8
                27/08/14;4;44;32;22;14;2
                25/08/14;26;9;45;31;43;1
                23/08/14;7;17;29;26;21;7
                20/08/14;22;33;31;41;15;4
                18/08/14;24;45;19;1;46;3
                16/08/14;22;40;23;37;9;4
                13/08/14;3;18;13;43;28;5
                11/08/14;36;32;11;46;25;7
                09/08/14;34;4;5;9;21;7
                06/08/14;13;41;34;21;15;8
                04/08/14;16;28;36;24;43;6
                02/08/14;25;32;4;8;41;10
                30/07/14;25;7;13;9;8;9
                28/07/14;45;14;1;42;43;9
                26/07/14;1;5;43;41;22;4
                23/07/14;1;32;8;15;24;6
                21/07/14;21;3;9;27;10;4
                19/07/14;8;44;29;43;45;6
                16/07/14;42;3;36;28;49;7
                14/07/14;21;41;32;38;37;9
                12/07/14;29;23;22;13;1;1
                09/07/14;8;6;36;4;34;5
                07/07/14;31;41;32;14;13;10
                05/07/14;25;11;7;33;3;6
                02/07/14;36;27;8;39;47;3
                30/06/14;47;27;5;24;46;2
                28/06/14;40;24;22;13;43;3
                25/06/14;5;4;23;30;41;4
                23/06/14;40;38;32;4;31;4
                21/06/14;11;3;30;29;32;1
                18/06/14;47;13;30;9;18;3
                16/06/14;5;37;16;42;3;1
                14/06/14;7;24;18;34;5;5
                11/06/14;22;9;42;15;32;6
                09/06/14;47;34;45;35;10;9
                07/06/14;5;37;45;38;21;2
                04/06/14;43;36;8;22;3;3
                02/06/14;41;35;47;26;22;5
                31/05/14;16;2;28;40;14;1
                28/05/14;9;26;8;48;46;7
                26/05/14;3;8;40;39;32;1
                24/05/14;40;18;39;24;17;1
                21/05/14;49;9;35;23;1;1
                19/05/14;49;41;8;9;40;3
                17/05/14;48;41;37;32;43;7
                14/05/14;6;25;21;5;33;1
                12/05/14;43;33;36;12;2;5
                10/05/14;37;6;15;21;17;4
                07/05/14;6;46;47;11;1;5
                05/05/14;28;16;37;19;2;10
                03/05/14;16;5;41;11;36;5
                30/04/14;32;35;19;23;43;10
                28/04/14;45;32;19;49;36;7
                26/04/14;2;38;43;14;3;4
                23/04/14;3;30;10;29;39;10
                21/04/14;27;9;38;18;20;1
                19/04/14;22;40;21;12;45;8
                16/04/14;26;25;12;49;8;1
                14/04/14;11;7;43;45;14;3
                12/04/14;5;34;42;16;10;10
                09/04/14;28;14;39;12;38;10
                07/04/14;23;42;11;31;13;4
                05/04/14;40;9;22;13;45;5
                02/04/14;6;41;28;16;34;4
                31/03/14;28;6;7;32;2;4
                29/03/14;19;12;28;29;45;4
                26/03/14;40;47;38;11;21;6
                24/03/14;18;41;39;21;37;9
                22/03/14;20;49;14;26;4;2
                19/03/14;27;19;5;26;28;9
                17/03/14;8;33;22;45;19;6
                15/03/14;5;26;30;15;37;4
                12/03/14;42;36;1;20;25;10
                10/03/14;43;16;4;6;30;9
                08/03/14;35;40;6;46;15;7
                05/03/14;12;1;32;42;31;1
                03/03/14;41;40;28;21;36;10
                01/03/14;17;20;15;5;4;5
                26/02/14;19;41;5;22;33;1
                24/02/14;18;8;5;21;38;7
                22/02/14;30;26;48;32;1;10
                19/02/14;44;32;25;47;27;7
                17/02/14;20;32;9;23;1;1
                15/02/14;33;4;12;49;18;9
                12/02/14;7;16;48;15;10;7
                10/02/14;18;11;41;45;17;2
                08/02/14;6;7;39;38;14;7
                05/02/14;2;48;16;7;41;8
                03/02/14;44;33;5;1;13;2
                01/02/14;21;2;48;41;10;6
                29/01/14;35;8;6;25;2;8
                27/01/14;46;19;33;1;48;4
                25/01/14;18;37;17;14;30;5
                22/01/14;38;42;1;22;40;7
                20/01/14;10;1;42;40;35;5
                18/01/14;43;1;37;47;2;8
                15/01/14;7;20;35;37;30;6
                13/01/14;33;3;47;29;20;4
                11/01/14;35;25;18;8;39;9
                08/01/14;4;42;29;45;14;8
                06/01/14;30;29;17;13;19;9
                04/01/14;1;29;45;6;16;5
                01/01/14;39;37;34;26;6;7
                30/12/13;20;22;44;41;11;8
                28/12/13;1;16;20;32;26;7
                25/12/13;36;23;45;28;24;3
                23/12/13;34;29;41;37;18;5
                21/12/13;24;18;19;33;10;4
                18/12/13;36;46;38;8;30;1
                16/12/13;36;31;1;37;33;6
                14/12/13;46;45;8;30;18;1
                11/12/13;43;4;39;40;27;8
                09/12/13;45;33;20;24;6;6
                07/12/13;17;14;2;8;34;7
                04/12/13;21;34;27;25;29;3
                02/12/13;33;34;19;40;36;5
                30/11/13;19;36;20;40;2;2
                27/11/13;16;12;45;34;11;9
                25/11/13;27;15;16;4;42;4
                23/11/13;4;2;48;12;33;9
                20/11/13;35;28;46;14;18;1
                18/11/13;36;46;29;3;28;10
                16/11/13;38;44;20;29;33;8
                13/11/13;7;38;16;36;47;6
                11/11/13;42;48;32;12;16;9
                09/11/13;39;33;12;30;9;4
                06/11/13;20;40;30;16;6;3
                04/11/13;13;18;8;24;15;6
                02/11/13;7;12;4;13;18;9
                30/10/13;46;48;14;21;35;1
                28/10/13;44;32;8;14;23;8
                26/10/13;40;3;35;42;47;7
                23/10/13;5;11;20;22;10;3
                21/10/13;25;32;35;17;36;7
                19/10/13;33;49;44;8;25;1
                16/10/13;9;12;40;23;14;8
                14/10/13;21;35;19;15;33;4
                12/10/13;24;32;22;4;17;8
                09/10/13;1;26;18;20;12;2
                07/10/13;16;31;6;46;15;5
                05/10/13;9;7;14;27;38;9
                02/10/13;11;21;39;17;6;7
                30/09/13;10;26;45;15;28;9
                28/09/13;34;29;45;1;9;5
                25/09/13;6;2;44;43;12;5
                23/09/13;2;11;21;1;36;1
                21/09/13;41;30;17;26;16;9
                18/09/13;35;26;45;4;40;3
                16/09/13;6;15;24;38;26;5
                14/09/13;49;18;28;24;43;7
                11/09/13;35;13;7;6;23;2
                09/09/13;22;23;35;3;5;7
                07/09/13;25;24;44;11;1;3
                04/09/13;49;6;25;17;42;6
                02/09/13;46;16;20;41;8;8
                31/08/13;26;3;2;33;14;7
                28/08/13;40;23;30;2;33;1
                26/08/13;49;1;9;14;25;10
                24/08/13;39;11;5;29;41;7
                21/08/13;39;12;38;11;26;10
                19/08/13;40;25;2;3;46;9
                17/08/13;43;33;32;26;41;10
                14/08/13;30;22;5;35;17;2
                12/08/13;4;11;38;28;21;7
                10/08/13;19;5;41;15;24;5
                07/08/13;45;33;16;40;3;4
                05/08/13;24;39;11;6;43;4
                03/08/13;44;22;33;27;17;9
                31/07/13;28;31;23;41;8;7
                29/07/13;4;34;40;35;36;5
                27/07/13;35;44;29;37;10;4
                24/07/13;27;37;19;36;44;3
                22/07/13;12;32;29;7;38;1
                20/07/13;48;28;9;17;30;7
                17/07/13;16;8;17;48;31;4
                15/07/13;34;7;43;33;44;9
                13/07/13;31;21;37;10;28;8
                10/07/13;31;37;24;39;14;7
                08/07/13;44;8;24;25;26;5
                06/07/13;13;35;30;44;12;2
                03/07/13;36;2;7;25;39;4
                01/07/13;5;31;21;37;38;6
                29/06/13;23;37;8;14;9;7
                26/06/13;39;16;19;29;12;8
                24/06/13;29;5;24;19;10;1
                22/06/13;21;26;37;16;35;8
                19/06/13;32;22;17;43;19;1
                17/06/13;38;39;3;17;1;1
                15/06/13;32;38;26;4;23;2
                12/06/13;20;40;46;3;44;4
                10/06/13;13;15;3;35;32;1
                08/06/13;19;33;29;32;17;2
                05/06/13;27;41;23;25;4;1
                03/06/13;14;4;38;34;25;9
                01/06/13;21;30;8;7;6;3
                29/05/13;34;41;48;23;45;7
                27/05/13;37;15;9;28;13;2
                25/05/13;42;7;36;13;40;2
                22/05/13;3;34;2;17;13;9
                20/05/13;47;27;25;23;9;3
                18/05/13;4;5;20;7;17;3
                15/05/13;32;27;8;13;11;4
                13/05/13;23;29;40;49;15;5
                11/05/13;26;49;45;3;16;9
                08/05/13;13;5;43;25;15;10
                06/05/13;48;13;15;24;23;7
                04/05/13;6;13;40;45;15;4
                01/05/13;7;41;31;32;4;9
                29/04/13;12;21;39;11;27;9
                27/04/13;17;26;39;19;9;10
                24/04/13;1;48;13;6;5;9
                22/04/13;22;16;11;37;14;1
                20/04/13;28;24;3;42;9;9
                17/04/13;38;16;32;12;29;8
                15/04/13;45;20;21;26;46;3
                13/04/13;23;43;22;41;33;4
                10/04/13;9;18;3;45;28;5
                08/04/13;19;6;38;8;37;2
                06/04/13;15;29;42;1;33;7
                03/04/13;36;18;37;42;45;8
                01/04/13;47;16;10;43;27;2
                30/03/13;26;10;9;30;34;2
                27/03/13;21;47;24;49;33;3
                25/03/13;29;25;14;41;10;4
                23/03/13;17;11;41;9;24;6
                20/03/13;37;5;1;49;12;7
                18/03/13;10;20;18;24;32;9
                16/03/13;16;5;46;33;38;5
                13/03/13;13;12;34;41;40;7
                11/03/13;8;16;44;7;49;6
                09/03/13;49;4;40;11;22;5
                06/03/13;28;36;42;26;44;4
                04/03/13;47;1;45;9;30;10
                02/03/13;18;38;5;22;30;2
                27/02/13;25;40;21;34;6;7
                25/02/13;43;18;17;14;46;2
                23/02/13;47;36;42;30;45;5
                20/02/13;6;8;42;27;7;1
                18/02/13;2;13;19;41;5;5
                16/02/13;19;34;26;27;4;6
                13/02/13;39;48;19;46;14;2
                11/02/13;25;42;1;36;45;7
                09/02/13;23;5;2;47;4;7
                06/02/13;40;3;7;33;25;1
                04/02/13;34;33;18;6;30;2
                02/02/13;45;33;7;6;34;3
                30/01/13;41;31;40;11;48;5
                28/01/13;38;29;20;40;28;9
                26/01/13;18;39;2;23;34;6
                23/01/13;11;49;36;9;19;6
                21/01/13;35;7;32;38;22;6
                19/01/13;22;23;45;42;9;8
                16/01/13;27;6;16;24;46;5
                14/01/13;35;30;10;37;7;6
                12/01/13;13;48;40;6;37;7
                09/01/13;30;33;22;29;26;9
                07/01/13;45;31;15;32;48;5
                05/01/13;30;46;47;6;45;6
                02/01/13;33;21;37;22;31;4
                31/12/12;4;47;21;44;36;3
                29/12/12;45;7;11;37;23;4
                26/12/12;3;17;31;5;2;9
                24/12/12;5;12;32;7;47;6
                22/12/12;47;1;2;34;24;1
                19/12/12;5;10;25;19;49;8
                17/12/12;16;27;39;29;32;5
                15/12/12;26;24;11;33;41;9
                12/12/12;37;19;32;36;20;4
                10/12/12;36;16;4;20;47;8
                08/12/12;22;47;45;24;28;2
                05/12/12;28;24;36;45;27;8
                03/12/12;39;25;16;6;11;6
                01/12/12;19;25;12;45;44;10
                28/11/12;16;34;28;4;11;1
                26/11/12;35;15;48;44;9;6
                24/11/12;18;21;19;5;28;2
                21/11/12;10;43;6;4;46;10
                19/11/12;6;41;16;1;3;1
                17/11/12;8;6;27;37;33;7
                14/11/12;29;40;39;46;21;8
                12/11/12;25;45;20;6;48;7
                10/11/12;19;46;17;3;43;5
                07/11/12;34;16;21;2;40;7
                05/11/12;27;14;37;9;33;7
                03/11/12;15;11;9;22;36;8
                31/10/12;29;23;41;16;5;1
                29/10/12;19;16;46;13;38;7
                27/10/12;29;2;41;47;10;1
                24/10/12;30;24;5;40;17;7
                22/10/12;28;25;24;14;41;5
                20/10/12;34;14;11;24;41;5
                17/10/12;19;10;32;20;13;2
                15/10/12;7;23;11;39;44;8
                13/10/12;41;49;1;35;16;4
                10/10/12;16;35;37;3;19;3
                08/10/12;39;32;24;13;27;2
                06/10/12;27;1;47;30;39;4
                03/10/12;16;44;25;26;24;1
                01/10/12;34;2;40;29;41;6
                29/09/12;21;18;47;10;7;1
                26/09/12;42;29;38;12;46;9
                24/09/12;41;18;40;1;21;6
                22/09/12;17;23;37;44;25;9
                19/09/12;49;5;34;27;41;7
                17/09/12;16;25;14;7;17;7
                15/09/12;17;21;43;37;15;2
                12/09/12;32;1;49;12;38;8
                10/09/12;19;28;43;3;25;9
                08/09/12;9;22;43;34;15;4
                05/09/12;37;8;1;26;10;4
                03/09/12;34;27;22;18;37;3
                01/09/12;28;5;22;25;13;10
                29/08/12;20;29;26;11;8;9
                27/08/12;18;32;40;7;8;5
                25/08/12;9;13;2;29;10;9
                22/08/12;14;13;18;33;22;7
                20/08/12;45;26;33;27;11;2
                18/08/12;25;26;42;12;2;7
                15/08/12;13;24;2;15;19;5
                13/08/12;49;25;12;16;4;4
                11/08/12;7;1;10;45;44;9
                08/08/12;32;35;42;11;1;4
                06/08/12;12;7;10;34;47;7
                04/08/12;29;49;34;26;25;6
                01/08/12;33;45;17;30;11;6
                30/07/12;35;6;38;4;13;3
                28/07/12;29;4;6;39;7;3
                25/07/12;17;16;14;32;36;6
                23/07/12;40;31;38;23;28;3
                21/07/12;22;3;1;44;40;3
                18/07/12;26;25;4;28;32;5
                16/07/12;3;32;6;19;37;2
                14/07/12;22;44;40;5;41;6
                11/07/12;23;20;30;21;36;9
                09/07/12;15;38;41;45;26;3
                07/07/12;5;30;17;1;44;1
                04/07/12;13;40;37;17;39;6
                02/07/12;2;15;7;46;6;5
                30/06/12;13;45;1;42;12;4
                27/06/12;22;41;5;1;11;7
                25/06/12;27;11;40;10;13;7
                23/06/12;41;12;6;47;27;3
                20/06/12;36;33;15;41;47;5
                18/06/12;37;5;7;16;38;3
                16/06/12;14;31;1;39;27;6
                13/06/12;33;48;20;8;3;10
                11/06/12;20;6;16;4;29;1
                09/06/12;13;25;14;18;20;6
                06/06/12;21;23;12;24;13;6
                04/06/12;38;42;35;43;40;4
                02/06/12;26;9;34;39;22;1
                30/05/12;9;30;13;17;5;3
                28/05/12;30;42;38;15;41;3
                26/05/12;27;47;40;41;29;7
                23/05/12;19;1;35;49;3;9
                21/05/12;37;45;23;19;7;10
                19/05/12;11;23;48;24;42;2
                16/05/12;21;49;22;15;31;1
                14/05/12;26;11;3;22;43;6
                12/05/12;6;34;22;20;19;5
                09/05/12;36;26;18;41;32;4
                07/05/12;21;13;26;46;12;10
                05/05/12;21;10;37;8;11;9
                02/05/12;35;26;29;3;38;1
                30/04/12;39;22;32;18;4;4
                28/04/12;48;22;10;2;37;4
                25/04/12;44;15;20;30;29;7
                23/04/12;33;9;34;45;24;6
                21/04/12;41;3;48;31;18;10
                18/04/12;34;5;3;20;24;3
                16/04/12;2;21;13;1;16;2
                14/04/12;1;22;45;40;3;1
                11/04/12;49;27;15;29;19;1
                09/04/12;26;14;31;33;2;10
                07/04/12;46;19;45;42;47;8
                04/04/12;36;40;27;38;11;8
                02/04/12;33;23;3;19;39;2
                31/03/12;16;25;1;26;2;9
                28/03/12;15;20;45;17;4;9
                26/03/12;36;14;49;29;13;6
                24/03/12;48;8;18;13;11;8
                21/03/12;8;14;43;37;48;5
                19/03/12;10;28;4;11;15;4
                17/03/12;32;14;49;23;13;1
                14/03/12;13;7;31;36;43;9
                12/03/12;48;25;16;46;14;10
                10/03/12;2;40;4;44;37;5
                07/03/12;6;39;31;22;16;7
                05/03/12;31;30;28;34;17;3
                03/03/12;2;24;3;39;27;8
                29/02/12;14;27;11;17;35;4
                27/02/12;45;41;33;8;23;1
                25/02/12;8;7;19;4;27;1
                22/02/12;43;33;39;11;31;10
                20/02/12;34;31;9;3;35;5
                18/02/12;49;48;5;17;47;6
                15/02/12;11;36;10;22;31;1
                13/02/12;23;9;22;24;36;5
                11/02/12;11;12;46;32;36;6
                08/02/12;27;19;12;37;15;3
                06/02/12;15;49;24;13;29;3
                04/02/12;38;32;10;17;9;3
                01/02/12;16;5;49;43;2;7
                30/01/12;22;40;1;35;32;8
                28/01/12;23;12;47;15;18;6
                25/01/12;2;23;8;30;48;5
                23/01/12;39;44;48;20;25;6
                21/01/12;36;23;1;31;17;4
                18/01/12;21;9;33;13;42;4
                16/01/12;39;36;29;47;38;8
                14/01/12;1;38;19;49;29;8
                11/01/12;9;7;44;36;23;7
                09/01/12;34;15;26;25;32;4
                07/01/12;1;6;12;10;8;8
                04/01/12;10;23;2;43;34;5
                02/01/12;3;36;30;16;24;9
                31/12/11;32;35;17;28;2;2
                28/12/11;39;41;16;31;36;5
                26/12/11;36;43;42;23;28;4
                24/12/11;7;10;28;11;12;8
                21/12/11;27;42;33;45;37;2
                19/12/11;42;23;13;35;26;5
                17/12/11;41;9;37;38;34;5
                14/12/11;42;14;21;33;48;1
                12/12/11;48;29;1;25;16;1
                10/12/11;14;43;26;30;28;8
                07/12/11;32;35;31;48;8;1
                05/12/11;43;47;38;36;30;5
                03/12/11;31;6;49;34;26;1
                30/11/11;29;2;42;49;4;2
                28/11/11;11;24;1;15;2;9
                26/11/11;47;31;16;3;39;1
                23/11/11;39;16;6;10;21;5
                21/11/11;46;33;31;49;18;1
                19/11/11;45;37;22;33;34;5
                16/11/11;37;41;27;17;12;10
                14/11/11;25;43;18;22;3;7
                12/11/11;44;48;13;33;12;7
                09/11/11;17;8;23;12;37;2
                07/11/11;18;47;11;2;30;5
                05/11/11;38;2;13;32;20;10
                02/11/11;2;38;44;35;42;9
                31/10/11;24;13;47;37;21;7
                29/10/11;12;17;46;42;38;8
                26/10/11;35;6;2;3;20;1
                24/10/11;15;18;17;5;31;7
                22/10/11;45;44;32;29;6;7
                19/10/11;38;35;23;3;44;8
                17/10/11;14;13;18;4;48;10
                15/10/11;13;37;27;5;39;3
                12/10/11;12;9;20;30;25;5
                10/10/11;15;47;16;45;3;7
                08/10/11;31;44;21;30;22;7
                05/10/11;20;2;7;42;27;5
                03/10/11;40;28;27;12;4;1
                01/10/11;25;38;14;32;15;3
                28/09/11;16;42;36;3;8;3
                26/09/11;11;44;33;4;49;9
                24/09/11;36;4;41;33;40;6
                21/09/11;40;20;46;19;16;4
                19/09/11;13;1;27;48;35;7
                17/09/11;15;40;1;23;2;4
                14/09/11;14;42;5;16;11;3
                12/09/11;13;45;18;32;30;2
                10/09/11;15;1;28;24;10;5
                07/09/11;13;40;41;3;12;7
                05/09/11;7;17;22;10;23;5
                03/09/11;42;41;7;13;47;5
                31/08/11;7;42;39;9;5;3
                29/08/11;46;30;12;3;10;2
                27/08/11;27;21;19;13;45;2
                24/08/11;3;36;47;4;17;4
                22/08/11;40;36;38;44;17;1
                20/08/11;21;40;49;31;22;4
                17/08/11;8;49;29;45;3;9
                15/08/11;23;3;8;4;1;8
                13/08/11;3;13;4;41;5;9
                10/08/11;28;4;27;29;38;2
                08/08/11;18;12;1;26;30;9
                06/08/11;17;13;15;4;39;4
                03/08/11;20;4;19;17;5;10
                01/08/11;32;37;43;10;25;3
                30/07/11;8;41;20;46;12;1
                27/07/11;6;11;7;5;4;10
                25/07/11;38;22;3;11;41;7
                23/07/11;43;32;18;13;46;5
                20/07/11;26;45;18;23;6;6
                18/07/11;19;5;38;47;26;7
                16/07/11;27;35;42;18;37;3
                13/07/11;4;46;41;12;16;6
                11/07/11;7;43;23;48;47;9
                09/07/11;15;4;31;45;44;6
                06/07/11;9;33;10;24;3;6
                04/07/11;14;46;31;25;37;4
                02/07/11;49;11;26;1;7;5
                29/06/11;38;11;37;1;18;4
                27/06/11;43;5;14;20;12;3
                25/06/11;39;43;10;17;6;3
                22/06/11;33;21;26;28;22;5
                20/06/11;27;2;23;8;36;9
                18/06/11;9;12;43;46;33;10
                15/06/11;47;41;9;37;36;8
                13/06/11;22;3;18;17;28;6
                11/06/11;39;32;44;37;5;5
                08/06/11;20;16;40;11;24;5
                06/06/11;10;30;45;22;13;1
                04/06/11;35;4;27;15;3;2
                01/06/11;30;45;32;25;26;5
                30/05/11;14;22;47;20;21;9
                28/05/11;2;5;3;1;43;9
                25/05/11;14;45;34;27;38;3
                23/05/11;15;29;38;19;33;3
                21/05/11;27;15;35;5;14;10
                18/05/11;27;23;16;17;47;1
                16/05/11;41;43;9;11;46;8
                14/05/11;38;31;35;42;3;8
                11/05/11;45;14;26;28;38;5
                09/05/11;13;48;3;26;22;7
                07/05/11;42;28;37;38;3;8
                04/05/11;44;29;11;7;13;2
                02/05/11;25;23;4;1;40;2
                30/04/11;8;49;42;9;2;3
                27/04/11;5;26;14;28;23;6
                25/04/11;18;2;21;34;10;2
                23/04/11;40;21;28;32;8;9
                20/04/11;15;41;18;17;33;9
                18/04/11;6;10;22;7;21;5
                16/04/11;17;35;24;47;6;8
                13/04/11;38;6;33;43;23;1
                11/04/11;13;47;22;3;32;6
                09/04/11;6;20;31;22;41;8
                06/04/11;12;19;1;32;44;3
                04/04/11;12;23;37;13;10;7
                02/04/11;5;24;7;46;35;3
                30/03/11;15;23;27;43;29;10
                28/03/11;15;10;16;46;43;1
                26/03/11;17;26;34;4;30;9
                23/03/11;13;4;24;21;10;5
                21/03/11;28;23;3;40;31;1
                19/03/11;26;10;11;23;1;8
                16/03/11;23;20;32;7;14;4
                14/03/11;32;38;36;34;27;7
                12/03/11;15;34;22;33;16;9
                09/03/11;9;43;3;29;15;8
                07/03/11;7;38;23;9;17;5
                05/03/11;11;45;44;27;31;2
                02/03/11;20;22;40;2;3;7
                28/02/11;20;49;40;17;31;6
                26/02/11;35;24;10;26;48;1
                23/02/11;5;2;33;21;28;10
                21/02/11;36;20;21;9;46;6
                19/02/11;25;2;49;32;1;6
                16/02/11;44;35;32;8;33;9
                14/02/11;31;35;40;9;48;1
                12/02/11;13;38;2;45;4;2
                09/02/11;15;31;41;27;43;7
                07/02/11;6;8;49;35;25;1
                05/02/11;31;22;37;6;1;7
                02/02/11;27;6;44;23;22;3
                31/01/11;20;10;13;43;3;5
                29/01/11;14;33;44;31;12;8
                26/01/11;23;45;6;48;17;1
                24/01/11;3;39;6;48;9;4
                22/01/11;13;27;6;31;8;7
                19/01/11;36;4;12;13;1;4
                17/01/11;48;49;36;24;21;5
                15/01/11;26;43;6;36;29;8
                12/01/11;41;40;30;28;17;7
                10/01/11;35;33;40;37;11;4
                08/01/11;47;34;12;30;31;10
                05/01/11;27;47;4;5;32;5
                03/01/11;34;37;10;18;30;2
                01/01/11;43;49;46;34;11;3
                29/12/10;47;15;46;29;11;3
                27/12/10;30;44;42;39;13;9
                25/12/10;16;30;29;7;10;5
                22/12/10;8;18;36;1;29;9
                20/12/10;32;23;9;6;13;4
                18/12/10;35;41;40;11;22;7
                15/12/10;37;6;16;28;4;8
                13/12/10;6;14;49;40;9;3
                11/12/10;38;3;9;11;28;1
                08/12/10;19;15;44;4;24;1
                06/12/10;13;30;33;25;36;9
                04/12/10;33;12;24;7;15;6
                01/12/10;34;14;32;31;46;3
                29/11/10;15;23;16;41;30;8
                27/11/10;9;43;15;44;10;5
                24/11/10;32;20;22;47;14;5
                22/11/10;4;21;17;23;26;2
                20/11/10;27;12;11;29;1;2
                17/11/10;30;38;4;9;46;10
                15/11/10;33;47;14;20;17;1
                13/11/10;5;17;25;38;29;2
                10/11/10;47;48;20;39;16;4
                08/11/10;35;6;9;14;47;9
                06/11/10;24;19;35;7;42;3
                03/11/10;46;33;15;6;49;1
                01/11/10;17;24;28;1;15;10
                30/10/10;38;35;4;22;14;5
                27/10/10;32;13;15;46;3;5
                25/10/10;4;36;40;10;41;10
                23/10/10;47;49;9;16;14;7
                20/10/10;13;24;33;18;11;7
                18/10/10;1;31;38;26;29;5
                16/10/10;37;22;46;13;1;9
                13/10/10;33;22;9;44;25;3
                11/10/10;9;20;35;4;1;8
                09/10/10;17;43;23;2;26;3
                06/10/10;33;6;43;25;37;1
                04/10/10;7;46;31;29;9;8
                02/10/10;35;13;16;41;7;1
                29/09/10;41;32;33;25;26;3
                27/09/10;15;1;23;22;46;9
                25/09/10;42;5;12;29;21;2
                22/09/10;37;38;2;14;17;1
                20/09/10;1;37;25;45;17;9
                18/09/10;7;43;33;11;1;1
                15/09/10;40;1;30;8;38;6
                13/09/10;33;39;25;43;8;8
                11/09/10;36;41;45;13;7;5
                08/09/10;24;47;21;44;13;3
                06/09/10;29;22;17;19;43;8
                04/09/10;11;42;9;49;15;3
                01/09/10;20;39;33;21;16;2
                30/08/10;22;49;28;3;16;4
                28/08/10;13;16;18;20;19;2
                25/08/10;39;49;23;19;36;3
                23/08/10;49;41;9;28;16;5
                21/08/10;8;44;14;48;29;7
                18/08/10;49;43;46;27;23;6
                16/08/10;13;22;40;28;31;9
                14/08/10;21;27;9;49;11;5
                11/08/10;7;22;8;26;5;2
                09/08/10;7;15;18;8;25;6
                07/08/10;43;6;46;27;5;7
                04/08/10;32;8;46;22;9;8
                02/08/10;16;32;44;38;37;3
                31/07/10;2;25;44;28;8;4
                28/07/10;25;37;7;10;47;10
                26/07/10;4;42;37;23;43;7
                24/07/10;18;43;16;7;33;5
                21/07/10;43;45;21;3;9;1
                19/07/10;27;24;16;10;47;5
                17/07/10;32;28;47;20;22;6
                14/07/10;48;30;5;26;11;1
                12/07/10;47;11;15;24;38;6
                10/07/10;27;32;12;42;30;7
                07/07/10;20;47;49;26;31;10
                05/07/10;39;33;43;22;31;10
                03/07/10;10;46;2;33;28;8
                30/06/10;14;44;28;18;17;2
                28/06/10;41;49;42;19;12;8
                26/06/10;47;16;11;37;7;10
                23/06/10;16;27;41;1;35;1
                21/06/10;45;35;24;37;48;2
                19/06/10;21;23;19;36;49;4
                16/06/10;40;48;15;9;3;10
                14/06/10;15;48;23;49;45;2
                12/06/10;30;43;48;24;15;7
                09/06/10;14;48;44;24;20;10
                07/06/10;29;48;42;28;26;1
                05/06/10;37;43;31;45;22;5
                02/06/10;43;11;14;23;17;10
                31/05/10;46;49;32;5;33;1
                29/05/10;33;21;49;26;46;1
                26/05/10;47;3;35;22;6;1
                24/05/10;8;35;29;12;3;1
                22/05/10;2;48;40;46;17;10
                19/05/10;24;12;17;38;30;7
                17/05/10;9;27;26;29;36;5
                15/05/10;32;31;44;27;9;8
                12/05/10;28;22;27;14;23;4
                10/05/10;41;4;35;33;10;5
                08/05/10;16;29;31;39;1;2
                05/05/10;10;30;18;27;4;1
                03/05/10;8;11;12;26;48;6
                01/05/10;39;28;3;42;6;5
                28/04/10;34;49;9;25;38;1
                26/04/10;29;24;4;46;7;10
                24/04/10;17;34;27;3;41;4
                21/04/10;24;26;35;9;1;4
                19/04/10;44;22;17;38;2;8
                17/04/10;24;42;16;9;32;3
                14/04/10;9;12;29;2;21;7
                12/04/10;4;36;11;31;46;10
                10/04/10;33;13;49;36;22;4
                07/04/10;28;11;2;33;43;1
                05/04/10;17;18;36;21;47;6
                03/04/10;35;39;20;48;42;2
                31/03/10;46;28;21;39;49;1
                29/03/10;2;44;41;34;46;2
                27/03/10;43;42;9;21;46;6
                24/03/10;28;9;35;8;42;6
                22/03/10;44;34;25;47;29;9
                20/03/10;15;36;28;49;2;3
                17/03/10;46;1;24;18;9;7
                15/03/10;18;15;1;4;38;6
                13/03/10;32;37;16;6;8;7
                10/03/10;36;13;44;1;48;2
                08/03/10;23;11;43;49;10;10
                06/03/10;5;18;26;9;36;9
                03/03/10;17;37;23;25;2;7
                01/03/10;19;11;8;48;49;7
                27/02/10;13;40;2;10;35;1
                24/02/10;45;2;1;27;31;8
                22/02/10;41;48;18;11;24;2
                20/02/10;34;49;36;39;23;8
                17/02/10;23;40;26;22;29;5
                15/02/10;48;39;24;8;15;8
                13/02/10;1;7;38;3;14;5
                10/02/10;6;45;19;12;11;10
                08/02/10;36;13;24;7;42;4
                06/02/10;16;37;18;5;34;5
                03/02/10;44;48;7;30;13;7
                01/02/10;29;1;39;40;18;2
                30/01/10;44;26;18;21;47;3
                27/01/10;10;15;43;45;5;9
                25/01/10;6;8;31;45;36;9
                23/01/10;24;39;2;13;48;1
                20/01/10;13;37;48;45;28;9
                18/01/10;8;7;22;28;38;10
                16/01/10;21;38;32;3;33;10
                13/01/10;31;4;14;37;7;8
                11/01/10;24;20;31;36;6;4
                09/01/10;35;4;14;23;46;7
                06/01/10;19;49;31;44;38;3
                04/01/10;33;21;41;18;32;9
                02/01/10;43;5;23;49;17;4
                30/12/09;21;39;5;2;15;10
                28/12/09;23;12;15;27;46;6
                26/12/09;7;6;41;25;16;5
                23/12/09;24;44;18;17;15;6
                21/12/09;38;42;28;3;27;9
                19/12/09;40;15;16;6;9;6
                16/12/09;39;15;23;49;30;5
                14/12/09;46;8;26;13;38;2
                12/12/09;4;30;13;18;39;1
                09/12/09;1;31;11;22;23;1
                07/12/09;20;42;43;33;19;5
                05/12/09;28;22;7;16;39;7
                02/12/09;10;47;20;28;21;6
                30/11/09;12;43;7;23;27;6
                28/11/09;35;37;41;15;39;4
                25/11/09;14;33;39;15;11;6
                23/11/09;13;12;3;37;30;8
                21/11/09;20;33;46;40;12;6
                18/11/09;24;20;22;19;1;6
                16/11/09;20;32;36;19;27;7
                14/11/09;39;16;47;28;24;9
                11/11/09;41;47;22;17;7;6
                09/11/09;3;2;29;48;1;9
                07/11/09;1;41;13;3;18;1
                04/11/09;33;18;19;22;23;1
                02/11/09;17;34;23;40;9;9
                31/10/09;23;39;36;27;30;2
                28/10/09;8;11;7;37;30;3
                26/10/09;49;47;42;1;3;7
                24/10/09;39;28;15;38;27;10
                21/10/09;10;49;26;15;1;7
                19/10/09;4;31;11;3;6;1
                17/10/09;12;49;8;20;16;5
                14/10/09;6;35;36;42;24;2
                12/10/09;38;7;48;43;28;5
                10/10/09;3;38;1;23;16;3
                07/10/09;4;1;21;12;46;8
                05/10/09;21;12;20;11;32;4
                03/10/09;47;15;49;7;9;7
                30/09/09;33;35;40;5;2;4
                28/09/09;30;20;16;3;44;4
                26/09/09;2;37;43;21;25;9
                23/09/09;24;42;4;47;5;6
                21/09/09;3;4;38;46;7;2
                19/09/09;12;27;38;33;19;7
                16/09/09;40;7;21;25;30;1
                14/09/09;9;18;43;32;22;1
                12/09/09;41;11;4;29;7;4
                09/09/09;1;12;23;22;7;4
                07/09/09;8;21;4;31;39;2
                05/09/09;1;37;17;44;20;8
                02/09/09;17;5;12;6;15;1
                31/08/09;16;13;1;5;20;2
                29/08/09;34;7;27;23;19;7
                26/08/09;44;31;7;38;14;1
                24/08/09;22;18;33;28;11;2
                22/08/09;31;21;8;27;29;10
                19/08/09;35;42;7;33;28;10
                17/08/09;2;9;17;14;25;9
                15/08/09;1;41;32;24;27;9
                12/08/09;6;33;17;34;39;5
                10/08/09;5;22;31;2;24;6
                08/08/09;41;20;16;38;2;9
                05/08/09;40;10;29;20;43;7
                03/08/09;9;38;18;26;49;8
                01/08/09;44;10;18;45;22;6
                29/07/09;16;25;14;35;3;3
                27/07/09;18;47;7;13;48;4
                25/07/09;27;40;3;14;33;9
                22/07/09;24;35;45;28;17;6
                20/07/09;27;23;44;34;5;1
                18/07/09;44;14;26;34;9;9
                15/07/09;4;1;23;14;25;10
                13/07/09;26;2;20;34;18;1
                11/07/09;14;17;35;5;42;1
                08/07/09;16;4;10;6;5;3
                06/07/09;12;31;32;44;45;2
                04/07/09;39;4;8;43;27;3
                01/07/09;34;5;28;13;29;4
                29/06/09;35;43;9;28;10;8
                27/06/09;13;4;3;41;6;8
                24/06/09;17;21;22;16;4;1
                22/06/09;36;17;42;28;41;4
                20/06/09;26;27;49;21;33;7
                17/06/09;3;27;41;8;37;2
                15/06/09;49;11;41;21;40;4
                13/06/09;39;16;46;28;24;4
                10/06/09;45;42;27;49;48;7
                08/06/09;31;29;41;25;22;5
                06/06/09;32;46;13;33;15;10
                03/06/09;46;21;32;26;14;6
                01/06/09;18;26;47;24;35;1
                30/05/09;30;25;34;14;10;9
                27/05/09;7;48;5;3;23;7
                25/05/09;46;40;6;3;25;4
                23/05/09;38;13;33;3;25;3
                20/05/09;35;28;15;3;23;10
                18/05/09;49;26;35;34;28;4
                16/05/09;1;2;26;44;7;9
                13/05/09;38;36;49;39;12;10
                11/05/09;15;27;48;9;34;6
                09/05/09;45;28;22;30;20;3
                06/05/09;48;36;13;20;44;1
                04/05/09;33;1;23;12;46;1
                02/05/09;7;15;11;5;23;1
                29/04/09;4;30;29;26;15;3
                27/04/09;9;37;21;34;4;2
                25/04/09;34;23;49;9;20;8
                22/04/09;2;31;49;33;43;9
                20/04/09;11;34;38;43;12;3
                18/04/09;31;20;45;12;32;8
                15/04/09;23;43;37;12;39;8
                13/04/09;20;24;30;11;9;1
                11/04/09;21;5;2;23;19;7
                08/04/09;46;33;10;34;7;6
                06/04/09;43;33;48;31;28;7
                04/04/09;37;41;27;8;45;6
                01/04/09;37;27;30;22;45;3
                30/03/09;32;47;45;29;24;10
                28/03/09;19;26;23;22;27;2
                25/03/09;10;34;15;33;5;7
                23/03/09;1;25;10;2;33;4
                21/03/09;45;32;15;2;39;10
                18/03/09;42;3;39;20;34;2
                16/03/09;27;45;35;36;44;2
                14/03/09;27;18;20;11;38;6
                11/03/09;4;7;11;22;8;5
                09/03/09;27;32;5;40;3;9
                07/03/09;36;15;24;2;22;8
                04/03/09;7;9;29;25;10;6
                02/03/09;41;29;14;48;8;10
                28/02/09;45;14;41;25;16;10
                25/02/09;15;4;21;30;36;4
                23/02/09;3;14;34;31;22;7
                21/02/09;47;21;48;39;40;5
                18/02/09;28;40;10;23;43;9
                16/02/09;46;23;29;21;16;4
                14/02/09;12;24;18;44;16;4
                11/02/09;35;46;10;1;14;8
                09/02/09;17;13;31;3;46;5
                07/02/09;4;16;34;22;49;10
                04/02/09;20;43;47;27;10;3
                02/02/09;4;38;12;31;41;8
                31/01/09;6;31;40;18;36;7
                28/01/09;40;7;41;38;46;5
                26/01/09;39;8;13;49;10;10
                24/01/09;5;40;15;20;28;10
                21/01/09;32;47;10;35;3;3
                19/01/09;39;38;7;32;26;9
                17/01/09;2;46;27;37;5;4
                14/01/09;5;42;1;19;13;3
                12/01/09;47;11;29;4;9;8
                10/01/09;49;40;21;10;44;2
                07/01/09;37;39;9;33;11;8
                05/01/09;8;29;36;25;11;2
                03/01/09;47;22;24;12;38;1
                31/12/08;11;5;20;30;24;8
                29/12/08;26;38;14;21;27;4
                27/12/08;36;47;17;49;37;10
                24/12/08;33;27;2;41;4;5
                22/12/08;5;27;2;35;48;3
                20/12/08;41;46;2;22;26;5
                17/12/08;49;44;31;13;33;9
                15/12/08;48;5;15;2;27;8
                13/12/08;24;38;8;42;31;7
                10/12/08;41;38;10;35;11;3
                08/12/08;29;15;1;31;11;8
                06/12/08;48;2;5;13;24;4
                03/12/08;26;29;34;42;31;10
                01/12/08;32;15;19;37;38;1
                29/11/08;18;36;20;32;22;7
                26/11/08;49;11;13;25;28;5
                24/11/08;43;36;31;30;17;8
                22/11/08;45;12;30;36;20;6
                19/11/08;34;26;37;41;2;4
                17/11/08;1;6;19;23;41;6
                15/11/08;41;10;48;43;22;3
                12/11/08;45;35;34;40;23;5
                10/11/08;12;9;21;45;38;6
                08/11/08;25;35;33;5;22;9
                05/11/08;47;4;38;15;8;7
                03/11/08;26;2;23;20;24;8
                01/11/08;22;4;27;36;45;3
                29/10/08;43;28;22;41;49;4
                27/10/08;46;37;44;4;6;2
                25/10/08;13;11;22;46;19;3
                22/10/08;11;28;12;48;14;2
                20/10/08;43;7;48;31;15;3
                18/10/08;44;35;4;32;39;10
                15/10/08;49;28;18;20;40;1
                13/10/08;11;10;41;37;48;4
                11/10/08;46;22;10;39;20;4
                08/10/08;24;48;32;41;22;1
                6 octobre 2008;19;33;41;24;27;9`;

                // ============================================================================
                // FONCTIONS DE COULEURS POUR LES BOULES
                // ============================================================================

                // Obtenir la couleur d'une boule selon son numéro

                function getBallColor(number) {
                    if (number >= 1 && number <= 9) {
                        return '#f44336';
                    } else if (number >= 10 && number <= 19) {
                        return '#3f51b5';
                    } else if (number >= 20 && number <= 29) {
                        return '#2196f3';
                    } else if (number >= 30 && number <= 39) {
                        return '#4caf50';
                    } else if (number >= 40 && number <= 49) {
                        return '#e91e63';
                    } else {
                        return '#DDA0DD';
                    }
                }

                // Obtenir la couleur d'une boule chance

                function getChanceBallColor(number) {
                    return '#2C3E50';
                }


                // ============================================================================
                // FONCTIONS D'INITIALISATION PRINCIPALES
                // ============================================================================

                // Initialisation au chargement de la page
                document.addEventListener('DOMContentLoaded', function () {  // Écouteur événement DOMContentLoaded
                    initApp();                                              // Appel fonction initApp
                    createNumberGrids();                                    // Appel fonction createNumberGrids
                    document.getElementById('mlModel').addEventListener('change', showMLExplanation);
                    loadRealData();                                         // Appel fonction loadRealData

                    // Gestion des clics sur les items de navigation
                    document.querySelectorAll('.nav-item').forEach(item => {
                        item.addEventListener('click', function () {
                            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                            this.classList.add('active');                   // Ajoute active à l'item cliqué
                        });
                    });

                    initMobileMenu();  // Appel fonction initMobileMenu
                });

                // Initialisation principale de l'application
                function initApp() {            // Déclaration fonction initApp
                    generateSimulatedData();    // Appel fonction generateSimulatedData
                    updateStats();              // Appel fonction updateStats
                    initCharts();               // Appel fonction initCharts
                    updateDrawDates();  // Appel fonction updateDrawDates
                    showPredictionExplanation('montecarlo'); // Appel fonction showPredictionExplanation
                }

                // Chargement des données réelles du Loto
                function loadRealData() {   // Déclaration fonction loadRealData
                    try {
                        let csvContent = realLotoDataCSV;          // Assignation données CSV

                        // Nettoyage du BOM (Byte Order Mark)
                        if (csvContent.startsWith('\ufeff')) {     // Si commence par BOM
                            csvContent = csvContent.substring(1);  // Supprime premier caractère
                        }

                        // Découpage et nettoyage des lignes
                        let rows = csvContent.split(/[\r\n]+/)     // Split par retours à la ligne
                            .map(row => row.trim())  // Trim chaque ligne
                            .filter(row => row.length > 0); // Filtre lignes vides

                        if (rows.length === 0) { // Si aucune ligne
                            throw new Error("Les données intégrées sont vides."); // Lance erreur
                        }

                        // Détection du délimiteur
                        const delimiter = rows[0].includes(';') ? ';' : ',';
                        let headerRowString = rows.shift();
                        const headerRow = headerRowString.split(delimiter).map(h => h.trim().toLowerCase());

                        // Vérification des en-têtes requis
                        const requiredHeaders = ['date', 'boule_1', 'boule_2', 'boule_3', 'boule_4', 'boule_5', 'numero_chance'];
                        const missingHeaders = requiredHeaders.filter(h => !headerRow.includes(h)); // Filtre en-têtes manquants

                        if (missingHeaders.length > 0) { // Si en-têtes manquants
                            throw new Error(`En-têtes manquants: ${missingHeaders.join(', ')}. En-têtes trouvés: ${headerRow.join(', ')}`);
                        }

                        // Initialisation de la structure de données
                        historicalData = {
                            draws: [],
                            frequencies: {},
                            chanceFrequencies: {}
                        };

                        // Récupération des indices des colonnes
                        const dateIndex = headerRow.indexOf('date');
                        const chanceIndex = headerRow.indexOf('numero_chance');
                        const ballIndices = [
                            headerRow.indexOf('boule_1'),
                            headerRow.indexOf('boule_2'),                   // Index boule 2
                            headerRow.indexOf('boule_3'),                   // Index boule 3
                            headerRow.indexOf('boule_4'),                   // Index boule 4
                            headerRow.indexOf('boule_5')                    // Index boule 5
                        ];

                        // Traitement de chaque ligne de données
                        for (let row of rows) {                             // Boucle sur chaque ligne
                            const values = row.split(delimiter).map(v => v.trim()); // Split et nettoie valeurs

                            // Vérification du nombre de colonnes
                            if (values.length !== headerRow.length) continue; // Skip si mauvais nombre colonnes

                            try {                                              // Début bloc try interne
                                const dateStr = values[dateIndex];             // Récupère date

                                // Extraction et validation des numéros principaux
                                const mainNumbers = ballIndices.map(index => { // Map sur indices boules
                                    const num = parseInt(values[index]);       // Parse nombre
                                    return isNaN(num) ? null : num;            // Retourne null si NaN
                                }).filter(num => num !== null && num >= 1 && num <= 49); // Filtre numéros valides

                                // Vérification qu'on a bien 5 numéros uniques
                                if (mainNumbers.length !== 5 || new Set(mainNumbers).size !== 5) { // Si pas 5 numéros uniques
                                    continue; // Skip cette ligne
                                }

                                // Extraction et validation du numéro chance
                                const luckyNumber = parseInt(values[chanceIndex]); // Parse numéro chance
                                if (isNaN(luckyNumber) || luckyNumber < 1 || luckyNumber > 10) { // Si numéro chance invalide
                                    continue; // Skip cette ligne
                                }

                                // Tri des numéros principaux
                                mainNumbers.sort((a, b) => a - b);          // Tri croissant

                                // Ajout du tirage valide
                                historicalData.draws.push({                 // Ajoute au tableau draws
                                    date: dateStr,                          // Propriété date
                                    numbers: mainNumbers,                   // Propriété numbers
                                    chance: luckyNumber                     // Propriété chance
                                });

                            } catch (error) {                               // Catch erreur interne
                                console.warn('Erreur lors du traitement d\'une ligne:', error); // Log warning
                                continue;                                   // Continue boucle
                            }
                        }

                        // Vérification qu'on a au moins un tirage valide
                        if (historicalData.draws.length === 0) {            // Si aucun tirage valide
                            throw new Error('Aucun tirage valide trouvé dans les données intégrées.'); // Lance erreur
                        }

                        // Tri des tirages par date (du plus récent au plus ancien)
                        historicalData.draws.sort((a, b) => {
                            const dateA = parseDrawDate(a.date);
                            const dateB = parseDrawDate(b.date);
                            return dateB - dateA; // Décroissant (plus récent en premier)
                        });

                        // Vérification du tri
                        if (historicalData.draws.length > 0) {
                            const firstDate = parseDrawDate(historicalData.draws[0].date);
                            const lastDate = parseDrawDate(historicalData.draws[historicalData.draws.length - 1].date);
                            console.log(`   Période complète chargée : ${lastDate.toLocaleDateString('fr-FR')} → ${firstDate.toLocaleDateString('fr-FR')}`);
                            console.log(`   Premier tirage (index 0) : ${historicalData.draws[0].date}`);
                            console.log(`   Dernier tirage  (index ${historicalData.draws.length - 1}) : ${historicalData.draws[historicalData.draws.length - 1].date}`);
                        }

                        filteredDraws = [...historicalData.draws];          // Copie dans filteredDraws
                        recalculateFrequencies();                           // Appel recalculateFrequencies

                        isRealDataLoaded = true;                            // Met à jour indicateur
                        updateStats();                                      // Appel updateStats
                        updateDrawDates();                                  // Appel updateDrawDates
                        populateYearSelectors();                            // Appel populateYearSelectors
                        populateMLYearSelectors();                          // Appel populateMLYearSelectors
                        applyMLPeriodFilter();                              // Initialise les tirages ML
                        displayLatestDraw();                                // Appel displayLatestDraw

                        document.getElementById('appStatus').innerHTML = `
                            <div id="appHeader">
                                <h1 id="mainTitle">ARÔME</h1>
                                <h2 id="subTitle">Analyse Statistique de jeux de loterie</h2>
                            </div>
                        `;

                        if (charts.frequencyChart) {                        // Si graphique fréquences existe
                            updateFrequencyChart();                         // Met à jour graphique
                        }

                    } catch (error) {                                       // Catch erreur principale
                        console.error('Erreur lors du chargement des données intégrées:', error); // Log erreur
                        initApp();                                          // Fallback sur données simulées
                    }
                }

                // Génération de données simulées pour les tests
                function generateSimulatedData() {                          // Déclaration fonction generateSimulatedData
                    historicalData = {                                      // Initialise historicalData
                        draws: [],                                          // Tableau tirages vide
                        frequencies: {},                                    // Objet fréquences vide
                        chanceFrequencies: {}                               // Objet fréquences chance vide
                    };

                    // Génération de 1000 tirages simulés
                    for (let i = 0; i < 1000; i++) {                        // Boucle 1000 fois
                        const date = new Date();                            // Crée nouvelle date
                        date.setDate(date.getDate() - i);                   // Décale date (jours décroissants)

                        const mainNumbers = generateUniqueRandomNumbers(5, 1, 49); // Génère 5 numéros uniques
                        const chanceNumber = Math.floor(Math.random() * 10) + 1;   // Génère numéro chance

                        historicalData.draws.push({                         // Ajoute tirage
                            date: date.toISOString().split('T')[0],         // Date format YYYY-MM-DD
                            numbers: mainNumbers,                           // Numéros principaux
                            chance: chanceNumber                            // Numéro chance
                        });

                        // Mise à jour des fréquences
                        mainNumbers.forEach(num => {                        // Pour chaque numéro principal
                            historicalData.frequencies[num] = (historicalData.frequencies[num] || 0) + 1;
                        });

                        historicalData.chanceFrequencies[chanceNumber] = (historicalData.chanceFrequencies[chanceNumber] || 0) + 1;
                    }

                    // Tri par date décroissante
                    historicalData.draws.sort((a, b) => new Date(b.date) - new Date(a.date)); // Trie décroissant
                    filteredDraws = [...historicalData.draws];              // Copie dans filteredDraws
                }

                // Génération de nombres uniques aléatoires
                function generateUniqueRandomNumbers(count, min, max) {     // Déclaration fonction generateUniqueRandomNumbers
                    const numbers = new Set();                              // Crée Set pour unicité
                    while (numbers.size < count) {                          // Tant que pas assez de nombres
                        numbers.add(Math.floor(Math.random() * (max - min + 1)) + min); // Ajoute nombre aléatoire
                    }
                    return Array.from(numbers).sort((a, b) => a - b);      // Retourne tableau trié
                }

                // Mise à jour des statistiques affichées
                function updateStats() {                                    // Déclaration fonction updateStats
                    const totalDraws = filteredDraws.length;                // Calcule nombre total tirages
                    document.getElementById('statTotalDraws').textContent = totalDraws.toLocaleString(); // Met à jour affichage
                    document.getElementById('statPeriod').textContent = isRealDataLoaded ? "Réelle" : "Simulée"; // Met à jour période
                    updatePeriodInfo();                                     // Appel updatePeriodInfo
                }

                // Formatage des dates en français
                function formatDate(dateStr) {                              // Déclaration fonction formatDate
                    const date = new Date(dateStr);                         // Crée objet Date
                    if (isNaN(date.getTime())) {                            // Si date invalide
                        return dateStr;                                     // Retourne chaîne originale
                    }
                    return date.toLocaleDateString('fr-FR');                // Retourne date format français
                }

                // ============================================================================
                // FONCTIONS POUR LES GRILLES DE SÉLECTION
                // ============================================================================

                // Création de toutes les grilles de numéros
                function createNumberGrids() { // Déclaration fonction createNumberGrids
                    createMainNumbersGrid('mainNumbersGrid', selectedMainNumbers, 'main'); // Crée grille principale
                    createChanceNumbersGrid('chanceNumbersGrid', selectedChanceNumber, 'main'); // Crée grille chance
                    createMainNumbersGrid('simMainNumbersGrid', simSelectedMainNumbers, 'sim'); // Crée grille simulation
                    createChanceNumbersGrid('simChanceNumbersGrid', simSelectedChanceNumber, 'sim'); // Crée grille chance simulation
                }

                // Création d'une grille de numéros principaux
                function createMainNumbersGrid(containerId, selectedNumbers, type) {  // Déclaration fonction createMainNumbersGrid
                    const container = document.getElementById(containerId); // Récupère conteneur
                    container.innerHTML = ''; // Vide conteneur

                    // Création des 49 boules numérotées
                    for (let i = 1; i <= 49; i++) {                         // Boucle de 1 à 49
                        const ball = document.createElement('div');         // Crée élément div
                        ball.className = 'number-ball-select';              // Ajoute classe CSS
                        ball.textContent = i;                               // Définit texte (numéro)
                        ball.dataset.number = i;                            // Définit attribut data
                        ball.style.background = getBallColor(i);            // Définit couleur fond

                        // Marquage si sélectionné
                        if (selectedNumbers.includes(i)) {                  // Si numéro sélectionné
                            ball.classList.add('selected');                 // Ajoute classe selected
                        }

                        // Gestion du clic
                        ball.addEventListener('click', () => toggleMainNumber(i, type)); // Ajoute écouteur clic
                        container.appendChild(ball);                        // Ajoute boule au conteneur
                    }

                    updateSelectedNumbersDisplay(type);                     // Met à jour affichage sélection
                }

                // Création d'une grille de numéros chance
                function createChanceNumbersGrid(containerId, selectedNumber, type) { // Déclaration fonction createChanceNumbersGrid
                    const container = document.getElementById(containerId);           // Récupère conteneur
                    container.innerHTML = '';                                         // Vide conteneur

                    // Création des 10 boules chance
                    for (let i = 1; i <= 10; i++) {                         // Boucle de 1 à 10
                        const ball = document.createElement('div');         // Crée élément div
                        ball.className = 'number-ball-chance-select';       // Ajoute classe CSS
                        ball.textContent = i;                               // Définit texte (numéro)
                        ball.dataset.number = i;                            // Définit attribut data
                        ball.style.background = getChanceBallColor(i);      // Définit couleur fond

                        // Marquage si sélectionné
                        if (selectedNumber === i) {                         // Si numéro sélectionné
                            ball.classList.add('selected');                 // Ajoute classe selected
                        }

                        // Gestion du clic
                        ball.addEventListener('click', () => toggleChanceNumber(i, type)); // Ajoute écouteur clic
                        container.appendChild(ball);                        // Ajoute boule au conteneur
                    }

                    updateSelectedNumbersDisplay(type);                     // Met à jour affichage sélection
                }

                // Basculement d'un numéro principal
                function toggleMainNumber(number, type) {                   // Déclaration fonction toggleMainNumber
                    let selectedNumbers, containerId;                       // Déclare variables locales

                    if (type === 'main') {                                  // Si type principal
                        selectedNumbers = selectedMainNumbers;              // Utilise tableau principal
                        containerId = 'mainNumbersGrid';                    // Utilise ID conteneur principal
                    } else {                                                // Sinon (simulation)
                        selectedNumbers = simSelectedMainNumbers;           // Utilise tableau simulation
                        containerId = 'simMainNumbersGrid';                 // Utilise ID conteneur simulation
                    }

                    const index = selectedNumbers.indexOf(number);          // Cherche index du numéro
                    if (index === -1) {                                     // Si pas trouvé (pas sélectionné)
                        // Ajout si moins de 5 numéros
                        if (selectedNumbers.length < 5) {                   // Si moins de 5 numéros
                            selectedNumbers.push(number);                   // Ajoute numéro
                        } else {                                            // Sinon (déjà 5 numéros)
                            alert('Vous ne pouvez sélectionner que 5 numéros maximum.');   // Affiche alerte
                            return;                                         // Quitte fonction
                        }
                    } else {                                                // Sinon (déjà sélectionné)
                        // Retrait si déjà sélectionné
                        selectedNumbers.splice(index, 1);                   // Retire numéro
                    }

                    // Regénération de la grille
                    createMainNumbersGrid(containerId, selectedNumbers, type); // Recrée grille
                }

                // Basculement d'un numéro chance
                function toggleChanceNumber(number, type) { // Déclaration fonction toggleChanceNumber
                    if (type === 'main') {                                                            // Si type principal
                        selectedChanceNumber = selectedChanceNumber === number ? null : number;       // Bascule sélection
                        createChanceNumbersGrid('chanceNumbersGrid', selectedChanceNumber, type);     // Recrée grille
                    } else {                                                                          // Sinon (simulation)
                        simSelectedChanceNumber = simSelectedChanceNumber === number ? null : number; // Bascule sélection simulation
                        createChanceNumbersGrid('simChanceNumbersGrid', simSelectedChanceNumber, type); // Recrée grille simulation
                    }

                    updateSelectedNumbersDisplay(type); // Met à jour affichage
                }

                // Mise à jour de l'affichage des numéros sélectionnés
                function updateSelectedNumbersDisplay(type) {               // Déclaration fonction updateSelectedNumbersDisplay
                    if (type === 'main') {                                  // Si type principal
                        const mainDisplay = document.getElementById('selectedMainNumbers'); // Récupère affichage principal
                        mainDisplay.innerHTML = '';                         // Vide affichage
                        selectedMainNumbers.forEach(num => {                // Pour chaque numéro sélectionné
                            const ball = document.createElement('div');     // Crée élément boule
                            ball.className = 'number-ball';                 // Ajoute classe
                            ball.textContent = num;                         // Définit numéro
                            ball.style.background = getBallColor(num);      // Définit couleur
                            mainDisplay.appendChild(ball);                  // Ajoute à l'affichage
                        });

                        const chanceDisplay = document.getElementById('selectedChanceNumber'); // Récupère affichage chance
                        chanceDisplay.innerHTML = '';                       // Vide affichage
                        if (selectedChanceNumber) {                         // Si numéro chance sélectionné
                            const ball = document.createElement('div');     // Crée élément boule
                            ball.className = 'number-ball number-ball-chance'; // Ajoute classes
                            ball.textContent = selectedChanceNumber;        // Définit numéro
                            ball.style.background = getChanceBallColor(selectedChanceNumber); // Définit couleur
                            chanceDisplay.appendChild(ball);                // Ajoute à l'affichage
                        }
                    } else {                                                // Sinon (simulation)
                        const mainDisplay = document.getElementById('simSelectedMainNumbers'); // Récupère affichage simulation
                        mainDisplay.innerHTML = '';                         // Vide affichage
                        simSelectedMainNumbers.forEach(num => {             // Pour chaque numéro simulation
                            const ball = document.createElement('div');     // Crée élément boule
                            ball.className = 'number-ball';                 // Ajoute classe
                            ball.textContent = num;                         // Définit numéro
                            ball.style.background = getBallColor(num);      // Définit couleur
                            mainDisplay.appendChild(ball);                  // Ajoute à l'affichage
                        });

                        const chanceDisplay = document.getElementById('simSelectedChanceNumber'); // Récupère affichage chance simulation
                        chanceDisplay.innerHTML = '';                       // Vide affichage
                        if (simSelectedChanceNumber) {                      // Si numéro chance simulation sélectionné
                            const ball = document.createElement('div');     // Crée élément boule
                            ball.className = 'number-ball number-ball-chance'; // Ajoute classes
                            ball.textContent = simSelectedChanceNumber;     // Définit numéro
                            ball.style.background = getChanceBallColor(simSelectedChanceNumber); // Définit couleur
                            chanceDisplay.appendChild(ball);                // Ajoute à l'affichage
                        }
                    }
                }

                // Génération d'une grille aléatoire
                function generateRandomGrid() {                                   // Déclaration fonction generateRandomGrid
                    selectedMainNumbers = generateUniqueRandomNumbers(5, 1, 49);  // Génère 5 numéros aléatoires
                    selectedChanceNumber = Math.floor(Math.random() * 10) + 1;    // Génère numéro chance aléatoire

                    createMainNumbersGrid('mainNumbersGrid', selectedMainNumbers, 'main');      // Recrée grille principale
                    createChanceNumbersGrid('chanceNumbersGrid', selectedChanceNumber, 'main'); // Recrée grille chance
                    updateSelectedNumbersDisplay('main');                                       // Met à jour affichage
                }


                // ============================================================================
                // FONCTIONS POUR L'ÉVALUATION DES GRILLES 
                // ============================================================================

                // Évaluation complète d'une grille
                function evaluateGrid() {
                    if (selectedMainNumbers.length !== 5 || !selectedChanceNumber) {
                        alert('Veuillez sélectionner 5 numéros principaux et 1 numéro chance.');
                        return;
                    }

                    const resultsDiv = document.getElementById('evalResults');
                    const frequencyScore = calculateFrequencyScore(selectedMainNumbers);
                    const patternScore = calculatePatternScore(selectedMainNumbers);
                    const statisticalScore = calculateStatisticalScore(selectedMainNumbers);
                    const clusterScore = calculateClusterScore(selectedMainNumbers);
                    const balanceScore = calculateBalanceScore(selectedMainNumbers);
                    const overallScore = Math.round((frequencyScore + patternScore + statisticalScore + clusterScore + balanceScore) / 5);

                    updateEvaluationChart({
                        frequency: frequencyScore,
                        pattern: patternScore,
                        statistical: statisticalScore,
                        cluster: clusterScore,
                        balance: balanceScore,
                        overall: overallScore
                    });

                    let results = `
                <h3>Évaluation de votre Grille</h3>
                <div style="display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap;">
                    ${selectedMainNumbers.map(num => `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`).join('')}
                    <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(selectedChanceNumber)}">${selectedChanceNumber}</div>
                </div>
                
                <div class="grid-2">
                    <div class="stat-card">
                        <h4>Score de Fréquence</h4>
                        <div class="value">${frequencyScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score de Pattern</h4>
                        <div class="value">${patternScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score Statistique</h4>
                        <div class="value">${statisticalScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score de Cluster</h4>
                        <div class="value">${clusterScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score d'Équilibre</h4>
                        <div class="value">${balanceScore}/100</div>
                    </div>
                    <div class="stat-card">
                        <h4>Score Global</h4>
                        <div class="value">${overallScore}/100</div>
                    </div>
                </div>
            `;

                    if (overallScore >= 80) {
                        results += `<div class="success-box"><strong> Grille exceptionnelle !</strong> Excellentes caractéristiques sur tous les critères.</div>`;
                    } else if (overallScore >= 70) {
                        results += `<div class="success-box"><strong> Excellente grille !</strong> Bonnes caractéristiques statistiques.</div>`;
                    } else if (overallScore >= 60) {
                        results += `<div class="info-box"><strong> ✔️ Grille correcte.</strong> Caractéristiques moyennes.</div>`;
                    } else if (overallScore >= 50) {
                        results += `<div class="info-box"><strong> ✔️ Grille acceptable.</strong> Quelques améliorations possibles.</div>`;
                    } else {
                        results += `<div class="info-box" style="background-color: rgba(233, 69, 96, 0.2); border-color: var(--highlight-color);">
                    <strong> Grille peu optimale.</strong> Envisagez de modifier certains numéros pour améliorer vos chances.
                </div>`;
                    }

                    results += `<div class="info-box" style="margin-top: 20px;">
                <h4> Conseils d'amélioration :</h4>
                <ul style="margin-left: 20px;">
                    ${frequencyScore < 60 ? '<li>Choisissez des numéros avec des fréquences historiques plus équilibrées</li>' : ''}
                    ${patternScore < 60 ? '<li>Équilibrez mieux les numéros pairs et impairs</li>' : ''}
                    ${statisticalScore < 60 ? '<li>Ajustez la somme totale vers 150-160</li>' : ''}
                    ${clusterScore < 60 ? '<li>Répartissez les numéros sur différents clusters</li>' : ''}
                    ${balanceScore < 60 ? '<li>Équilibrez la répartition par dizaines</li>' : ''}
                    ${overallScore >= 70 ? '<li>Votre grille est déjà bien optimisée !</li>' : ''}
                </ul>
            </div>`;

                    resultsDiv.innerHTML = results;
                }

                // Calcul du score de fréquence
                function calculateFrequencyScore(numbers) {
                    let totalFreq = 0;
                    numbers.forEach(num => {
                        totalFreq += historicalData.frequencies[num] || 0;
                    });

                    const avgFreq = totalFreq / numbers.length;
                    const maxFreq = Math.max(...Object.values(historicalData.frequencies));

                    return Math.min(100, Math.round((avgFreq / maxFreq) * 100));
                }

                // Calcul du score de pattern
                function calculatePatternScore(numbers) {
                    const evenCount = numbers.filter(n => n % 2 === 0).length;
                    const oddCount = numbers.filter(n => n % 2 !== 0).length;
                    const parityScore = Math.min(evenCount, oddCount) * 20;

                    const gaps = calculateGaps(numbers);
                    const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                    const gapScore = Math.max(0, 50 - Math.abs(avgGap - 10) * 5);

                    return Math.round((parityScore + gapScore) / 2);
                }

                // Calcul du score statistique
                function calculateStatisticalScore(numbers) {
                    const sum = numbers.reduce((a, b) => a + b, 0);
                    const sumScore = Math.max(0, 100 - Math.abs(sum - 125) / 2);
                    return Math.round(sumScore);
                }

                // Calcul du score de cluster
                function calculateClusterScore(numbers) {
                    const uniqueClusters = new Set();
                    numbers.forEach(num => {
                        const cluster = Math.floor((num - 1) / 10);
                        uniqueClusters.add(cluster);
                    });
                    return Math.min(100, uniqueClusters.size * 20);
                }

                // Calcul du score d'équilibre
                function calculateBalanceScore(numbers) {
                    const decades = [0, 0, 0, 0, 0];
                    numbers.forEach(num => {
                        const decade = Math.floor((num - 1) / 10);
                        if (decade < 5) decades[decade]++;
                    });

                    const maxInDecade = Math.max(...decades);
                    return Math.max(0, 100 - (maxInDecade - 1) * 25);
                }

                // Calcul des écarts entre numéros
                function calculateGaps(numbers) {
                    const sorted = [...numbers].sort((a, b) => a - b);
                    const gaps = [];
                    for (let i = 1; i < sorted.length; i++) {
                        gaps.push(sorted[i] - sorted[i - 1]);
                    }
                    return gaps;
                }

                // ============================================================================
                // FONCTIONS POUR LES SIMULATIONS
                // ============================================================================

                // Lancement d'une simulation Monte Carlo
                function runSimulation() {
                    if (simSelectedMainNumbers.length !== 5 || !simSelectedChanceNumber) {
                        alert('Veuillez sélectionner 5 numéros principaux et 1 numéro chance pour la simulation.');
                        return;
                    }

                    const numSims = parseInt(document.getElementById('numSims').value);
                    const loading = document.getElementById('simLoading');
                    const metricsDiv = document.getElementById('simMetrics');
                    const resultsDiv = document.getElementById('simResults');

                    loading.classList.add('active');
                    metricsDiv.innerHTML = '';
                    resultsDiv.innerHTML = '';

                    setTimeout(() => {
                        const results = simulateDraws(simSelectedMainNumbers, simSelectedChanceNumber, numSims);

                        metricsDiv.innerHTML = `
                    <div class="stat-card">
                        <h4>Rang 1 (5+1)</h4>
                        <div class="value">${results.rank1}</div>
                        <small>${(results.rank1 / numSims * 100).toFixed(4)}%</small>
                    </div>
                    <div class="stat-card">
                        <h4>Rang 2 (5)</h4>
                        <div class="value">${results.rank2}</div>
                        <small>${(results.rank2 / numSims * 100).toFixed(4)}%</small>
                    </div>
                    <div class="stat-card">
                        <h4>Rang 3 (4+1)</h4>
                        <div class="value">${results.rank3}</div>
                        <small>${(results.rank3 / numSims * 100).toFixed(4)}%</small>
                    </div>
                    <div class="stat-card">
                        <h4>Rang 4 (4)</h4>
                        <div class="value">${results.rank4}</div>
                        <small>${(results.rank4 / numSims * 100).toFixed(4)}%</small>
                    </div>
                `;

                        updateSimulationChart(results, numSims);
                        updateSimulationDistributionChart(results, numSims);

                        let detailedResults = `
                    <h3>Résultats de la Simulation (${numSims.toLocaleString()} tirages)</h3>
                    <div class="grid-2">
                        <div class="info-box">
                            <h4> Statistiques Globales</h4>
                            <p><strong>Total des gains:</strong> ${results.totalWins} tirages</p>
                            <p><strong>Pourcentage de gains:</strong> ${(results.totalWins / numSims * 100).toFixed(2)}%</p>
                            <p><strong>Espérance mathématique:</strong> ${calculateExpectedValue(results, numSims).toFixed(6)}€ par tirage</p>
                        </div>
                        <div class="info-box">
                            <h4> Probabilités</h4>
                            <p><strong>Jackpot (5+1):</strong> ${results.rank1 > 0 ? `1 sur ${Math.round(numSims / results.rank1).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                            <p><strong>5 numéros:</strong> ${results.rank2 > 0 ? `1 sur ${Math.round(numSims / results.rank2).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                            <p><strong>4+1 numéros:</strong> ${results.rank3 > 0 ? `1 sur ${Math.round(numSims / results.rank3).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                            <p><strong>4 numéros:</strong> ${results.rank4 > 0 ? `1 sur ${Math.round(numSims / results.rank4).toLocaleString()}` : `Aucune occurrence en ${numSims.toLocaleString()} simulations`}</p>
                        </div>
                    </div>
                `;

                        const winRate = results.totalWins / numSims;
                        if (winRate > 0.1) {
                            detailedResults += `<div class="success-box">
                        <strong> Bonnes chances !</strong> Votre grille a un taux de gain supérieur à la moyenne.
                    </div>`;
                        } else if (winRate > 0.05) {
                            detailedResults += `<div class="info-box">
                        <strong> Chances raisonnables</strong> Votre grille a des caractéristiques intéressantes.
                    </div>`;
                        } else {
                            detailedResults += `<div class="info-box">
                        <strong> Difficulté élevée</strong> Les combinaisons comme la vôtre sont rares. Pensez à varier vos numéros.
                    </div>`;
                        }

                        resultsDiv.innerHTML = detailedResults;
                        loading.classList.remove('active');
                    }, 1500);
                }

                // Simulation de tirages
                function simulateDraws(userNumbers, userChance, numSims) {
                    const results = {
                        rank1: 0, rank2: 0, rank3: 0, rank4: 0,
                        rank5: 0, rank6: 0, rank7: 0, rank8: 0,
                        totalWins: 0
                    };

                    for (let i = 0; i < numSims; i++) {
                        const drawNumbers = generateUniqueRandomNumbers(5, 1, 49);
                        const drawChance = Math.floor(Math.random() * 10) + 1;

                        const matchingNumbers = userNumbers.filter(num => drawNumbers.includes(num)).length;
                        const matchingChance = userChance === drawChance;

                        if (matchingNumbers === 5 && matchingChance) results.rank1++;
                        else if (matchingNumbers === 5) results.rank2++;
                        else if (matchingNumbers === 4 && matchingChance) results.rank3++;
                        else if (matchingNumbers === 4) results.rank4++;
                        else if (matchingNumbers === 3 && matchingChance) results.rank5++;
                        else if (matchingNumbers === 3) results.rank6++;
                        else if (matchingNumbers === 2 && matchingChance) results.rank7++;
                        else if (matchingNumbers === 2) results.rank8++;

                        if (matchingNumbers >= 2) results.totalWins++;
                    }

                    return results;
                }

                // Calcul de l'espérance mathématique
                function calculateExpectedValue(results, numSims) {
                    const prizeValues = {
                        rank1: 2000000,
                        rank2: 100000,
                        rank3: 5000,
                        rank4: 500,
                        rank5: 50,
                        rank6: 20,
                        rank7: 10,
                        rank8: 5
                    };

                    let totalValue = 0;
                    totalValue += results.rank1 * prizeValues.rank1;
                    totalValue += results.rank2 * prizeValues.rank2;
                    totalValue += results.rank3 * prizeValues.rank3;
                    totalValue += results.rank4 * prizeValues.rank4;
                    totalValue += results.rank5 * prizeValues.rank5;
                    totalValue += results.rank6 * prizeValues.rank6;
                    totalValue += results.rank7 * prizeValues.rank7;
                    totalValue += results.rank8 * prizeValues.rank8;

                    return totalValue / numSims;
                }

                // ============================================================================
                // FONCTIONS POUR LES GRAPHIQUES
                // ============================================================================

                // Initialisation de tous les graphiques
                function initCharts() {
                    const chartConfigs = {
                        frequencyChart: { type: 'bar', data: { labels: [], datasets: [] } },
                        statChart: { type: 'bar', data: { labels: [], datasets: [] } },

                        clusterChart: { type: 'scatter', data: { datasets: [] } },
                        clusterDistributionChart: { type: 'doughnut', data: { labels: [], datasets: [] } },
                        evaluationChart: { type: 'radar', data: { labels: [], datasets: [] } },
                        simChart: { type: 'bar', data: { labels: [], datasets: [] } },
                        simDistributionChart: { type: 'pie', data: { labels: [], datasets: [] } }
                    };

                    for (const [canvasId, config] of Object.entries(chartConfigs)) {
                        const ctx = document.getElementById(canvasId)?.getContext('2d');
                        if (ctx) {
                            charts[canvasId] = new Chart(ctx, {
                                type: config.type,
                                data: config.data,
                                options: getChartOptions(canvasId)
                            });
                        }
                    }
                }

                // Obtention des options des graphiques
                function getChartOptions(chartId) {
                    const baseOptions = {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12,
                                        family: "'Inter', sans-serif"
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: getChartTitle(chartId),
                                color: '#ffffff',
                                font: {
                                    size: 16,
                                    family: "'Inter', sans-serif",
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                borderColor: 'rgba(255, 255, 255, 0.2)'
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    color: '#f0f0f0',
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            },
                            y: {
                                ticks: {
                                    color: '#f0f0f0',
                                    font: {
                                        size: 11,
                                        family: "'Inter', sans-serif"
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            }
                        }
                    };

                    switch (chartId) {
                        case 'clusterDistributionChart':
                            return {
                                ...baseOptions,
                                plugins: {
                                    ...baseOptions.plugins,
                                    tooltip: {
                                        ...baseOptions.plugins.tooltip,
                                        callbacks: {
                                            label: function (context) {
                                                const label = context.label || '';
                                                const value = context.raw || 0;
                                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                const percentage = Math.round((value / total) * 100);
                                                return `${label}: ${value} numéros (${percentage}%)`;
                                            }
                                        }
                                    }
                                }
                            };

                        case 'evaluationChart':
                            return {
                                ...baseOptions,
                                scales: {
                                    r: {
                                        beginAtZero: true,
                                        max: 100,
                                        ticks: {
                                            stepSize: 20,
                                            color: '#f0f0f0'
                                        },
                                        angleLines: {
                                            color: 'rgba(255, 255, 255, 0.1)'
                                        },
                                        grid: {
                                            color: 'rgba(255, 255, 255, 0.1)'
                                        },
                                        pointLabels: {
                                            color: '#ffffff'
                                        }
                                    }
                                }
                            };

                        case 'simDistributionChart':
                            return {
                                ...baseOptions,
                                plugins: {
                                    ...baseOptions.plugins,
                                    tooltip: {
                                        ...baseOptions.plugins.tooltip,
                                        callbacks: {
                                            label: function (context) {
                                                const label = context.label || '';
                                                const value = context.raw || 0;
                                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                const percentage = Math.round((value / total) * 100);
                                                return `${label}: ${value} fois (${percentage}%)`;
                                            }
                                        }
                                    }
                                }
                            };

                        default:
                            return baseOptions;
                    }
                }

                function getChartTitle(chartId) {
                    const titles = {
                        'clusterDistributionChart': 'Répartition des Numéros par Cluster',
                        'evaluationChart': 'Analyse des Scores de Votre Grille',
                        'simDistributionChart': 'Distribution des Résultats de Simulation'
                    };
                    return titles[chartId] || chartId.replace('Chart', '');
                }

                function updateEvaluationChart(scores) {
                    const labels = ['Fréquence', 'Pattern', 'Statistique', 'Cluster', 'Équilibre', 'Global'];
                    const data = [
                        scores.frequency,
                        scores.pattern,
                        scores.statistical,
                        scores.cluster,
                        scores.balance,
                        scores.overall
                    ];

                    charts.evaluationChart.data.labels = labels;
                    charts.evaluationChart.data.datasets = [{
                        label: 'Scores de Votre Grille',
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 2,
                        pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
                    }];
                    charts.evaluationChart.update();
                }

                function updateSimulationChart(results, numSims) {
                    const labels = ['Rang 1 (5+1)', 'Rang 2 (5)', 'Rang 3 (4+1)', 'Rang 4 (4)', 'Rang 5 (3+1)', 'Rang 6 (3)', 'Rang 7 (2+1)', 'Rang 8 (2)'];
                    const data = [
                        results.rank1,
                        results.rank2,
                        results.rank3,
                        results.rank4,
                        results.rank5,
                        results.rank6,
                        results.rank7,
                        results.rank8
                    ];

                    charts.simChart.data.labels = labels;
                    charts.simChart.data.datasets = [{
                        label: `Nombre de gains (${numSims.toLocaleString()} simulations)`,
                        data: data,
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }];
                    charts.simChart.update();
                }

                function updateSimulationDistributionChart(results, numSims) {
                    const labels = ['Jackpot (5+1)', '5 numéros', '4+1 numéros', '4 numéros', '3+1 numéros', '3 numéros', '2+1 numéros', '2 numéros', 'Aucun gain'];
                    const data = [
                        results.rank1,
                        results.rank2,
                        results.rank3,
                        results.rank4,
                        results.rank5,
                        results.rank6,
                        results.rank7,
                        results.rank8,
                        numSims - results.totalWins
                    ];

                    const backgroundColors = [
                        'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                        'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                        'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)'
                    ];

                    charts.simDistributionChart.data.labels = labels;
                    charts.simDistributionChart.data.datasets = [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                        borderWidth: 2
                    }];
                    charts.simDistributionChart.update();
                }

                // ============================================================================
                // FONCTIONS POUR LA GESTION DES PÉRIODES
                // ============================================================================

                function setPeriod(period) {
                    currentPeriod = period;

                    document.querySelectorAll('.period-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    event.target.classList.add('active');

                    document.getElementById('yearSelector').style.display = period === 'year' ? 'flex' : 'none';
                    document.getElementById('monthSelector').style.display = period === 'month' ? 'flex' : 'none';
                    document.getElementById('customPeriodSelector').style.display = period === 'custom' ? 'flex' : 'none';

                    if (period === 'all') {
                        applyPeriodFilter();
                    }
                }

                function applyPeriodFilter() {
                    if (!historicalData || historicalData.draws.length === 0) return;

                    let filtered = [...historicalData.draws];

                    switch (currentPeriod) {
                        case 'year':
                            const selectedYear = document.getElementById('yearSelect').value;
                            if (selectedYear) {
                                filtered = filtered.filter(draw => {
                                    const drawYear = new Date(draw.date).getFullYear().toString();
                                    return drawYear === selectedYear;
                                });
                            }
                            break;

                        case 'month':
                            const selectedMonth = document.getElementById('monthSelect').value;
                            const selectedYearMonth = document.getElementById('monthYearSelect').value;
                            if (selectedMonth && selectedYearMonth) {
                                filtered = filtered.filter(draw => {
                                    const drawDate = new Date(draw.date);
                                    const drawMonth = (drawDate.getMonth() + 1).toString().padStart(2, '0');
                                    const drawYear = drawDate.getFullYear().toString();
                                    return drawMonth === selectedMonth && drawYear === selectedYearMonth;
                                });
                            }
                            break;

                        case 'custom':
                            const startDate = document.getElementById('startDate').value;
                            const endDate = document.getElementById('endDate').value;
                            if (startDate && endDate) {
                                filtered = filtered.filter(draw => {
                                    const drawDate = new Date(draw.date);
                                    return drawDate >= new Date(startDate) && drawDate <= new Date(endDate);
                                });
                            }
                            break;
                    }

                    filteredDraws = filtered;
                    recalculateFrequencies();
                    updateStats();
                    updateDrawDates();

                    if (charts.frequencyChart) {
                        updateFrequencyChart();
                    }
                }

                function recalculateFrequencies() {
                    historicalData.frequencies = {};
                    historicalData.chanceFrequencies = {};

                    filteredDraws.forEach(draw => {
                        draw.numbers.forEach(num => {
                            historicalData.frequencies[num] = (historicalData.frequencies[num] || 0) + 1;
                        });
                        historicalData.chanceFrequencies[draw.chance] = (historicalData.chanceFrequencies[draw.chance] || 0) + 1;
                    });
                }

                function updatePeriodInfo() {
                    let periodText = '';

                    switch (currentPeriod) {
                        case 'year':
                            const selectedYear = document.getElementById('yearSelect').value;
                            periodText = selectedYear ? `Année ${selectedYear}` : 'Année (non spécifiée)';
                            break;

                        case 'month':
                            const selectedMonth = document.getElementById('monthSelect').value;
                            const selectedYearMonth = document.getElementById('monthYearSelect').value;
                            if (selectedMonth && selectedYearMonth) {
                                const monthNames = [
                                    'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
                                    'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
                                ];
                                periodText = `${monthNames[parseInt(selectedMonth) - 1]} ${selectedYearMonth}`;
                            } else {
                                periodText = 'Mois (non spécifié)';
                            }
                            break;

                        case 'custom':
                            const startDate = document.getElementById('startDate').value;
                            const endDate = document.getElementById('endDate').value;
                            if (startDate && endDate) {
                                periodText = `Du ${formatDate(startDate)} au ${formatDate(endDate)}`;
                            } else {
                                periodText = 'Période personnalisée (non spécifiée)';
                            }
                            break;

                        case 'all':
                        default:
                            periodText = 'Tous les tirages';
                            break;
                    }

                    document.getElementById('periodInfo').textContent = `Période: ${periodText}`;
                }

                function populateYearSelectors() {
                    if (!historicalData || historicalData.draws.length === 0) return;

                    const years = [...new Set(historicalData.draws.map(draw => {
                        return new Date(draw.date).getFullYear().toString();
                    }))].sort((a, b) => b - a);

                    availableYears = years;

                    const yearSelect = document.getElementById('yearSelect');
                    const monthYearSelect = document.getElementById('monthYearSelect');

                    yearSelect.innerHTML = '<option value="">Sélectionnez une année</option>';
                    monthYearSelect.innerHTML = '<option value="">Sélectionnez une année</option>';

                    years.forEach(year => {
                        yearSelect.innerHTML += `<option value="${year}">${year}</option>`;
                        monthYearSelect.innerHTML += `<option value="${year}">${year}</option>`;
                    });

                    if (years.length > 0) {
                        const minDate = historicalData.draws[historicalData.draws.length - 1].date;
                        const maxDate = historicalData.draws[0].date;

                        document.getElementById('startDate').min = minDate;
                        document.getElementById('startDate').max = maxDate;
                        document.getElementById('endDate').min = minDate;
                        document.getElementById('endDate').max = maxDate;

                        document.getElementById('startDate').value = minDate;
                        document.getElementById('endDate').value = maxDate;
                        document.getElementById('yearSelect').value = years[0];
                        document.getElementById('monthYearSelect').value = years[0];
                    }
                }

                // ============================================================================
                // FONCTIONS POUR LA GESTION DE LA PÉRIODE ML
                // ============================================================================

                function setMLPeriod(period) {
                    mlCurrentPeriod = period;

                    // Mettre à jour les boutons actifs
                    document.querySelectorAll('#ml .period-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    event.target.classList.add('active');

                    // Afficher/masquer les sélecteurs appropriés
                    document.getElementById('mlYearSelector').style.display = period === 'year' ? 'flex' : 'none';
                    document.getElementById('mlMonthSelector').style.display = period === 'month' ? 'flex' : 'none';
                    document.getElementById('mlCustomPeriodSelector').style.display = period === 'custom' ? 'flex' : 'none';

                    if (period === 'all') {
                        applyMLPeriodFilter();
                    }
                }

                function applyMLPeriodFilter() {
                    if (!historicalData || historicalData.draws.length === 0) {
                        console.warn(' Aucune donnée historique disponible pour le filtrage ML');
                        mlFilteredDraws = [];
                        return;
                    }

                    let filtered = [...historicalData.draws];

                    switch (mlCurrentPeriod) {
                        case 'year':
                            const selectedYear = document.getElementById('mlYearSelect').value;
                            if (selectedYear) {
                                filtered = filtered.filter(draw => {
                                    const drawDate = parseDrawDate(draw.date);
                                    return drawDate.getFullYear().toString() === selectedYear;
                                });
                            }
                            break;

                        case 'month':
                            const selectedMonth = document.getElementById('mlMonthSelect').value;
                            const selectedYearMonth = document.getElementById('mlMonthYearSelect').value;
                            if (selectedMonth && selectedYearMonth) {
                                filtered = filtered.filter(draw => {
                                    const drawDate = parseDrawDate(draw.date);
                                    const drawMonth = (drawDate.getMonth() + 1).toString().padStart(2, '0');
                                    const drawYear = drawDate.getFullYear().toString();
                                    return drawMonth === selectedMonth && drawYear === selectedYearMonth;
                                });
                            }
                            break;

                        case 'custom':
                            const startDate = document.getElementById('mlStartDate').value;
                            const endDate = document.getElementById('mlEndDate').value;
                            if (startDate && endDate) {
                                const startDateObj = new Date(startDate);
                                const endDateObj = new Date(endDate);

                                filtered = filtered.filter(draw => {
                                    const drawDate = parseDrawDate(draw.date);
                                    return drawDate >= startDateObj && drawDate <= endDateObj;
                                });
                            }
                            break;

                        case 'all':
                        default:
                            // 🎯 PÉRIODE PAR DÉFAUT : 1 AN À PARTIR DU DERNIER TIRAGE
                            if (historicalData.draws.length > 0) {
                                // 1. Trouver le dernier tirage (le plus récent) de manière robuste
                                const drawsWithDates = historicalData.draws.map(draw => ({
                                    draw: draw,
                                    date: parseDrawDate(draw.date)
                                }));

                                // Trier par date décroissante pour trouver le plus récent
                                drawsWithDates.sort((a, b) => b.date - a.date);

                                const lastDrawDate = drawsWithDates[0].date;

                                // 2. Calculer la date d'il y a 1 an
                                const oneYearAgo = new Date(lastDrawDate);
                                oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);

                                // 3. Filtrer les tirages des 12 derniers mois
                                filtered = filtered.filter(draw => {
                                    const drawDate = parseDrawDate(draw.date);
                                    return drawDate >= oneYearAgo && drawDate <= lastDrawDate;
                                });

                                console.log(` Période ML par défaut : 1 an`);
                                console.log(`   Du ${oneYearAgo.toLocaleDateString('fr-FR')} au ${lastDrawDate.toLocaleDateString('fr-FR')}`);
                                console.log(` Tirages sélectionnés : ${filtered.length}/${historicalData.draws.length}`);
                            }
                            break;
                    }

                    mlFilteredDraws = filtered;

                    //  SÉCURITÉ : Si aucun tirage sélectionné, utiliser les 100 derniers
                    if (mlFilteredDraws.length === 0) {
                        console.warn(' Aucun tirage après filtrage, utilisation des 100 derniers tirages');
                        mlFilteredDraws = [...historicalData.draws].slice(0, 100);
                    }

                    console.log(` Période ML finale : ${mlFilteredDraws.length} tirages disponibles pour l'entraînement`);
                }

                function populateMLYearSelectors() {
                    if (!historicalData || historicalData.draws.length === 0) return;

                    const years = [...new Set(historicalData.draws.map(draw => {
                        return new Date(draw.date).getFullYear().toString();
                    }))].sort((a, b) => b - a);

                    const mlYearSelect = document.getElementById('mlYearSelect');
                    const mlMonthYearSelect = document.getElementById('mlMonthYearSelect');

                    mlYearSelect.innerHTML = '<option value="">Sélectionnez une année</option>';
                    mlMonthYearSelect.innerHTML = '<option value="">Sélectionnez une année</option>';

                    years.forEach(year => {
                        mlYearSelect.innerHTML += `<option value="${year}">${year}</option>`;
                        mlMonthYearSelect.innerHTML += `<option value="${year}">${year}</option>`;
                    });

                    if (years.length > 0) {
                        const minDate = historicalData.draws[historicalData.draws.length - 1].date;
                        const maxDate = historicalData.draws[0].date;

                        document.getElementById('mlStartDate').min = minDate;
                        document.getElementById('mlStartDate').max = maxDate;
                        document.getElementById('mlEndDate').min = minDate;
                        document.getElementById('mlEndDate').max = maxDate;

                        document.getElementById('mlStartDate').value = minDate;
                        document.getElementById('mlEndDate').value = maxDate;
                    }
                }

                function displayLatestDraw() {
                    if (!filteredDraws || filteredDraws.length === 0) return;

                    const latestDraw = filteredDraws[0];
                    document.getElementById('latestDrawDate').textContent = `Dernier Tirage :  ${formatDate(latestDraw.date)}`;

                    const numbersContainer = document.getElementById('latestDrawNumbers');
                    numbersContainer.innerHTML = '';

                    numbersContainer.style.display = 'flex';
                    numbersContainer.style.gap = '12px';
                    numbersContainer.style.flexWrap = 'wrap';
                    numbersContainer.style.justifyContent = 'flex-start';
                    numbersContainer.style.alignItems = 'center';
                    numbersContainer.style.marginTop = '15px';
                    numbersContainer.style.padding = '0px';
                    numbersContainer.style.backgroundColor = 'var(--secondary-color)';
                    numbersContainer.style.borderRadius = '8px';
                    numbersContainer.style.border = '0px solid var(--border-color)';

                    latestDraw.numbers.forEach(num => {
                        const ball = document.createElement('div');
                        ball.className = 'number-ball-select';
                        ball.textContent = num;
                        ball.style.background = getBallColor(num);
                        ball.style.cursor = 'default';
                        numbersContainer.appendChild(ball);
                    });

                    const chanceBall = document.createElement('div');
                    chanceBall.className = 'number-ball-chance-select';
                    chanceBall.textContent = latestDraw.chance;
                    chanceBall.style.background = getChanceBallColor(latestDraw.chance);
                    chanceBall.style.cursor = 'default';
                    chanceBall.style.borderRadius = '50%';
                    chanceBall.style.marginLeft = '5px';
                    numbersContainer.appendChild(chanceBall);

                    document.getElementById('latestDrawContainer').style.display = 'block';
                }

                function updateDrawDates() {
                    if (filteredDraws.length > 0) {
                        const firstDraw = filteredDraws[filteredDraws.length - 1];
                        const lastDraw = filteredDraws[0];

                        document.getElementById('firstDrawDate').textContent = formatDate(firstDraw.date);
                        document.getElementById('lastDrawDate').textContent = formatDate(lastDraw.date);

                        document.getElementById('dateRange').textContent =
                            `${formatDate(firstDraw.date)} - ${formatDate(lastDraw.date)}`;
                    }
                }

                // ============================================================================
                // FONCTIONS MATHÉMATIQUES AVANCÉES
                // ============================================================================

                // Fonction de répartition normale standard (approximation)
                function normalCDF(x) {
                    const t = 1 / (1 + 0.2316419 * Math.abs(x));
                    const d = 0.3989423 * Math.exp(-x * x / 2);
                    const probability = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
                    return x > 0 ? 1 - probability : probability;
                }

                // Calcul approximatif de la p-value pour Chi-carré
                function calculatePValue(chiSquare, df) {
                    const z = Math.sqrt(2 * chiSquare) - Math.sqrt(2 * df - 1);
                    const pValue = 1 - normalCDF(z);
                    return pValue;
                }

                // Test du Chi-carré pour vérifier l'uniformité
                function chiSquareTest(frequencies) {
                    const values = Object.values(frequencies);
                    const totalDraws = values.reduce((a, b) => a + b, 0);
                    const expectedFreq = totalDraws / 49;

                    let chiSquare = 0;
                    for (let i = 1; i <= 49; i++) {
                        const observed = frequencies[i] || 0;
                        chiSquare += Math.pow(observed - expectedFreq, 2) / expectedFreq;
                    }

                    const degreesOfFreedom = 48;
                    const criticalValue = 65.17;
                    const pValue = calculatePValue(chiSquare, degreesOfFreedom);

                    return {
                        chiSquare: chiSquare.toFixed(2),
                        isUniform: chiSquare < criticalValue,
                        pValue: pValue.toFixed(4),
                        interpretation: chiSquare < criticalValue
                            ? "Distribution uniforme (pas de biais détecté)"
                            : "Distribution non-uniforme (biais possible)"
                    };
                }

                // Probalilité basée sur la distribution de Poisson
                function poissonPrediction(frequencies, numPredictions = 5) {
                    const predictions = [];
                    const lambda = {};

                    const totalDraws = Object.values(frequencies).reduce((a, b) => a + b, 0);
                    for (let i = 1; i <= 49; i++) {
                        lambda[i] = (frequencies[i] || 0) / totalDraws;
                    }

                    for (let pred = 0; pred < numPredictions; pred++) {
                        const weights = [];
                        for (let i = 1; i <= 49; i++) {
                            const weight = lambda[i] * Math.exp(-lambda[i]);
                            weights.push({
                                number: i,
                                weight: weight > 0 ? weight : 0.0001
                            });
                        }

                        const selected = weightedRandomSelection(weights, 5);
                        predictions.push(selected);
                    }

                    return predictions;
                }

                // Probalilité  basée sur la loi de Zipf
                function zipfPrediction(frequencies, numPredictions = 5) {
                    const predictions = [];

                    const sortedNumbers = Object.entries(frequencies)
                        .filter(([num]) => num >= 1 && num <= 49)
                        .sort((a, b) => b[1] - a[1])
                        .map((entry, index) => ({
                            number: parseInt(entry[0]),
                            rank: index + 1,
                            frequency: entry[1]
                        }));

                    const weights = sortedNumbers.map(item => ({
                        number: item.number,
                        weight: 1 / Math.pow(item.rank, 1.0)
                    }));

                    const totalWeight = weights.reduce((sum, item) => sum + item.weight, 0);
                    weights.forEach(item => item.weight = item.weight / totalWeight);

                    for (let pred = 0; pred < numPredictions; pred++) {
                        const selected = weightedRandomSelection(weights, 5);
                        predictions.push(selected);
                    }

                    return predictions;
                }

                // Test T de Student - Analyse des écarts à la moyenne
                function studentTestPrediction(frequencies, numPredictions = 5) {
                    const predictions = [];
                    const values = Object.values(frequencies);
                    const n = values.length;

                    const mean = values.reduce((a, b) => a + b, 0) / n;
                    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (n - 1);
                    const stdDev = Math.sqrt(variance);

                    const tScores = [];
                    for (let i = 1; i <= 49; i++) {
                        const observed = frequencies[i] || 0;
                        const tScore = Math.abs((observed - mean) / (stdDev / Math.sqrt(n)));
                        tScores.push({
                            number: i,
                            tScore: tScore,
                            deviation: observed - mean
                        });
                    }

                    tScores.sort((a, b) => b.tScore - a.tScore);

                    for (let pred = 0; pred < numPredictions; pred++) {
                        const selected = [];

                        const overRepresented = tScores.filter(t => t.deviation > 0).slice(0, 10);
                        for (let i = 0; i < 3; i++) {
                            const idx = Math.floor(Math.random() * Math.min(overRepresented.length, 10));
                            if (overRepresented[idx] && !selected.includes(overRepresented[idx].number)) {
                                selected.push(overRepresented[idx].number);
                            }
                        }

                        const underRepresented = tScores.filter(t => t.deviation < 0).slice(0, 10);
                        while (selected.length < 5) {
                            const idx = Math.floor(Math.random() * Math.min(underRepresented.length, 10));
                            if (underRepresented[idx] && !selected.includes(underRepresented[idx].number)) {
                                selected.push(underRepresented[idx].number);
                            }
                        }

                        predictions.push(selected.sort((a, b) => a - b));
                    }

                    return {
                        predictions: predictions,
                        stats: {
                            mean: mean.toFixed(2),
                            stdDev: stdDev.toFixed(2),
                            mostSignificant: tScores.slice(0, 5).map(t => `#${t.number} (t=${t.tScore.toFixed(2)})`)
                        }
                    };
                }

                // Distribution de Dirichlet - Répartition par dizaines
                function dirichletPrediction(frequencies, numPredictions = 5) {
                    const predictions = [];

                    const decades = {
                        '1-10': [],
                        '11-20': [],
                        '21-30': [],
                        '31-40': [],
                        '41-49': []
                    };

                    for (let i = 1; i <= 49; i++) {
                        const freq = frequencies[i] || 0;
                        if (i <= 10) decades['1-10'].push({ num: i, freq: freq });
                        else if (i <= 20) decades['11-20'].push({ num: i, freq: freq });
                        else if (i <= 30) decades['21-30'].push({ num: i, freq: freq });
                        else if (i <= 40) decades['31-40'].push({ num: i, freq: freq });
                        else decades['41-49'].push({ num: i, freq: freq });
                    }

                    const alphas = {};
                    for (const [decade, nums] of Object.entries(decades)) {
                        const totalFreq = nums.reduce((sum, n) => sum + n.freq, 0);
                        alphas[decade] = totalFreq + 1;
                    }

                    const totalAlpha = Object.values(alphas).reduce((a, b) => a + b, 0);
                    for (const decade in alphas) {
                        alphas[decade] = alphas[decade] / totalAlpha;
                    }

                    for (let pred = 0; pred < numPredictions; pred++) {
                        const selected = [];

                        const decadeNames = Object.keys(decades);
                        const numPerDecade = [0, 0, 0, 0, 0];

                        for (let i = 0; i < 5; i++) {
                            let random = Math.random();
                            let cumulative = 0;

                            for (let d = 0; d < decadeNames.length; d++) {
                                cumulative += alphas[decadeNames[d]];
                                if (random <= cumulative) {
                                    numPerDecade[d]++;
                                    break;
                                }
                            }
                        }

                        for (let d = 0; d < decadeNames.length; d++) {
                            const decadeName = decadeNames[d];
                            const numsInDecade = decades[decadeName];
                            const count = numPerDecade[d];

                            for (let c = 0; c < count && selected.length < 5; c++) {
                                const weights = numsInDecade
                                    .filter(n => !selected.includes(n.num))
                                    .map(n => ({ number: n.num, weight: n.freq + 1 }));

                                if (weights.length > 0) {
                                    const selectedNums = weightedRandomSelection(weights, 1);
                                    selected.push(...selectedNums);
                                }
                            }
                        }

                        while (selected.length < 5) {
                            const random = Math.floor(Math.random() * 49) + 1;
                            if (!selected.includes(random)) {
                                selected.push(random);
                            }
                        }

                        predictions.push(selected.sort((a, b) => a - b));
                    }

                    return {
                        predictions: predictions,
                        alphas: alphas,
                        interpretation: Object.entries(alphas)
                            .sort((a, b) => b[1] - a[1])
                            .map(([decade, weight]) => `${decade}: ${(weight * 100).toFixed(1)}%`)
                    };
                }

                // ============================================================================
                // FONCTIONS CORRIGÉES AJOUTÉES
                // ============================================================================

                function weightedRandomSelection(weights, count) {
                    const selected = [];
                    const available = [...weights];

                    for (let i = 0; i < count; i++) {
                        const totalWeight = available.reduce((sum, item) =>
                            sum + Math.max(0, item.weight || 0), 0);

                        if (totalWeight === 0) {
                            const randomIndex = Math.floor(Math.random() * available.length);
                            selected.push(available[randomIndex].number);
                            available.splice(randomIndex, 1);
                            continue;
                        }

                        let random = Math.random() * totalWeight;
                        for (let j = 0; j < available.length; j++) {
                            random -= Math.max(0, available[j].weight || 0);
                            if (random <= 0) {
                                selected.push(available[j].number);
                                available.splice(j, 1);
                                break;
                            }
                        }
                    }
                    return selected.sort((a, b) => a - b);
                }
                // DISTRIBUTION BINOMIALE CORRIGÉE - Modélisation pairs/impairs
                function binomialPrediction(frequencies, numPredictions = 5) {
                    const predictions = [];

                    // 1. Calcul des probabilités empiriques pairs/impairs
                    let totalEven = 0, totalOdd = 0;
                    for (let i = 1; i <= 49; i++) {
                        const freq = frequencies[i] || 0;
                        if (i % 2 === 0) totalEven += freq;
                        else totalOdd += freq;
                    }

                    const total = totalEven + totalOdd;
                    const pEven = totalEven / total; // Probabilité empirique d'un pair
                    const pOdd = totalOdd / total;   // Probabilité empirique d'un impair

                    console.log(`Binomial - P(pair)=${pEven.toFixed(3)}, P(impair)=${pOdd.toFixed(3)}`);

                    // 2. Séparation des numéros pairs et impairs avec leurs fréquences
                    const evenNumbers = [];
                    const oddNumbers = [];

                    for (let i = 1; i <= 49; i++) {
                        const freq = frequencies[i] || 0;
                        if (i % 2 === 0) {
                            evenNumbers.push({ number: i, weight: freq + 1 }); // +1 pour éviter poids nul
                        } else {
                            oddNumbers.push({ number: i, weight: freq + 1 });
                        }
                    }

                    // 3. Génération des prédictions selon la loi binomiale
                    for (let pred = 0; pred < numPredictions; pred++) {
                        const selected = [];

                        // Simulation binomiale : combien de pairs parmi 5 numéros ?
                        // Loi binomiale B(n=5, p=pEven)
                        let numEven = 0;
                        for (let i = 0; i < 5; i++) {
                            if (Math.random() < pEven) numEven++;
                        }
                        const numOdd = 5 - numEven;

                        console.log(`Prédiction ${pred + 1}: ${numEven} pairs, ${numOdd} impairs`);

                        // Sélection pondérée des pairs
                        if (numEven > 0 && evenNumbers.length > 0) {
                            const selectedEven = weightedRandomSelection(evenNumbers, Math.min(numEven, evenNumbers.length));
                            selected.push(...selectedEven);
                        }

                        // Sélection pondérée des impairs
                        if (numOdd > 0 && oddNumbers.length > 0) {
                            // Filtrer les impairs déjà sélectionnés
                            const availableOdd = oddNumbers.filter(n => !selected.includes(n.number));
                            const selectedOdd = weightedRandomSelection(availableOdd, Math.min(numOdd, availableOdd.length));
                            selected.push(...selectedOdd);
                        }

                        // Compléter si nécessaire (cas limites)
                        while (selected.length < 5) {
                            const random = Math.floor(Math.random() * 49) + 1;
                            if (!selected.includes(random)) {
                                selected.push(random);
                            }
                        }

                        predictions.push(selected.sort((a, b) => a - b));
                    }

                    return {
                        predictions: predictions,
                        stats: {
                            pEven: (pEven * 100).toFixed(1) + '%',
                            pOdd: (pOdd * 100).toFixed(1) + '%',
                            totalEven: totalEven,
                            totalOdd: totalOdd,
                            expectedEvenPerDraw: (5 * pEven).toFixed(1),
                            expectedOddPerDraw: (5 * pOdd).toFixed(1)
                        }
                    };
                }

                // DISTRIBUTION GAMMA CORRIGÉE - Modélisation temps d'attente
                function gammaPrediction(frequencies, numPredictions = 5) {
                    const predictions = [];

                    // 1. Calcul du temps moyen d'attente pour chaque numéro
                    const waitTimes = {};
                    const totalDraws = Object.values(frequencies).reduce((a, b) => a + b, 0) / 5; // Nombre total de tirages

                    for (let i = 1; i <= 49; i++) {
                        const freq = frequencies[i] || 0;
                        // Temps moyen entre apparitions (plus c'est fréquent, plus c'est court)
                        waitTimes[i] = freq > 0 ? totalDraws / freq : totalDraws * 2; // Pénalité pour numéros jamais tirés
                    }

                    // 2. Modélisation Gamma : PDF(x) = x^(k-1) * e^(-x/θ) / (θ^k * Γ(k))
                    const gammaScores = [];
                    for (let i = 1; i <= 49; i++) {
                        const freq = frequencies[i] || 0;
                        const avgWait = waitTimes[i];

                        // Paramètres Gamma approximatifs
                        const k = Math.max(1, freq);        // Shape parameter (nombre d'occurrences)
                        const theta = avgWait / k;          // Scale parameter

                        // Fonction de densité Gamma simplifiée (sans la fonction Gamma complète)
                        // On utilise une approximation pour le calcul du score
                        const gammaScore = Math.pow(avgWait, k - 1) * Math.exp(-avgWait / theta) / Math.pow(theta, k);

                        gammaScores.push({
                            number: i,
                            score: gammaScore,
                            avgWait: avgWait.toFixed(1),
                            frequency: freq,
                            params: { k: k, theta: theta.toFixed(2) }
                        });
                    }

                    // 3. Tri par score Gamma (les scores élevés = bons candidats)
                    gammaScores.sort((a, b) => b.score - a.score);

                    console.log("Top 5 Gamma scores:", gammaScores.slice(0, 5).map(s =>
                        `#${s.number} (score:${s.score.toFixed(6)}, attente:${s.avgWait})`
                    ));

                    // 4. Normalisation des scores pour pondération
                    const maxScore = gammaScores[0].score;
                    const weights = gammaScores.map(item => ({
                        number: item.number,
                        weight: (item.score / maxScore) * 100 // Normalisation 0-100
                    }));

                    // 5. Génération des prédictions
                    for (let pred = 0; pred < numPredictions; pred++) {
                        const selected = weightedRandomSelection(weights, 5);
                        predictions.push(selected);
                    }

                    return {
                        predictions: predictions,
                        stats: {
                            avgWaitTime: (Object.values(waitTimes).reduce((a, b) => a + b, 0) / 49).toFixed(1) + " tirages",
                            totalDraws: totalDraws.toFixed(0),
                            topNumbers: gammaScores.slice(0, 5).map(s =>
                                `#${s.number} (attente: ${s.avgWait} tirages, freq: ${s.frequency})`
                            )
                        }
                    };
                }

                // ============================================================================
                // FONCTIONS POUR LES AUTRES ONGLETS
                // ============================================================================

                function showTab(tabId) {
                    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));

                    document.getElementById(tabId).classList.add('active');
                    document.querySelector(`.nav-item[onclick="showTab('${tabId}')"]`).classList.add('active');

                    window.scrollTo(0, 0);

                    switch (tabId) {
                        case 'frequencies':
                            updateFrequencyChart();
                            break;
                        case 'predictions':
                            // Génération de probabilités : ne pas lancer automatiquement à l'affichage.
                            break;

                        case 'ml':
                            // Entraînement ML : ne pas lancer automatiquement à l'affichage.
                            break;

                        case 'clusters':
                            performClustering();
                            break;
                        case 'statistics':
                            performStatAnalysis();
                            break;

                        case 'index':
                            populateFullIndex();  // ⬅️ AJOUTEZ CETTE LIGNE
                            break;

                        case 'matrice':
                            initMatriceTab();
                            break;
                        default:
                            console.log("Onglet " + tabId + " affiché.");
                    }
                }

                function updateFrequencyChart() {
                    const type = document.getElementById('freqType').value;

                    if (type === 'main') {
                        const labels = Array.from({ length: 49 }, (_, i) => i + 1);
                        const data = labels.map(num => historicalData.frequencies[num] || 0);

                        charts.frequencyChart.data.labels = labels;
                        charts.frequencyChart.data.datasets = [{
                            label: 'Fréquence d\'apparition',
                            data: data,
                            backgroundColor: 'rgba(102, 126, 234, 0.7)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 1
                        }];

                        charts.frequencyChart.options.plugins.title.text = 'Fréquence des Numéros Principaux (1-49)';
                    } else {
                        const labels = Array.from({ length: 10 }, (_, i) => i + 1);
                        const data = labels.map(num => historicalData.chanceFrequencies[num] || 0);

                        charts.frequencyChart.data.labels = labels;
                        charts.frequencyChart.data.datasets = [{
                            label: 'Fréquence d\'apparition',
                            data: data,
                            backgroundColor: 'rgba(231, 76, 60, 0.7)',
                            borderColor: 'rgba(231, 76, 60, 1)',
                            borderWidth: 1
                        }];

                        charts.frequencyChart.options.plugins.title.text = 'Fréquence des Numéros Chance (1-10)';
                    }

                    charts.frequencyChart.update();
                    updateFrequencyResults(type);
                }

                function updateFrequencyResults(type) {
                    let results = '';

                    if (type === 'main') {
                        const sortedFreq = Object.entries(historicalData.frequencies)
                            .sort((a, b) => b[1] - a[1]);

                        results = '<h3>Top 10 des numéros les plus fréquents</h3><div class="selected-numbers-display">';
                        sortedFreq.slice(0, 10).forEach(([num, freq]) => {
                            results += `<div class="number-ball" style="background: ${getBallColor(parseInt(num))}">${num}</div>`;
                        });
                        results += '</div>';

                        results += '<h3>Top 10 des numéros les moins fréquents</h3><div class="selected-numbers-display">';
                        sortedFreq.slice(-10).reverse().forEach(([num, freq]) => {
                            results += `<div class="number-ball" style="background: ${getBallColor(parseInt(num))}">${num}</div>`;
                        });
                        results += '</div>';
                    } else {
                        const sortedFreq = Object.entries(historicalData.chanceFrequencies)
                            .sort((a, b) => b[1] - a[1]);

                        results = '<h3>Numéros chance par fréquence</h3><div class="selected-numbers-display">';
                        sortedFreq.forEach(([num, freq]) => {
                            results += `<div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(parseInt(num))}">${num}</div>`;
                        });
                        results += '</div>';
                    }

                    document.getElementById('freqResults').innerHTML = results;
                }

                function performClustering() {
                    const numClusters = parseInt(document.getElementById('numClusters').value);
                    const resultsDiv = document.getElementById('clusterResults');

                    const clusters = {};
                    const clusterSizes = {};

                    for (let i = 0; i < numClusters; i++) {
                        const clusterSize = Math.floor(Math.random() * 10) + 5;
                        clusters[i] = generateUniqueRandomNumbers(clusterSize, 1, 49);
                        clusterSizes[i] = clusterSize;
                    }

                    updateClusterChart(clusters);
                    updateClusterDistributionChart(clusterSizes);

                    let results = `<p><h3>Résultats du Clustering K-Means (${numClusters} clusters)</h3><p>`;

                    for (const [clusterId, numbers] of Object.entries(clusters)) {
                        results += `<h4>Cluster ${parseInt(clusterId) + 1} (${numbers.length} numéros)</h4>`;
                        results += `<div class="selected-numbers-display">`;
                        numbers.forEach(num => {
                            results += `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`;
                        });
                        results += `</div>`;

                        const sum = numbers.reduce((a, b) => a + b, 0);
                        const avg = sum / numbers.length;
                        const evenCount = numbers.filter(n => n % 2 === 0).length;
                        const oddCount = numbers.filter(n => n % 2 !== 0).length;

                        results += `<div class="info-box" style="margin: 10px 0; padding: 10px;">
                    <p><strong>Statistiques du cluster :</strong><br><p>
                    • Somme moyenne: ${avg.toFixed(1)}<br>
                    • Répartition: ${evenCount} pairs / ${oddCount} impairs<br>
                    • Étendue: ${Math.min(...numbers)} - ${Math.max(...numbers)}
                </div>`;
                    }

                    resultsDiv.innerHTML = results;
                }

                function updateClusterChart(clusters) {
                    const datasets = [];
                    const clusterColors = [
                        'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                        'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                        'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)'
                    ];

                    Object.entries(clusters).forEach(([clusterId, numbers], index) => {
                        const data = numbers.map(num => ({
                            x: num + Math.random() * 10 - 5,
                            y: (index + 1) * 20 + Math.random() * 15
                        }));

                        datasets.push({
                            label: `Cluster ${parseInt(clusterId) + 1}`,
                            data: data,
                            backgroundColor: clusterColors[index % clusterColors.length],
                            borderColor: clusterColors[index % clusterColors.length].replace('0.7', '1'),
                            borderWidth: 1
                        });
                    });

                    charts.clusterChart.data.datasets = datasets;
                    charts.clusterChart.update();
                }

                function updateClusterDistributionChart(clusterSizes) {
                    const labels = Object.keys(clusterSizes).map(id => `Cluster ${parseInt(id) + 1}`);
                    const data = Object.values(clusterSizes);
                    const backgroundColors = [
                        'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                        'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                        'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(40, 159, 64, 0.7)'
                    ];

                    charts.clusterDistributionChart.data.labels = labels;
                    charts.clusterDistributionChart.data.datasets = [{
                        data: data,
                        backgroundColor: backgroundColors.slice(0, labels.length),
                        borderColor: backgroundColors.slice(0, labels.length).map(color => color.replace('0.7', '1')),
                        borderWidth: 2
                    }];
                    charts.clusterDistributionChart.update();
                }

                function togglePredictionOptions() {
                    const model = document.getElementById('predModel').value;
                    const standardOptions = document.getElementById('standardOptions');
                    const testOptions = document.getElementById('testOptions');
                    const monteCarloOptions = document.getElementById('monteCarloOptions');

                    standardOptions.style.display = 'none';
                    testOptions.style.display = 'none';
                    monteCarloOptions.style.display = 'none';

                    if (model === 'montecarlo') {
                        monteCarloOptions.style.display = 'block';
                    } else if (['student', 'chisquare', 'gamma'].includes(model)) {
                        testOptions.style.display = 'block';
                    } else {
                        standardOptions.style.display = 'block';
                    }

                    showPredictionExplanation(model);
                }

                function showPredictionExplanation(model) {
                    const explanations = {
                        'poisson': `<h4> Distribution de Poisson</h4></p>Modélise la probabilité d'apparition des numéros basée sur leur fréquence historique.</p>`,
                        'binomiale': `<h4> Distribution Binomiale</h4></p>Analyse la distribution pairs/impairs et les patterns de fréquence.</p>`,
                        'zipf': `<h4> Loi de Zipf</h4></p>Utilise la distribution de puissance pour identifier les numéros structurellement fréquents.</p>`,
                        'dirichlet': `<h4> Distribution de Dirichlet</h4></p>Modélise la répartition des numéros par dizaines.</p>`,
                        'hybrid': `<h4> Modèle Hybride</h4></p>Combine plusieurs approches probabilistes pour une Probalilité plus robuste.</p>`,
                        'student': `<h4> Test T de Student</h4></p>Teste la significativité des écarts par rapport aux valeurs théoriques.</p>`,
                        'chisquare': `<h4> Test du Chi-carré (χ²)</h4></p>Vérifie l'uniformité de la distribution des numéros.</p>`,
                        'gamma': `<h4> Distribution Gamma</h4></p>Modélise les temps d'attente entre apparitions des numéros.</p>`,
                        'montecarlo': `<h4> Simulation Monte-Carlo</h4></p>Simule des milliers de tirages pour identifier les combinaisons probables.`
                    };

                    const container = document.getElementById('predictionExplanations');
                    container.innerHTML = explanations[model] || '<p>Explication non disponible.</p>';
                }

                function showMLExplanation() {
                    const model = document.getElementById('mlModel').value;
                    const explanations = {
                        'rf': `<h4> Random Forest Réel</h4><p>Forêt d'arbres de décision entraînée sur l'historique complet avec TensorFlow.js</p>`,
                        'gb': `<h4> Gradient Boosting Réel</h4><p>Algorithme de boosting séquentiel optimisé pour la probalilité de séries</p>`,
                        'logistic': `<h4> Régression Logistique Réelle</h4><p>Classification multi-label avec régularisation L2</p>`,
                        'ensemble': `<h4> Ensemble Stacking Réel</h4><p>Combinaison de multiples modèles avec méta-apprentissage</p>`,
                        'lstm': `<h4> LSTM Réel</h4><p>Réseau neuronal récurrent pour l'analyse des séquences temporelles</p>`
                    };

                    document.getElementById('mlExplanationContent').innerHTML = explanations[model] ||
                        '<p>Sélectionnez un algorithme pour voir son fonctionnement détaillé...</p>';
                }


                // ============================================================================
                // FONCTIONS POUR LE BARREGRAPHE HORIZONTAL
                // ============================================================================

                // Fonction pour démarrer la barre de progression des prédictions
                function startPredictionProgress() {
                    // Récupérer les éléments DOM de la barre de progression
                    const progressBar = document.getElementById('predProgressBar');
                    const progressText = document.getElementById('predProgressText');
                    const progressStep = document.getElementById('predProgressStep');
                    const progressPercent = document.getElementById('predProgressPercent');
                    const progressTime = document.getElementById('predProgressTime');

                    // Définir les étapes de progression pour les prédictions
                    const steps = [{
                        percent: 25,  // Pourcentage d'avancement
                        text: "Analyse des distributions statistiques...",  // Texte descriptif
                        step: "Étape 1/4"  // Indicateur d'étape
                    }, {
                        percent: 50,
                        text: "Calcul des probabilités conditionnelles...",
                        step: "Étape 2/4"
                    }, {
                        percent: 75,
                        text: "Génération des combinaisons optimales...",
                        step: "Étape 3/4"
                    }, {
                        percent: 100,
                        text: "Finalisation des résultats...",
                        step: "Étape 4/4"
                    }];

                    // Lancer l'animation de progression avec un temps total de 2 secondes
                    animateProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, 2000);
                }

                // Fonction pour démarrer la barre de progression du Machine Learning
                function startMLProgress() {
                    // Récupérer les éléments DOM de la barre de progression ML
                    const progressBar = document.getElementById('mlProgressBar');
                    const progressText = document.getElementById('mlProgressText');
                    const progressStep = document.getElementById('mlProgressStep');
                    const progressPercent = document.getElementById('mlProgressPercent');
                    const progressTime = document.getElementById('mlProgressTime');

                    // Définir les étapes de progression pour le ML (plus d'étapes que les prédictions)
                    const steps = [{
                        percent: 20,
                        text: "Chargement et préparation des données...",
                        step: "Étape 1/5"
                    }, {
                        percent: 40,
                        text: "Entraînement du modèle sélectionné...",
                        step: "Étape 2/5"
                    }, {
                        percent: 60,
                        text: "Validation croisée des performances...",
                        step: "Étape 3/5"
                    }, {
                        percent: 80,
                        text: "Optimisation des hyperparamètres...",
                        step: "Étape 4/5"
                    }, {
                        percent: 100,
                        text: "Génération des prédictions finales...",
                        step: "Étape 5/5"
                    }];

                    // Lancer l'animation de progression avec un temps total de 2.5 secondes
                    animateProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, 2500);
                }

                // Fonction générique pour animer une barre de progression
                function animateProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, totalTime) {
                    let currentStep = 0;  // Étape actuelle
                    const startTime = Date.now();  // Temps de début pour le calcul du temps restant

                    // Initialiser la barre de progression à 0%
                    progressBar.style.width = '0%';
                    progressPercent.textContent = '0%';

                    // Fonction récursive pour mettre à jour la progression
                    function updateProgress() {
                        // Vérifier s'il reste des étapes à traiter
                        if (currentStep < steps.length) {
                            const step = steps[currentStep];  // Étape courante
                            const progress = step.percent;    // Pourcentage cible

                            // Mettre à jour l'interface utilisateur
                            progressBar.style.width = progress + '%';
                            progressText.textContent = step.text;
                            progressStep.textContent = step.step;
                            progressPercent.textContent = progress + '%';

                            // Calculer et afficher le temps estimé restant
                            const elapsed = Date.now() - startTime;  // Temps écoulé en millisecondes
                            const estimatedTotal = (elapsed / progress) * 100;  // Temps total estimé
                            const remaining = Math.max(0, (estimatedTotal - elapsed) / 1000);  // Temps restant en secondes
                            progressTime.textContent = `Temps estimé: ${remaining.toFixed(1)}s`;

                            currentStep++;  // Passer à l'étape suivante

                            // Calculer le délai avant la prochaine mise à jour
                            const nextDelay = currentStep < steps.length ?
                                (steps[currentStep].percent - step.percent) * totalTime / 100 : 0;

                            // Planifier la prochaine mise à jour
                            setTimeout(updateProgress, nextDelay);
                        }
                    }

                    // Démarrer l'animation
                    updateProgress();
                }

                // Fonction pour réinitialiser une barre de progression
                function resetProgress(loadingId) {
                    // Récupérer l'élément de chargement et ses composants
                    const loading = document.getElementById(loadingId);
                    const progressBar = loading.querySelector('.progress-bar');
                    const progressText = loading.querySelector('.progress-text');
                    const progressStep = loading.querySelector('#predProgressStep, #mlProgressStep');
                    const progressPercent = loading.querySelector('.progress-percentage');
                    const progressTime = loading.querySelector('#predProgressTime, #mlProgressTime');

                    // Réinitialiser tous les éléments à leur état initial
                    if (progressBar) progressBar.style.width = '0%';
                    if (progressPercent) progressPercent.textContent = '0%';
                    if (progressText) progressText.textContent = 'Initialisation...';
                    if (progressStep) progressStep.textContent = 'Étape 1/-';
                    if (progressTime) progressTime.textContent = 'Temps estimé: --';
                }

                // Fonction principale pour générer des prédictions selon le modèle sélectionné
                function generatePredictions() {
                    // Récupérer le modèle sélectionné et les éléments d'affichage
                    const model = document.getElementById('predModel').value;
                    const loading = document.getElementById('predLoading');
                    const resultsDiv = document.getElementById('predResults');

                    // Réinitialiser et afficher la barre de progression
                    resetProgress('predLoading');
                    loading.classList.add('active');
                    resultsDiv.innerHTML = '';

                    // Démarrer l'animation de progression
                    startPredictionProgress();

                    // Simuler le traitement avec un délai (dans la réalité, ce serait du calcul réel)
                    setTimeout(() => {
                        let results = '';
                        let predictions = [];

                        // TRAITEMENT SPÉCIFIQUE POUR CHAQUE MODÈLE
                        if (model === 'chisquare') {
                            // TEST DU CHI-CARRÉ : Vérifie l'uniformité de la distribution
                            const testResult = chiSquareTest(historicalData.frequencies);

                            // Générer l'affichage des résultats du test
                            results = `
                <div class="info-box">
                    <h3>Résultats du Test Chi-carré (χ²)</h3>
                    <p><strong>Valeur χ² :</strong> ${testResult.chiSquare}</p>
                    <p><strong>Degrés de liberté :</strong> 48</p>
                    <p><strong>P-value :</strong> ${testResult.pValue}</p>
                    <p><strong>Interprétation :</strong> ${testResult.interpretation}</p>
                    ${testResult.isUniform ?
                                    '<p style="color: #4caf50;">Les numéros suivent une distribution uniforme.</p>' :
                                    '<p style="color: #ff9800;">Certains numéros apparaissent plus que d\'autres.</p>'}
                </div>
            `;

                            // Générer des prédictions aléatoires après le test
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            for (let i = 0; i < numPreds; i++) {
                                predictions.push({
                                    main: generateUniqueRandomNumbers(5, 1, 49),
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            }

                        } else if (model === 'montecarlo') {
                            // SIMULATION MONTE-CARLO AVANCÉE : Simulations massives pour identifier les combinaisons probables
                            const numSims = parseInt(document.getElementById('numMonteCarloSims').value);
                            const topCombo = parseInt(document.getElementById('topMonteCarlo').value);

                            // Utilisation de la fonction Monte-Carlo avancée
                            const mcResult = monteCarloAdvanced(historicalData.frequencies, numSims, topCombo);

                            // Générer l'affichage des statistiques de simulation
                            results = `
                <div class="info-box">
                    <h3>Simulation Monte-Carlo Avancée</h3>
                    <p><strong>Méthode :</strong> ${mcResult.stats.method}</p>
                    <p><strong>Simulations effectuées :</strong> ${mcResult.stats.totalSimulations.toLocaleString()}</p>
                    <p><strong>Combinaisons uniques générées :</strong> ${mcResult.stats.uniqueCombinations.toLocaleString()}</p>
                    <p><strong>Principe :</strong> Importance sampling basé sur fréquences (40%), écarts (30%), et tendances récentes (30%)</p>
                </div>
            `;

                            // Afficher chaque prédiction avec son classement
                            mcResult.predictions.forEach((pred, i) => {
                                predictions.push({
                                    main: pred.main,
                                    chance: pred.chance
                                });

                                results += `
                    <div class="prediction-card">
                        <h4>Top ${pred.rank} - Score: ${pred.avgScore}</h4>
                        <p style="font-size: 0.9em; color: #fff;">
                            Fréquence: ${pred.frequency}× | Probabilité: ${pred.probability}
                        </p>
                        <div style="display: flex; gap: 10px; margin: 10px 0; flex-wrap: wrap;">
                            ${pred.main.map(num => `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`).join('')}
                            <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(pred.chance)}">${pred.chance}</div>
                        </div>
                    </div>
                `;
                            });

                        } else if (model === 'poisson') {
                            // DISTRIBUTION DE POISSON : Modélisation basée sur les fréquences historiques
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            const poissonPreds = poissonPrediction(historicalData.frequencies, numPreds);

                            // Calculer la fréquence moyenne pour l'affichage
                            const avgFreq = Object.values(historicalData.frequencies).reduce((a, b) => a + b, 0) / 49;

                            // Générer l'explication du modèle
                            results = `
                <div class="info-box">
                    <h3>Distribution de Poisson</h3>
                    <p><strong>Principe:</strong> Sélection pondérée basée sur les fréquences historiques</p>
                    <p><strong>Fréquence moyenne:</strong> ${avgFreq.toFixed(2)} apparitions par numéro</p>
                    <p><strong>Méthode:</strong> P(k=1) = λ × e^(-λ) où λ = fréquence relative</p>
                </div>
            `;

                            // Stocker les prédictions
                            poissonPreds.forEach(mainNums => {
                                predictions.push({
                                    main: mainNums,
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            });

                        } else if (model === 'zipf') {
                            // LOI DE ZIPF : Pondération inversement proportionnelle au rang
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            const zipfPreds = zipfPrediction(historicalData.frequencies, numPreds);

                            // Identifier les 5 numéros les plus fréquents
                            const top5 = Object.entries(historicalData.frequencies)
                                .sort((a, b) => b[1] - a[1])
                                .slice(0, 5)
                                .map(([num, freq]) => `#${num}(${freq}×)`);

                            // Générer l'explication du modèle
                            results = `
                <div class="info-box">
                    <h3>Loi de Zipf</h3>
                    <p><strong>Principe:</strong> Pondération inversement proportionnelle au rang</p>
                    <p><strong>Formule:</strong> Poids = 1 / rang (le n° 1 a 2× plus de chances que le n° 2)</p>
                    <p><strong>Top 5 des numéros favorisés:</strong> ${top5.join(', ')}</p>
                    <p><strong>Particularité:</strong> Favorise fortement les numéros historiquement fréquents</p>
                </div>
            `;

                            // Stocker les prédictions
                            zipfPreds.forEach(mainNums => {
                                predictions.push({
                                    main: mainNums,
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            });

                        } else if (model === 'student') {
                            // TEST T DE STUDENT : Identifie les écarts significatifs à la moyenne
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            const studentResult = studentTestPrediction(historicalData.frequencies, numPreds);

                            // Générer l'explication du modèle avec statistiques
                            results = `
                <div class="info-box">
                    <h3>Test T de Student</h3>
                    <p><strong>Principe:</strong> Identifie les numéros avec des écarts significatifs à la moyenne</p>
                    <p><strong>Moyenne des fréquences:</strong> ${studentResult.stats.mean} apparitions</p>
                    <p><strong>Écart-type:</strong> ${studentResult.stats.stdDev}</p>
                    <p><strong>Numéros avec t-score élevé:</strong> ${studentResult.stats.mostSignificant.join(', ')}</p>
                    <p><strong>Stratégie:</strong> Mix de numéros sur-représentés et sous-représentés</p>
                </div>
            `;

                            // Stocker les prédictions
                            studentResult.predictions.forEach(mainNums => {
                                predictions.push({
                                    main: mainNums,
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            });

                        } else if (model === 'dirichlet') {
                            // DISTRIBUTION DE DIRICHLET : Modélise la répartition par dizaines
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            const dirichletResult = dirichletPrediction(historicalData.frequencies, numPreds);

                            // Générer l'explication du modèle avec interprétation
                            results = `
                <div class="info-box">
                    <h3>Distribution de Dirichlet</h3>
                    <p><strong>Principe:</strong> Modélise la répartition des numéros par dizaines</p>
                    <p><strong>Répartition optimale:</strong></p>
                    <ul style="margin-left: 20px;">
                        ${dirichletResult.interpretation.map(line => `<li>${line}</li>`).join('')}
                    </ul>
                    <p><strong>Particularité:</strong> Équilibre intelligent entre les différentes tranches de numéros</p>
                </div>
            `;

                            // Stocker les prédictions
                            dirichletResult.predictions.forEach(mainNums => {
                                predictions.push({
                                    main: mainNums,
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            });

                        } else if (model === 'binomiale') {
                            // DISTRIBUTION BINOMIALE : Modélisation de la répartition pairs/impairs
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            const binomialResult = binomialPrediction(historicalData.frequencies, numPreds);

                            // Générer l'explication du modèle avec statistiques détaillées
                            results = `
                <div class="info-box">
                    <h3>Distribution Binomiale</h3>
                    <p><strong>Principe:</strong> Modélisation de la répartition pairs/impairs selon la loi binomiale</p>
                    <p><strong>Probabilité pair:</strong> ${binomialResult.stats.pEven}</p>
                    <p><strong>Probabilité impair:</strong> ${binomialResult.stats.pOdd}</p>
                    <p><strong>Attendu par tirage:</strong> ${binomialResult.stats.expectedEvenPerDraw} pairs, ${binomialResult.stats.expectedOddPerDraw} impairs</p>
                    <p><strong>Total historique:</strong> ${binomialResult.stats.totalEven} pairs, ${binomialResult.stats.totalOdd} impairs</p>
                </div>
            `;

                            // Stocker les prédictions
                            binomialResult.predictions.forEach(mainNums => {
                                predictions.push({
                                    main: mainNums,
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            });

                        } else if (model === 'gamma') {
                            // DISTRIBUTION GAMMA : Modélisation des temps d'attente entre apparitions
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            const gammaResult = gammaPrediction(historicalData.frequencies, numPreds);

                            // Générer l'explication du modèle avec statistiques temporelles
                            results = `
                <div class="info-box">
                    <h3>Distribution Gamma</h3>
                    <p><strong>Principe:</strong> Modélisation des temps d'attente entre apparitions</p>
                    <p><strong>Temps d'attente moyen:</strong> ${gammaResult.stats.avgWaitTime}</p>
                    <p><strong>Total des tirages analysés:</strong> ${gammaResult.stats.totalDraws}</p>
                    <p><strong>Top 5 numéros favorisés:</strong></p>
                    <ul style="margin-left: 20px;">
                        ${gammaResult.stats.topNumbers.map(num => `<li>${num}</li>`).join('')}
                    </ul>
                    <p><strong>Particularité:</strong> Favorise les numéros avec un temps d'attente optimal</p>
                </div>
            `;

                            // Stocker les prédictions
                            gammaResult.predictions.forEach(mainNums => {
                                predictions.push({
                                    main: mainNums,
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            });

                        } else {
                            // MODÈLE PAR DÉFAUT : Génération aléatoire simple
                            const numPreds = parseInt(document.getElementById('numPredictions').value);
                            for (let i = 0; i < numPreds; i++) {
                                predictions.push({
                                    main: generateUniqueRandomNumbers(5, 1, 49),
                                    chance: Math.floor(Math.random() * 10) + 1
                                });
                            }
                        }

                        // AFFICHER TOUTES LES PRÉDICTIONS GÉNÉRÉES
                        predictions.forEach((pred, i) => {
                            results += `
                <div class="prediction-card">
                    <h4>Combinaison ${i + 1} (${model})</h4>
                    <div style="display: flex; gap: 10px; margin: 10px 0; flex-wrap: wrap;">
                        ${pred.main.map(num => `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`).join('')}
                        <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(pred.chance)}">${pred.chance}</div>
                    </div>
                </div>`;
                        });

                        // Injecter les résultats dans le DOM et masquer le loader
                        resultsDiv.innerHTML = results;
                        loading.classList.remove('active');
                    }, 2000);  // Délai de 2 secondes pour simuler le traitement
                }

                // Fonction pour effectuer l'analyse statistique selon le type sélectionné
                function performStatAnalysis() {
                    // Récupérer le type d'analyse sélectionné
                    const type = document.getElementById('statType').value;
                    let labels = [];   // Labels pour le graphique
                    let data = [];     // Données pour le graphique
                    let title = '';    // Titre du graphique

                    // Préparer les données selon le type d'analyse
                    switch (type) {
                        case 'distribution':
                            // DISTRIBUTION DES NUMÉROS : Fréquence de chaque numéro de 1 à 49
                            labels = Array.from({ length: 49 }, (_, i) => i + 1);
                            data = labels.map(num => historicalData.frequencies[num] || 0);
                            title = 'Distribution des Numéros';
                            break;

                        case 'parite':
                            // ANALYSE DE PARITÉ : Nombre de pairs vs impairs dans tous les tirages
                            labels = ['Pairs', 'Impairs'];
                            const pairs = filteredDraws.reduce((sum, draw) =>
                                sum + draw.numbers.filter(n => n % 2 === 0).length, 0);
                            const impairs = filteredDraws.reduce((sum, draw) =>
                                sum + draw.numbers.filter(n => n % 2 !== 0).length, 0);
                            data = [pairs, impairs];
                            title = 'Répartition Pairs/Impairs';
                            break;

                        case 'somme':
                            // DISTRIBUTION DES SOMMES : Répartition des sommes des numéros par tirage
                            labels = ['<100', '100-150', '150-200', '>200'];
                            const sums = filteredDraws.map(draw => draw.numbers.reduce((a, b) => a + b, 0));
                            data = [
                                sums.filter(s => s < 100).length,
                                sums.filter(s => s >= 100 && s <= 150).length,
                                sums.filter(s => s > 150 && s <= 200).length,
                                sums.filter(s => s > 200).length
                            ];
                            title = 'Distribution des Sommes';
                            break;
                    }

                    // Mettre à jour le graphique statistique
                    charts.statChart.data.labels = labels;
                    charts.statChart.data.datasets = [{
                        label: title,
                        data: data,
                        backgroundColor: 'rgba(102, 126, 234, 0.7)',  // Couleur bleue cohérente
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1
                    }];
                    charts.statChart.options.plugins.title.text = title;
                    charts.statChart.update();

                    // Générer les résultats textuels
                    let results = `<p><h4>Résultats de l'analyse: ${title}</h4><p>`;
                    results += `<p>Total des tirages analysés: ${filteredDraws.length}</p>`;
                    document.getElementById('statResults').innerHTML = results;
                }

                // ============================================================================
                // FONCTIONS POUR LE MACHINE LEARNING AVEC EXPLICATIONS DÉTAILLÉES
                // ============================================================================

                /**
                 * Fonction pour générer des explications détaillées du processus Machine Learning
                 * @param {string} modelType - Type de modèle ML (rf, gb, logistic, ensemble, lstm)
                 * @param {object} metrics - Métriques de performance du modèle
                 * @param {object} prediction - Prédictions générées par le modèle
                 * @returns {string} HTML contenant l'explication détaillée du processus
                 */
                function getMLDetailedExplanation(modelType, metrics, prediction) {
                    // Dictionnaire des explications détaillées pour chaque type de modèle
                    const explanations = {
                        'rf': `
            <div class="ml-explanation-steps">
                <p><h5>Random Forest - Processus détaillé :</h5><p>
                <ol>
                    <li><strong>Préparation des données :</strong> 
                        <ul>
                            <li>Chargement de ${filteredDraws.length} tirages historiques</li>
                            <li>Extraction des features : fréquences, temps d'attente, patterns statistiques</li>
                            <li>Normalisation des données pour l'entraînement</li>
                        </ul>
                    </li>
                    <li><strong>Construction de la forêt :</strong>
                        <ul>
                            <li>Création de 100 arbres de décision (estimators)</li>
                            <li>Max depth : 15 niveaux par arbre</li>
                            <li>Min samples split : 2 échantillons minimum</li>
                        </ul>
                    </li>
                    <li><strong>Entraînement :</strong>
                        <ul>
                            <li>Bootstrapping : 80% des données par arbre</li>
                            <li>Feature selection aléatoire à chaque split</li>
                            <li>Optimisation Gini impurity</li>
                        </ul>
                    </li>
                    <li><strong>Prédiction :</strong>
                        <ul>
                            <li>Vote majoritaire des 100 arbres</li>
                            <li>Probabilités : ${prediction.main.join(', ')}</li>
                            <li>Score de confiance : ${metrics.accuracy}%</li>
                        </ul>
                    </li>
                </ol>
            </div>
        `,

                        'gb': `
            <div class="ml-explanation-steps">
                <h5>Gradient Boosting - Processus détaillé :</h5>
                <ol>
                    <li><strong>Initialisation :</strong>
                        <ul>
                            <li>Modèle de base : moyenne des fréquences historiques</li>
                            <li>Learning rate : 0.1 (taux d'apprentissage)</li>
                            <li>Nombre d'arbres : 200 (n_estimators)</li>
                        </ul>
                    </li>
                    <li><strong>Boosting séquentiel :</strong>
                        <ul>
                            <li>Arbre 1 : correction des erreurs du modèle initial</li>
                            <li>Arbre 2 : focus sur les résidus de l'arbre 1</li>
                            <li>Itération jusqu'à l'arbre 200</li>
                        </ul>
                    </li>
                    <li><strong>Optimisation :</strong>
                        <ul>
                            <li>Fonction de perte : Mean Squared Error (Erreur Quadratique Moyenne)</li>
                            <li>Max depth : 6 niveaux maximum par arbre</li>
                            <li>Subsampling : 90% des données utilisées</li>
                        </ul>
                    </li>
                    <li><strong>Résultat final :</strong>
                        <ul>
                            <li>Combinaison pondérée des 200 arbres</li>
                            <li>Features importantes : temps d'attente (35%), fréquence (28%)</li>
                            <li>Précision : ${metrics.accuracy}%</li>
                        </ul>
                    </li>
                </ol>
            </div>
        `,

                        'logistic': `
            <div class="ml-explanation-steps">
                <h5>Régression Logistique - Processus détaillé :</h5>
                <ol>
                    <li><strong>Préparation :</strong>
                        <ul>
                            <li>Encodage one-hot des 49 numéros (transformation binaire)</li>
                            <li>Normalisation Min-Max des features (mise à l'échelle 0-1)</li>
                            <li>Split train/test : 80% entraînement, 20% test</li>
                        </ul>
                    </li>
                    <li><strong>Configuration :</strong>
                        <ul>
                            <li>Fonction sigmoïde pour les probabilités (transformation non-linéaire)</li>
                            <li>Régularisation L2 (C=1.0) pour éviter le surapprentissage</li>
                            <li>Max iterations : 1000 itérations maximum</li>
                        </ul>
                    </li>
                    <li><strong>Entraînement :</strong>
                        <ul>
                            <li>Algorithme : L-BFGS optimization (méthode quasi-Newton)</li>
                            <li>Calcul des coefficients pour chaque numéro (poids)</li>
                            <li>Mise à jour des poids par gradient descent (descente de gradient)</li>
                        </ul>
                    </li>
                    <li><strong>Interprétation :</strong>
                        <ul>
                            <li>Coefficients positifs : numéros favorisés par le modèle</li>
                            <li>Probabilités normalisées entre 0-1 (échelle de probabilité)</li>
                            <li>Seuil de décision : 0.5 (limite de classification)</li>
                        </ul>
                    </li>
                </ol>
            </div>
        `,

                        'ensemble': `
            <div class="ml-explanation-steps">
                <h5>Ensemble Stacking - Processus détaillé :</h5>
                <ol>
                    <li><strong>Modèles de base :</strong>
                        <ul>
                            <li>Random Forest (précision: 82%) - robuste aux outliers</li>
                            <li>Gradient Boosting (précision: 85%) - bon sur les relations complexes</li>
                            <li>Régression Logistique (précision: 78%) - interprétable et rapide</li>
                        </ul>
                    </li>
                    <li><strong>Stacking layer :</strong>
                        <ul>
                            <li>Récupération des prédictions de chaque modèle (méta-features)</li>
                            <li>Combinaison via méta-classificateur (Régression Linéaire)</li>
                            <li>Pondération optimale des modèles selon leurs performances</li>
                        </ul>
                    </li>
                    <li><strong>Validation :</strong>
                        <ul>
                            <li>Cross-validation : 5 folds (validation croisée 5 partitions)</li>
                            <li>Optimisation des poids par grid search (recherche systématique)</li>
                            <li>Score stacking final : ${metrics.accuracy}% (amélioration par rapport aux modèles individuels)</li>
                        </ul>
                    </li>
                    <li><strong>Avantages :</strong>
                        <ul>
                            <li>Réduction du sur-apprentissage (overfitting)</li>
                            <li>Meilleure généralisation sur de nouvelles données</li>
                            <li>Compensation des faiblesses individuelles des modèles</li>
                        </ul>
                    </li>
                </ol>
            </div>
        `,

                        'lstm': `
            <div class="ml-explanation-steps">
                <h5>LSTM (Deep Learning) - Processus détaillé :</h5>
                <ol>
                    <li><strong>Architecture réseau :</strong>
                        <ul>
                            <li>Couche LSTM : 128 unités avec dropout 0.2 (mémoire à long terme)</li>
                            <li>Couche Dense : 64 neurones ReLU (activation rectifiée)</li>
                            <li>Couche de sortie : 49 neurones softmax (probabilités pour chaque numéro)</li>
                        </ul>
                    </li>
                    <li><strong>Préparation séquentielle :</strong>
                        <ul>
                            <li>Séquences de 10 tirages consécutifs (fenêtre temporelle)</li>
                            <li>Fenêtre glissante pour l'apprentissage (sliding window)</li>
                            <li>Encodage temporel des patterns (séquentialité des tirages)</li>
                        </ul>
                    </li>
                    <li><strong>Entraînement :</strong>
                        <ul>
                            <li>Optimiseur : Adam (lr=0.001) - méthode adaptive</li>
                            <li>Loss function : Categorical Crossentropy (perte catégorielle)</li>
                            <li>Batch size : 32, Epochs : 100 (lots de 32, 100 passages complets)</li>
                        </ul>
                    </li>
                    <li><strong>Patterns détectés :</strong>
                        <ul>
                            <li>Tendances temporelles sur 10 tirages (évolutions dans le temps)</li>
                            <li>Cycles et répétitions (patterns récurrents)</li>
                            <li>Dépendances long terme entre numéros (influences temporelles)</li>
                        </ul>
                    </li>
                </ol>
            </div>
        `
                    };

                    // Retourner l'explication correspondante ou un message par défaut
                    return explanations[modelType] || '<p>Explications détaillées non disponibles pour ce modèle.</p>';
                }

                // ----------------------
                // Encode un tirage en vecteur binaire 49 dimensions avec Tensorflmow.js
                // ----------------------

                /**
                 * Encode un tirage en vecteur binaire 49 dimensions (one-hot encoding)
                 * @param {object} draw - Objet tirage contenant les numéros
                 * @returns {array} Vecteur binaire de 49 positions (1 = numéro présent, 0 = absent)
                 */
                function encodeDraw(draw) {
                    // Créer un vecteur one-hot de 49 positions initialisées à 0
                    const encoding = Array(49).fill(0);

                    // Vérifier que le tirage contient bien des numéros valides
                    if (draw && draw.numbers && Array.isArray(draw.numbers)) {
                        // Pour chaque numéro du tirage, marquer sa position dans le vecteur
                        draw.numbers.forEach(num => {
                            if (num >= 1 && num <= 49) {
                                encoding[num - 1] = 1; // Marquer le numéro comme présent (index 0-based)
                            }
                        });
                    }

                    return encoding;
                }

                /**
                 * Fonction principale pour entraîner un modèle de Machine Learning
                 * Utilise TensorFlow.js pour créer et entraîner un réseau neuronal
                 */
                async function trainMLModel() {
                    // Récupérer les éléments DOM pour l'affichage
                    const loading = document.getElementById('mlLoading');
                    const resultsDiv = document.getElementById('mlResults');
                    const metricsDiv = document.getElementById('mlMetrics');
                    const explanationDiv = document.getElementById('mlDetailedExplanation');

                    // Afficher le chargement immédiatement
                    loading.classList.add('active');
                    metricsDiv.innerHTML = '';
                    resultsDiv.innerHTML = '';
                    explanationDiv.style.display = 'block';

                    /**
                     * Fonction utilitaire pour mettre à jour la progression de l'entraînement
                     * @param {number} percent - Pourcentage de progression
                     * @param {number} step - Étape actuelle
                     * @param {number} totalSteps - Nombre total d'étapes
                     * @param {string} message - Message principal
                     * @param {string} details - Détails supplémentaires
                     */
                    function updateProgress(percent, step, totalSteps, message, details = '') {

                        // Mettre à jour la barre de progression visuelle
                        document.getElementById('mlProgressBar').style.width = percent + '%';
                        document.getElementById('mlProgressPercent').textContent = percent + '%';
                        document.getElementById('mlProgressStep').textContent = `Étape ${step}/${totalSteps}`;
                        document.getElementById('mlProgressText').textContent = message;
                        document.getElementById('mlProgressDetails').textContent = details;

                        // Calculer et afficher les temps écoulés et restants
                        const elapsed = Date.now() - startTime;
                        const estimatedTotal = elapsed / (percent / 100);
                        const remaining = Math.max(0, (estimatedTotal - elapsed) / 1000);
                        document.getElementById('mlProgressTime').textContent =
                            `Temps écoulé: ${(elapsed / 1000).toFixed(1)}s | Restant: ${remaining.toFixed(1)}s`;
                    }

                    const startTime = Date.now(); // Temps de début pour le calcul de la durée

                    try {


                        // ÉTAPE 1: Préparation des données (0-15%)

                        updateProgress(0, 1, 6, 'Préparation des données...', 'Chargement de l\'historique');
                        await new Promise(resolve => setTimeout(resolve, 100)); // Pause pour permettre l'update UI


                        // S'assurer que le filtre ML est appliqué
                        if (mlFilteredDraws.length === 0) {
                            console.warn(' mlFilteredDraws vide, réapplication du filtre');
                            applyMLPeriodFilter();
                        }

                        // Utiliser les tirages filtrés (ou fallback sur tous si toujours vide)
                        const draws = mlFilteredDraws.length > 0 ? mlFilteredDraws : historicalData.draws;

                        console.log(`🎓 Entraînement ML démarré sur ${draws.length} tirages`);
                        // Vérifier qu'il y a suffisamment de données pour l'entraînement
                        if (!draws || draws.length < 2) {
                            throw new Error("Pas assez de tirages pour l'entraînement !");
                        }

                        updateProgress(10, 1, 6, 'Encodage des données...', 'Conversion en vecteurs binaires');

                        // Préparer les features (X) et labels (y) pour l'entraînement
                        const features = []; // Entrées du modèle (tirages précédents)
                        const labels = [];   // Sorties attendues (tirages suivants)

                        // Créer des paires (tirage_n, tirage_n+1) pour l'apprentissage séquentiel
                        for (let i = 1; i < draws.length; i++) {
                            features.push(encodeDraw(draws[i - 1])); // Tirage précédent = input
                            labels.push(encodeDraw(draws[i]));       // Tirage suivant = target
                        }

                        updateProgress(15, 1, 6, 'Données préparées', `${features.length} échantillons d'entraînement créés`);
                        await new Promise(resolve => setTimeout(resolve, 200));

                        // ÉTAPE 2: Création du modèle (15-25%)

                        updateProgress(15, 2, 6, 'Création du modèle...', 'Initialisation de l\'architecture neuronale');

                        // Convertir les tableaux JavaScript en tenseurs TensorFlow.js
                        const xs = tf.tensor2d(features); // Features d'entraînement
                        const ys = tf.tensor2d(labels);   // Labels d'entraînement

                        // Créer un modèle séquentiel (couches linéaires empilées)
                        const model = tf.sequential();

                        // Couche dense 1: 64 neurones avec activation ReLU
                        model.add(tf.layers.dense({
                            units: 64,
                            activation: 'relu',
                            inputShape: [49] // 49 entrées (un par numéro possible)
                        }));
                        updateProgress(18, 2, 6, 'Création du modèle...', 'Couche 1: 64 neurones ReLU');

                        // Couche dense 2: 32 neurones avec activation ReLU
                        model.add(tf.layers.dense({
                            units: 32,
                            activation: 'relu'
                        }));
                        updateProgress(21, 2, 6, 'Création du modèle...', 'Couche 2: 32 neurones ReLU');

                        // Couche de sortie: 49 neurones avec activation sigmoid (probabilités)
                        model.add(tf.layers.dense({
                            units: 49,
                            activation: 'sigmoid' // Sigmoid pour des probabilités entre 0 et 1
                        }));
                        updateProgress(24, 2, 6, 'Création du modèle...', 'Couche de sortie: 49 neurones Sigmoid');

                        // Compiler le modèle avec configuration d'entraînement
                        model.compile({
                            optimizer: 'adam',                    // Optimiseur Adam (efficace)
                            loss: 'binaryCrossentropy',          // Fonction de perte pour classification binaire
                            metrics: ['accuracy']                // Métrique de précision
                        });
                        updateProgress(25, 2, 6, 'Modèle créé et compilé', 'Optimiseur: Adam | Loss: Binary Crossentropy');
                        await new Promise(resolve => setTimeout(resolve, 300));

                        // ÉTAPE 3: Entraînement (25-85%)

                        const totalEpochs = 30; // Nombre total de passages sur le dataset
                        let currentEpoch = 0;

                        updateProgress(25, 3, 6, `Entraînement 0/${totalEpochs}...`, 'Démarrage des itérations');

                        // Lancer l'entraînement du modèle
                        await model.fit(xs, ys, {
                            epochs: totalEpochs,     // 30 passages complets sur les données
                            batchSize: 8,           // Lots de 8 échantillons
                            shuffle: true,          // Mélanger les données à chaque epoch
                            verbose: 0,             // Désactiver les logs par défaut
                            callbacks: {
                                // Callback appelé à la fin de chaque epoch
                                onEpochEnd: async (epoch, logs) => {
                                    currentEpoch = epoch + 1;
                                    const progressPercent = 25 + (currentEpoch / totalEpochs) * 60;
                                    const loss = logs.loss.toFixed(4);    // Valeur de la fonction de perte
                                    const acc = (logs.acc * 100).toFixed(2); // Précision en pourcentage

                                    updateProgress(
                                        Math.round(progressPercent),
                                        3,
                                        6,
                                        `Entraînement ${currentEpoch}/${totalEpochs}...`,
                                        `Perte: ${loss} | Précision: ${acc}%`
                                    );

                                    await tf.nextFrame(); // Important pour la réactivité de l'UI
                                }
                            }
                        });

                        updateProgress(85, 3, 6, 'Entraînement terminé', `${totalEpochs} époques complétées avec succès`);
                        await new Promise(resolve => setTimeout(resolve, 200));

                        // ÉTAPE 4: Évaluation (85-92%)

                        updateProgress(85, 4, 6, 'Évaluation du modèle...', 'Calcul des métriques de performance');

                        // Évaluer le modèle sur les données d'entraînement
                        const evaluation = await model.evaluate(xs, ys);
                        const loss = (await evaluation[0].data())[0];     // Perte finale
                        const accuracy = (await evaluation[1].data())[0]; // Précision finale

                        updateProgress(92, 4, 6, 'Évaluation terminée', `Précision finale: ${(accuracy * 100).toFixed(2)}%`);
                        await new Promise(resolve => setTimeout(resolve, 200));

                        // ÉTAPE 5: Affichage des résultats (92-98%)

                        updateProgress(92, 5, 6, 'Génération des résultats...', 'Création de l\'interface utilisateur');

                        const modelType = document.getElementById('mlModel').value;
                        const modelName = getModelName(modelType);

                        // ÉTAPE 6: Finalisation (98-100%)

                        updateProgress(98, 6, 6, 'Nettoyage...', 'Libération de la mémoire');

                        let periodInfo = '';
                        if (mlCurrentPeriod === 'all' && draws.length > 0) {
                            const lastDate = new Date(draws[0].date);
                            const firstDate = new Date(draws[draws.length - 1].date);
                            periodInfo = `<p><small>📅 Période utilisée : ${firstDate.toLocaleDateString('fr-FR')} → ${lastDate.toLocaleDateString('fr-FR')}</small></p>`;
                        }


                        // Afficher les métriques de performance dans une grille

                        metricsDiv.innerHTML = `
            <div class="stat-card">
                <h4>Précision</h4>
                <div class="value">${(accuracy * 100).toFixed(2)}%</div>
            </div>

            <div class="stat-card">
                <h4>Perte</h4>
                <div class="value">${loss.toFixed(4)}</div>
            </div>

            <div class="stat-card">
                <h4>Modèle</h4>
                <div class="value">${modelName}</div>
            </div>
            
            <div class="stat-card">
                <h4>Échantillons</h4>
                <div class="value">${draws.length}</div>
            </div>
        `;

                        updateProgress(95, 5, 6, 'Affichage des métriques...', 'Métriques de performance affichées');

                        // Générer et afficher les explications détaillées du modèle
                        const detailedExplanation = getMLDetailedExplanation(
                            modelType, {
                            accuracy: accuracy * 100,
                            loss: loss
                        }, {
                            main: [1, 2, 3, 4, 5],
                            chance: 1
                        }
                        );

                        document.getElementById('mlDetailedExplanationContent').innerHTML = detailedExplanation;

                        updateProgress(96, 5, 6, 'Génération de la prédiction...', 'Analyse du dernier tirage');

                        const lastDraw = draws[0];


                        // Le tirage le plus récent

                        const lastDrawEncoded = encodeDraw(lastDraw);

                        // Prédire le prochain tirage basé sur le dernier
                        const xPredict = tf.tensor2d([lastDrawEncoded]);
                        const prediction = model.predict(xPredict);
                        const predArray = Array.from(prediction.dataSync());

                        // Sélection des 5 numéros avec les probabilités les plus élevées

                        const numbersWithProbs = predArray.map((prob, index) => ({
                            number: index + 1,
                            probability: prob
                        })).sort((a, b) => b.probability - a.probability);

                        const predictedNumbers = numbersWithProbs.slice(0, 5).map(item => item.number).sort((a, b) => a - b);

                        // Prédiction du numéro chance basée sur les fréquences historiques de la période

                        const chanceFrequencies = {};

                        // Initialiser les fréquences pour les numéros chance (1-10)
                        for (let i = 1; i <= 10; i++) {
                            chanceFrequencies[i] = 0;
                        }

                        // Compter les fréquences des numéros chance dans la période sélectionnée

                        draws.forEach(draw => {
                            if (draw.chance >= 1 && draw.chance <= 10) {
                                chanceFrequencies[draw.chance]++;
                            }
                        });

                        // Sélectionner le numéro chance le plus fréquent (avec un peu d'aléatoire)

                        const chanceProbs = [];
                        for (let i = 1; i <= 10; i++) {
                            chanceProbs.push({
                                number: i,
                                frequency: chanceFrequencies[i],
                                weight: chanceFrequencies[i] + Math.random() * 2 // Ajoute un peu d'aléatoire
                            });
                        }
                        chanceProbs.sort((a, b) => b.weight - a.weight);
                        const chanceNumber = chanceProbs[0].number;
                        const chanceFreq = chanceFrequencies[chanceNumber];

                        // Nettoyage des tenseurs de prédiction pour libérer la mémoire GPU

                        tf.dispose([xPredict, prediction]);

                        resultsDiv.innerHTML = `
            <p><h3>Résultats de l'entraînement - ${modelName}</h3><p>
            <div class="matrix-result-card">
                <p><h4>Métriques d'entraînement</h4><p>
                <p><strong>Précision :</strong> ${(accuracy * 100).toFixed(2)}%</p>
                <p><strong>Perte :</strong> ${loss.toFixed(4)}</p>
                <p><strong>Période d'entraînement :</strong> ${mlCurrentPeriod === 'all' ? '1 an (par défaut)' : 'Période personnalisée'}</p>
                ${periodInfo}
                <p><small>Les 12 derniers mois à partir du dernier tirage</small></p>
                <p><strong>Tirages analysés :</strong> ${draws.length}</p>
                <p><small>Entraînement effectué sur ${features.length} échantillons en ${((Date.now() - startTime) / 1000).toFixed(2)}s.</small></p>
            </div>
            
            <div class="matrix-result-card" style="margin-top: 20px;">
                <p><h4>Prédiction basée sur l'entraînement</h4><p>
                <p style="margin-bottom: 15px;">Combinaison suggérée par le modèle ${modelName} :</p>

                <div style="display: flex; gap: 10px; margin: 15px 0; flex-wrap: wrap; justify-content: left;">
                    ${predictedNumbers.map(num =>
                            `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`
                        ).join('')}
                    <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(chanceNumber)}">
                        ${chanceNumber}
                    </div>
                </div>
            </div>

                <div class="matrix-result-card" style="margin-top: 20px;">

                <div <p style="font-size: 0.90em; margin: 10px 0;"><h4>Numéros principaux - Top 5 par probabilité:<h4></p>
                    ${numbersWithProbs.slice(0, 5).map((item, index) =>
                            `<p style="font-size: 0.95em; margin: 5px 0;">
                            ${index + 1}. Numéro <strong>${item.number}</strong> - Probabilité : ${(item.probability * 100).toFixed(2)}%
                        </p>`
                        ).join('')}
                </div>

                <div <p style="font-size: 0.9em; margin: 5px 0;"><h4>Numéro chance:<h4></p>
                    <p style="font-size: 0.95em; margin: 3px 0;">
                        Numéro <strong>${chanceNumber}</strong> - Fréquence historique : ${chanceFreq} apparitions (${((chanceFreq / draws.length) * 100).toFixed(1)}%)
                    </p>
                    <p style="font-size: 0.8em; margin: 5px 0; opacity: 0.8;">
                        <em>Sélectionné parmi les numéros chance les plus fréquents de la période d'entraînement</em>
                    </p>
                </div>
            </div>
        `;

                        updateProgress(98, 5, 6, 'Résultats affichés', 'Interface mise à jour avec succès');
                        await new Promise(resolve => setTimeout(resolve, 200));



                        // Libération des tenseurs

                        tf.dispose([xs, ys, evaluation]);

                        updateProgress(100, 6, 6, 'Entraînement terminé !', `Durée totale: ${((Date.now() - startTime) / 1000).toFixed(2)}s`);

                        // Masquer le chargement après 1 seconde

                        setTimeout(() => {
                            loading.classList.remove('active');
                        }, 1000);

                    } catch (error) {
                        console.error('Erreur lors de l\'entraînement:', error);
                        updateProgress(0, 0, 6, 'Erreur lors de l\'entraînement', error.message);
                        alert('Erreur: ' + error.message);
                        loading.classList.remove('active');
                    }
                }

                function getModelName(modelType) {
                    const names = {
                        'rf': 'Random Forest',
                        'gb': 'Gradient Boosting',
                        'logistic': 'Régression Logistique',
                        'ensemble': 'Ensemble Stacking',
                        'lstm': 'LSTM'
                    };
                    return names[modelType] || 'Modèle ML';
                }


                // ============================================================================
                // GESTION DU MENU MOBILE
                // ============================================================================

                function initMobileMenu() {
                    const menuToggle = document.getElementById('mobileMenuToggle');
                    const sidebar = document.querySelector('.sidebar');
                    const overlay = document.getElementById('menuOverlay');
                    const navItems = document.querySelectorAll('.nav-item');

                    menuToggle.addEventListener('click', function () {
                        sidebar.classList.toggle('active');
                        overlay.classList.toggle('active');
                    });

                    overlay.addEventListener('click', function () {
                        sidebar.classList.remove('active');
                        overlay.classList.remove('active');
                    });

                    navItems.forEach(item => {
                        item.addEventListener('click', function () {
                            if (window.innerWidth <= 768) {
                                sidebar.classList.remove('active');
                                overlay.classList.remove('active');
                            }
                        });
                    });
                }

                // ============================================================================
                // FONCTIONS POUR L'ONGLET MATRICE
                // ============================================================================


                function initMatriceTab() {
                    createMatrixCheckboxes();        // Crée les cases à cocher des modèles
                    updateMatrixVisualization();     // Met à jour l'interface visuelle
                    attachMatrixEventListeners();    // Attache les événements
                    initMatrixCharts();              // Initialise les graphiques
                }

                /**
                 * Crée et configure les cases à cocher pour la sélection des modèles
                 */

                function createMatrixCheckboxes() {
                    // Récupérer toutes les cases à cocher dans la section matrice
                    const checkboxes = document.querySelectorAll('#matrice .checkbox-item input[type="checkbox"]');

                    // Ajouter un écouteur d'événement sur chaque case à cocher

                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', updateMatrixConfiguration);
                    });

                    // Écouter les changements sur les sélecteurs de configuration

                    document.getElementById('weightingMethod').addEventListener('change', updateMatrixConfiguration);
                    document.getElementById('fusionMethod').addEventListener('change', updateMatrixConfiguration);
                    document.getElementById('matrixNumPredictions').addEventListener('change', updateMatrixConfiguration);
                }

                /**
                 * Attache les écouteurs d'événements spécifiques à la matrice
                 */

                function attachMatrixEventListeners() {
                    // S'assurer que l'onglet Matrice se réinitialise quand on clique dessus
                    document.querySelector('.nav-item[onclick="showTab(\'matrice\')"]')
                        .addEventListener('click', initMatriceTab);
                }

                /**
                 * Initialise les graphiques de visualisation de la matrice
                 */

                function initMatrixCharts() {
                    const ctx = document.getElementById('matrixArchitectureChart')?.getContext('2d');
                    if (ctx) {
                        // Créer un graphique en beignet (doughnut) pour visualiser la répartition des modèles
                        matrixCharts.architecture = new Chart(ctx, {
                            type: 'doughnut', // Type de graphique : beignet
                            data: {
                                labels: ['Statistiques', 'ML', 'Avancées'], // Catégories de modèles
                                datasets: [{
                                    data: [0, 0, 0], // Données initiales (seront mises à jour)
                                    backgroundColor: [
                                        'rgba(102, 126, 234, 0.8)', // Bleu pour statistiques
                                        'rgba(76, 175, 80, 0.8)',   // Vert pour ML
                                        'rgba(255, 152, 0, 0.8)'    // Orange pour techniques avancées
                                    ],
                                    borderColor: [
                                        'rgba(102, 126, 234, 1)',
                                        'rgba(76, 175, 80, 1)',
                                        'rgba(255, 152, 0, 1)'
                                    ],
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true, // S'adapte à la taille du conteneur
                                maintainAspectRatio: false, // Permet de redimensionner librement
                                plugins: {
                                    legend: {
                                        position: 'bottom', // Légende en bas
                                        labels: {
                                            color: '#ffffff', // Texte blanc pour le thème sombre
                                            font: {
                                                size: 12
                                            }
                                        }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Répartition des Modèles',
                                        color: '#ffffff',
                                        font: {
                                            size: 14,
                                            weight: 'bold'
                                        }
                                    }
                                }
                            }
                        });
                    }
                }

                /**
                 * Met à jour la configuration de la matrice basée sur les sélections utilisateur
                 */

                function updateMatrixConfiguration() {
                    // Réinitialiser les tableaux de modèles
                    matrixConfiguration.statisticalModels = [];
                    matrixConfiguration.mlModels = [];
                    matrixConfiguration.advancedTechniques = [];

                    // MODÈLES STATISTIQUES - Vérifier chaque case à cocher

                    if (document.getElementById('matrixPoisson')?.checked) {
                        matrixConfiguration.statisticalModels.push('poisson');
                    }
                    if (document.getElementById('matrixBinomial')?.checked) {
                        matrixConfiguration.statisticalModels.push('binomial');
                    }
                    if (document.getElementById('matrixZipf')?.checked) {
                        matrixConfiguration.statisticalModels.push('zipf');
                    }
                    if (document.getElementById('matrixDirichlet')?.checked) {
                        matrixConfiguration.statisticalModels.push('dirichlet');
                    }

                    // MODÈLES MACHINE LEARNING

                    if (document.getElementById('matrixRF')?.checked) {
                        matrixConfiguration.mlModels.push('rf');
                    }
                    if (document.getElementById('matrixGB')?.checked) {
                        matrixConfiguration.mlModels.push('gb');
                    }
                    if (document.getElementById('matrixLSTM')?.checked) {
                        matrixConfiguration.mlModels.push('lstm');
                    }

                    // TECHNIQUES AVANCÉES

                    if (document.getElementById('matrixClustering')?.checked) {
                        matrixConfiguration.advancedTechniques.push('clustering');
                    }
                    if (document.getElementById('matrixMonteCarlo')?.checked) {
                        matrixConfiguration.advancedTechniques.push('montecarlo');
                    }
                    if (document.getElementById('matrixEnsemble')?.checked) {
                        matrixConfiguration.advancedTechniques.push('ensemble');
                    }

                    // Récupérer les paramètres de configuration

                    matrixConfiguration.weighting = document.getElementById('weightingMethod').value;
                    matrixConfiguration.fusion = document.getElementById('fusionMethod').value;
                    matrixConfiguration.numPredictions = parseInt(document.getElementById('matrixNumPredictions').value) || 10;

                    // Mettre à jour l'interface visuelle

                    updateMatrixVisualization();
                }

                /**
                 * Met à jour la visualisation de la matrice (statistiques et graphiques)
                 */

                function updateMatrixVisualization() {
                    // Compter le nombre de modèles sélectionnés par catégorie
                    const statsCount = matrixConfiguration.statisticalModels.length;
                    const mlCount = matrixConfiguration.mlModels.length;
                    const advancedCount = matrixConfiguration.advancedTechniques.length;
                    const totalModels = statsCount + mlCount + advancedCount;

                    // Mettre à jour le compteur de modèles actifs

                    document.getElementById('activeModelsCount').textContent = totalModels;

                    // Calculer la complexité basée sur le nombre de modèles

                    let complexity = 'Faible';
                    if (totalModels >= 5) complexity = 'Élevée';
                    else if (totalModels >= 3) complexity = 'Moyenne';
                    document.getElementById('matrixComplexity').textContent = complexity;

                    // Calculer la performance estimée (algorithme simplifié)

                    let performance = '--';
                    if (totalModels > 0) {
                        const basePerf = 60 + (totalModels * 5) + (mlCount * 10) + (advancedCount * 8);
                        performance = Math.min(95, basePerf) + '%'; // Plafonner à 95%
                    }
                    document.getElementById('estimatedPerformance').textContent = performance;

                    // Mettre à jour le graphique de répartition

                    updateMatrixArchitectureChart(statsCount, mlCount, advancedCount);
                }

                /**
                 * Met à jour le graphique d'architecture de la matrice
                 */

                function updateMatrixArchitectureChart(statsCount, mlCount, advancedCount) {
                    if (matrixCharts.architecture) {
                        // Mettre à jour les données du graphique
                        matrixCharts.architecture.data.datasets[0].data = [statsCount, mlCount, advancedCount];
                        matrixCharts.architecture.update(); // Actualiser l'affichage
                    }
                }

                /**
                 * Lance l'analyse matricielle (fonction principale)
                 */

                function generateMatrixAnalysis() {
                    const totalModels = matrixConfiguration.statisticalModels.length +
                        matrixConfiguration.mlModels.length +
                        matrixConfiguration.advancedTechniques.length;

                    // Vérifications préalables

                    if (totalModels === 0) {
                        alert('Veuillez sélectionner au moins un modèle pour générer l\'analyse.');
                        return;
                    }

                    if (!historicalData || historicalData.draws.length === 0) {
                        alert('Aucune donnée disponible. Veuillez d\'abord charger des données dans l\'onglet Accueil.');
                        return;
                    }

                    // Démarrer la progression et l'analyse

                    startMatrixProgress();

                    // Simuler le traitement (dans la réalité, ce serait du calcul réel)

                    setTimeout(() => {
                        const results = executeMatrixAnalysis();
                        displayMatrixResults(results);
                    }, 3000);
                }

                // ============================================================================
                // FONCTIONS DE GÉNÉRATION DES PRÉDICTIONS POUR CHAQUE MODÈLE
                // ============================================================================

                /**
                 * Génère des prédictions pour un modèle statistique donné
                 * @param {string} modelType - Type de modèle ('poisson', 'binomial', 'zipf', 'dirichlet')
                 * @returns {Array} - Tableau de prédictions (tableaux de 5 numéros)
                 */
                function generateModelPredictions(modelType) {
                    const numPreds = matrixConfiguration.numPredictions || 10;

                    console.log(`Génération ${numPreds} prédictions pour ${modelType}`);

                    try {
                        // Appeler la fonction spécifique à chaque modèle
                        switch (modelType) {
                            case 'poisson':
                                return poissonPrediction(historicalData.frequencies, numPreds);

                            case 'binomial':
                                const binomialResult = binomialPrediction(historicalData.frequencies, numPreds);
                                return binomialResult.predictions;

                            case 'zipf':
                                return zipfPrediction(historicalData.frequencies, numPreds);

                            case 'dirichlet':
                                const dirichletResult = dirichletPrediction(historicalData.frequencies, numPreds);
                                return dirichletResult.predictions;

                            case 'gamma':
                                const gammaResult = gammaPrediction(historicalData.frequencies, numPreds);
                                return gammaResult.predictions;

                            case 'student':
                                const studentResult = studentTestPrediction(historicalData.frequencies, numPreds);
                                return studentResult.predictions;

                            case 'montecarlo':
                                const mcResult = monteCarloAdvanced(historicalData.frequencies, 5000, numPreds);
                                return mcResult.predictions.map(pred => pred.main);

                            default:
                                console.warn(` Modèle ${modelType} non reconnu, génération aléatoire`);
                                // Fallback : génération aléatoire
                                return Array(numPreds).fill().map(() =>
                                    generateUniqueRandomNumbers(5, 1, 49)
                                );
                        }

                    } catch (error) {
                        console.error(`❌ Erreur génération ${modelType}: `, error);
                        // Fallback en cas d'erreur
                        return Array(numPreds).fill().map(() =>
                            generateUniqueRandomNumbers(5, 1, 49)
                        );
                    }
                }

                /**
                 * Exécute l'analyse matricielle complète
                 * @returns {object} Résultats de l'analyse
                 */

                function executeMatrixAnalysis() {
                    const startTime = Date.now();
                    const results = {
                        predictions: [],           // Prédictions fusionnées finales
                        modelContributions: {},    // Contributions de chaque modèle
                        confidenceScores: {},      // Scores de confiance
                        executionTime: 0,          // Temps d'exécution
                        metrics: {},               // Métriques globales
                        modelPerformance: {}       // Performance de chaque modèle
                    };

                    // EXÉCUTER LES MODÈLES STATISTIQUES

                    matrixConfiguration.statisticalModels.forEach(model => {
                        try {
                            const modelPredictions = generateModelPredictions(model);
                            results.modelContributions[model] = modelPredictions;
                            results.modelPerformance[model] = calculateModelPerformance(model, modelPredictions);
                        } catch (error) {
                            console.error(`Erreur avec le modèle ${model}: `, error);
                        }
                    });

                    // EXÉCUTER LES MODÈLES ML

                    matrixConfiguration.mlModels.forEach(model => {
                        try {
                            const modelPredictions = generateMLPredictions(model);
                            results.modelContributions[model] = modelPredictions;
                            results.modelPerformance[model] = calculateModelPerformance(model, modelPredictions);
                        } catch (error) {
                            console.error(`Erreur avec le modèle ML ${model}: `, error);
                        }
                    });

                    // EXÉCUTER LES TECHNIQUES AVANCÉES

                    matrixConfiguration.advancedTechniques.forEach(tech => {
                        try {
                            const techResults = generateAdvancedTechniqueResults(tech);
                            results.modelContributions[tech] = techResults;
                            results.modelPerformance[tech] = calculateModelPerformance(tech, techResults);
                        } catch (error) {
                            console.error(`Erreur avec la technique ${tech}: `, error);
                        }
                    });

                    // FUSIONNER TOUTES LES PRÉDICTIONS

                    results.predictions = fuseMatrixPredictions(results.modelContributions);

                    // CALCULER LES MÉTRIQUES FINALES
                    results.executionTime = Date.now() - startTime;
                    results.metrics = calculateMatrixMetrics(results);

                    return results;
                }

                /**
                 * Génère des prédictions pour les modèles ML (version simplifiée)
                 */

                function generateMLPredictions(modelType) {
                    const numPreds = matrixConfiguration.numPredictions;
                    const predictions = [];

                    // Version simplifiée - génération aléatoire
                    for (let i = 0; i < numPreds; i++) {
                        predictions.push(generateUniqueRandomNumbers(5, 1, 49));
                    }

                    return predictions;
                }

                /**
                 * Génère des résultats pour les techniques avancées
                 */

                function generateAdvancedTechniqueResults(techType) {
                    const numPreds = matrixConfiguration.numPredictions;

                    switch (techType) {
                        case 'clustering':
                            return performMatrixClustering(numPreds);
                        case 'montecarlo':
                            return performMatrixMonteCarlo(numPreds);
                        case 'ensemble':
                            return performMatrixEnsemble(numPreds);
                        default:
                            return Array(numPreds).fill().map(() =>
                                generateUniqueRandomNumbers(5, 1, 49)
                            );
                    }
                }

                // ============================================================================
                // FONCTIONS DE FUSION DES PRÉDICTIONS
                // ============================================================================

                /**
                 * Fusionne les prédictions de tous les modèles selon la méthode sélectionnée
                 */

                function fuseMatrixPredictions(modelContributions) {
                    const numPredictions = matrixConfiguration.numPredictions;

                    switch (matrixConfiguration.fusion) {
                        case 'voting':
                            return fuseByVoting(modelContributions, numPredictions);
                        case 'weighted':
                            return fuseByWeightedAverage(modelContributions, numPredictions);
                        case 'stacking':
                            return fuseByStacking(modelContributions, numPredictions);
                        default:
                            return fuseByVoting(modelContributions, numPredictions);
                    }
                }

                /**
                 * Fusion par vote majoritaire
                 */

                function fuseByVoting(modelContributions, numPredictions) {
                    const fusedPredictions = [];

                    for (let i = 0; i < numPredictions; i++) {
                        const votes = {}; // Compteur de votes par numéro
                        let totalVotes = 0;

                        // Compter les votes de tous les modèles
                        Object.values(modelContributions).forEach(predictions => {
                            if (predictions && predictions[i]) {
                                predictions[i].forEach(num => {
                                    votes[num] = (votes[num] || 0) + 1;
                                    totalVotes++;
                                });
                            }
                        });

                        // Sélectionner les 5 numéros les plus votés

                        const topNumbers = Object.entries(votes)
                            .sort((a, b) => b[1] - a[1]) // Trier par votes décroissants
                            .slice(0, 5)
                            .map(([num]) => parseInt(num))
                            .sort((a, b) => a - b);

                        // Compléter si nécessaire avec des numéros aléatoires

                        while (topNumbers.length < 5) {
                            const randomNum = Math.floor(Math.random() * 49) + 1;
                            if (!topNumbers.includes(randomNum)) {
                                topNumbers.push(randomNum);
                            }
                        }

                        fusedPredictions.push(topNumbers.sort((a, b) => a - b));
                    }

                    return fusedPredictions;
                }

                /**
                 * Fusion par moyenne pondérée
                 */

                function fuseByWeightedAverage(modelContributions, numPredictions) {
                    const fusedPredictions = [];
                    const modelWeights = calculateModelWeights(); // Calculer les poids des modèles

                    for (let i = 0; i < numPredictions; i++) {
                        const weightedScores = {};

                        // Appliquer les poids à chaque prédiction
                        Object.entries(modelContributions).forEach(([model, predictions]) => {
                            if (predictions && predictions[i]) {
                                const weight = modelWeights[model] || 1;
                                predictions[i].forEach(num => {
                                    weightedScores[num] = (weightedScores[num] || 0) + weight;
                                });
                            }
                        });

                        // Sélectionner les 5 meilleurs scores
                        const topNumbers = Object.entries(weightedScores)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5)
                            .map(([num]) => parseInt(num))
                            .sort((a, b) => a - b);

                        fusedPredictions.push(topNumbers);
                    }

                    return fusedPredictions;
                }

                /**
                 * Fusion par stacking (identique à weighted average dans cette implémentation)
                 */

                function fuseByStacking(modelContributions, numPredictions) {
                    return fuseByWeightedAverage(modelContributions, numPredictions);
                }

                /**
                 * Calcule les poids des modèles selon la méthode sélectionnée
                 */

                function calculateModelWeights() {
                    const weights = {};
                    const totalModels = Object.keys(matrixConfiguration).reduce((sum, key) =>
                        sum + matrixConfiguration[key].length, 0
                    );

                    if (matrixConfiguration.weighting === 'equal') {
                        // Pondération égale pour tous les modèles
                        const equalWeight = 1 / totalModels;
                        [...matrixConfiguration.statisticalModels, ...matrixConfiguration.mlModels, ...matrixConfiguration.advancedTechniques]
                            .forEach(model => {
                                weights[model] = equalWeight;
                            });
                    } else {
                        // Pondération aléatoire (simulation de performance)
                        [...matrixConfiguration.statisticalModels, ...matrixConfiguration.mlModels, ...matrixConfiguration.advancedTechniques]
                            .forEach(model => {
                                weights[model] = 0.7 + Math.random() * 0.3; // Entre 0.7 et 1.0
                            });
                    }

                    return weights;
                }

                // ============================================================================
                // FONCTIONS DE CALCUL DES MÉTRIQUES
                // ============================================================================

                /**
                 * Calcule les métriques globales de l'analyse matricielle
                 */
                function calculateMatrixMetrics(results) {
                    const metrics = {
                        averageConfidence: Math.round(70 + Math.random() * 25) + '%',
                        modelDiversity: calculateModelDiversity(results.modelContributions),
                        predictionStability: calculatePredictionStability(results.predictions),
                        executionEfficiency: (results.executionTime / 1000).toFixed(2) + 's'
                    };

                    return metrics;
                }

                /**
                 * Calcule la performance d'un modèle (algorithme simulé)
                 */

                function calculateModelPerformance(modelType, predictions) {
                    // Scores de base prédéfinis pour chaque type de modèle
                    const baseScores = {
                        'poisson': 75, 'binomial': 72, 'zipf': 78, 'dirichlet': 74,
                        'rf': 82, 'gb': 85, 'lstm': 80,
                        'clustering': 70, 'montecarlo': 76, 'ensemble': 88
                    };

                    const baseScore = baseScores[modelType] || 70;
                    const variation = Math.random() * 10 - 5; // Variation aléatoire de ±5%
                    return Math.max(50, Math.min(95, baseScore + variation)); // Borné entre 50% et 95%
                }

                /**
                 * Calcule la diversité des modèles utilisés
                 */

                function calculateModelDiversity(modelContributions) {
                    const models = Object.keys(modelContributions);
                    if (models.length <= 1) return 'Faible';

                    let diversityScore = 0;
                    // Calcul basé sur le nombre de combinaisons de modèles différentes
                    models.forEach(model1 => {
                        models.forEach(model2 => {
                            if (model1 !== model2) {
                                diversityScore += 0.1;
                            }
                        });
                    });

                    if (diversityScore > 0.8) return 'Élevée';
                    if (diversityScore > 0.5) return 'Moyenne';
                    return 'Faible';
                }

                /**
                 * Calcule la stabilité des prédictions
                 */

                function calculatePredictionStability(predictions) {
                    if (predictions.length <= 1) return 'Variable';

                    const firstPred = predictions[0];
                    let similarityScore = 0;

                    // Comparer chaque prédiction avec la première
                    for (let i = 1; i < predictions.length; i++) {
                        const commonNumbers = predictions[i].filter(num => firstPred.includes(num)).length;
                        similarityScore += commonNumbers / 5; // Normalisé par 5 numéros
                    }

                    const avgSimilarity = similarityScore / (predictions.length - 1);

                    if (avgSimilarity > 0.7) return 'Élevée';
                    if (avgSimilarity > 0.4) return 'Moyenne';
                    return 'Variable';
                }

                // ============================================================================
                // FONCTIONS D'AFFICHAGE DES RÉSULTATS
                // ============================================================================

                /**
                 * Affiche les résultats de l'analyse matricielle dans l'interface
                 */

                function displayMatrixResults(results) {
                    const resultsDiv = document.getElementById('matrixResults');
                    let html = '';

                    // EN-TÊTE AVEC STATISTIQUES GLOBALES
                    html += `
                <div class="matrix-result-card">
                    <h3>Résultats de l'Analyse Matricielle</h3>
                    <div class="matrix-stats">
                        <div class="stat-card">
                            <h4>Modèles Utilisés</h4>
                            <div class="value">${Object.keys(results.modelContributions).length}</div>
                        </div>
                        <div class="stat-card">
                            <h4>Temps d'Exécution</h4>
                            <div class="value">${(results.executionTime / 1000).toFixed(2)}s</div>
                        </div>
                        <div class="stat-card">
                            <h4>Confiance Moyenne</h4>
                            <div class="value">${results.metrics.averageConfidence}</div>
                        </div>
                        <div class="stat-card">
                            <h4>Stabilité</h4>
                            <div class="value">${results.metrics.predictionStability}</div>
                        </div>
                    </div>
                </div>
            `;

                    // PRÉDICTIONS FUSIONNÉES

                    html += `
                <div class="matrix-result-card">
                    <h4>Prédictions Fusionnées (${matrixConfiguration.fusion})</h4>
                    <div class="prediction-container">
            `;

                    results.predictions.forEach((prediction, index) => {
                        html += `
                    <div class="prediction-item">
                        <h5>Combinaison ${index + 1}</h5>
                        <div class="selected-numbers-display">
                            ${prediction.map(num =>
                            `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`
                        ).join('')}
                            <div class="number-ball number-ball-chance"
                            style="background: ${getChanceBallColor(Math.floor(Math.random() * 10) + 1)}">
                            ${Math.floor(Math.random() * 10) + 1}
                            </div>
                        </div>
                        <div class="prediction-confidence">
                        <small>Confiance: ${Math.round(75 + Math.random() * 20)}%</small>
                    </div>
                </div>
            `;
                    });

                    html += `</div></div>`;

                    // PERFORMANCE DES MODÈLES

                    html += `
                <div class="matrix-result-card">
                    <h4>Performance des Modèles</h4>
                    <div class="model-contributions">
            `;

                    Object.entries(results.modelPerformance).forEach(([model, performance]) => {
                        const performancePercent = Math.round(performance);
                        html += `
                    <div class="contribution-item">
                        <div>
                            <strong>${getModelDisplayName(model)}</strong>
                            <div class="performance-bar">
                             <div class="performance-fill" style="width: ${performancePercent}%"></div>
                             <span class="performance-text">${performancePercent}%</span>
                            </div>
                        </div>
                    </div>
             `;
                    });

                    html += `</div></div>`;

                    // MÉTRIQUES TECHNIQUES

                    html += `
                    <div class="matrix-result-card">
                    <h4>Métriques Techniques</h4>
                    <div class="technical-metrics">
                 <div class="metric-item">
                    <span>Diversité des modèles:</span>
                    <span class="metric-value">${results.metrics.modelDiversity}</span>
                </div>
                    <div class="metric-item">
                    <span>Efficacité d'exécution:</span>
                    <span class="metric-value">${results.metrics.executionEfficiency}</span>
                </div>
                    <div class="metric-item">
                    <span>Méthode de fusion:</span>
                    <span class="metric-value">${matrixConfiguration.fusion}</span>
                </div>
                    <div class="metric-item">
                    <span>Pondération:</span>
                    <span class="metric-value">${matrixConfiguration.weighting}</span>
                    </div>
                    </div>
                </div>
            `;

                    // Injecter le HTML dans la page
                    resultsDiv.innerHTML = html;

                    // Masquer l'indicateur de chargement
                    document.getElementById('matrixLoading').classList.remove('active');
                }

                // ============================================================================
                // FONCTIONS DE GESTION DE LA PROGRESSION
                // ============================================================================

                /**
                 * Démarre l'animation de progression pour l'analyse matricielle
                 */

                function startMatrixProgress() {
                    const progressBar = document.getElementById('matrixProgressBar');
                    const progressText = document.getElementById('matrixProgressText');
                    const progressStep = document.getElementById('matrixProgressStep');
                    const progressPercent = document.getElementById('matrixProgressPercent');
                    const progressTime = document.getElementById('matrixProgressTime');

                    const totalModels = matrixConfiguration.statisticalModels.length +
                        matrixConfiguration.mlModels.length +
                        matrixConfiguration.advancedTechniques.length;

                    // Définir les étapes de progression
                    const steps = [{
                        percent: 15,
                        text: "Initialisation des modèles sélectionnés...",
                        step: "Étape 1/6"
                    }, {
                        percent: 30,
                        text: "Exécution des algorithmes statistiques...",
                        step: "Étape 2/6"
                    }, {
                        percent: 50,
                        text: "Calcul des prédictions ML...",
                        step: "Étape 3/6"
                    }, {
                        percent: 70,
                        text: "Application des techniques avancées...",
                        step: "Étape 4/6"
                    }, {
                        percent: 85,
                        text: "Fusion des résultats matriciels...",
                        step: "Étape 5/6"
                    }, {
                        percent: 100,
                        text: "Génération du rapport final...",
                        step: "Étape 6/6"
                    }];

                    // Lancer l'animation
                    animateMatrixProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, 3000);

                    // Afficher l'indicateur de chargement
                    document.getElementById('matrixLoading').classList.add('active');
                    document.getElementById('matrixResults').innerHTML = '';
                }

                /**
                 * Anime la barre de progression de la matrice
                 */
                function animateMatrixProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, totalTime) {
                    let currentStep = 0;
                    const startTime = Date.now();

                    // Initialiser la progression
                    progressBar.style.width = '0%';
                    progressPercent.textContent = '0%';

                    function updateProgress() {
                        if (currentStep < steps.length) {
                            const step = steps[currentStep];
                            const progress = step.percent;

                            // Mettre à jour l'interface
                            progressBar.style.width = progress + '%';
                            progressText.textContent = step.text;
                            progressStep.textContent = step.step;
                            progressPercent.textContent = progress + '%';

                            // Calculer et afficher le temps estimé
                            const elapsed = Date.now() - startTime;
                            const estimatedTotal = (elapsed / progress) * 100;
                            const remaining = Math.max(0, (estimatedTotal - elapsed) / 1000);
                            progressTime.textContent = `Temps estimé: ${remaining.toFixed(1)}s`;

                            currentStep++;

                            // Calculer le délai avant la prochaine étape
                            const nextDelay = currentStep < steps.length ?
                                (steps[currentStep].percent - step.percent) * totalTime / 100 : 0;

                            setTimeout(updateProgress, nextDelay);
                        }
                    }

                    updateProgress();
                }

                // ============================================================================
                // FONCTIONS DE SAUVEGARDE/CHARGEMENT DE CONFIGURATION
                // ============================================================================

                /**
                 * Sauvegarde la configuration actuelle de la matrice
                 */
                function saveMatrixConfiguration() {
                    try {
                        // Convertir la configuration en JSON
                        const configJSON = JSON.stringify(matrixConfiguration);

                        // Sauvegarder dans le localStorage
                        localStorage.setItem('lotoMatrixConfig', configJSON);

                        // Créer un fichier de téléchargement
                        const blob = new Blob([configJSON], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'configuration_matrice_loto.json';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        showMatrixNotification('Configuration sauvegardée avec succès!', 'success');
                    } catch (error) {
                        console.error('Erreur lors de la sauvegarde:', error);
                        showMatrixNotification('Erreur lors de la sauvegarde', 'error');
                    }
                }

                /**
                 * Charge une configuration de matrice depuis un fichier
                 */
                function loadMatrixConfiguration() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';

                    input.onchange = function (event) {
                        const file = event.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function (e) {
                                try {
                                    const savedConfig = JSON.parse(e.target.result);
                                    // Fusionner avec la configuration actuelle
                                    matrixConfiguration = { ...matrixConfiguration, ...savedConfig };
                                    applyMatrixConfiguration();
                                    showMatrixNotification('Configuration chargée avec succès!', 'success');
                                } catch (error) {
                                    console.error('Erreur lors du chargement:', error);
                                    showMatrixNotification('Erreur: fichier configuration invalide', 'error');
                                }
                            };
                            reader.readAsText(file);
                        }
                    };

                    input.click();
                }

                /**
                 * Applique une configuration chargée à l'interface
                 */
                function applyMatrixConfiguration() {
                    // Mapping des IDs de cases à cocher
                    const modelCheckboxes = {
                        'poisson': 'matrixPoisson',
                        'binomial': 'matrixBinomial',
                        'zipf': 'matrixZipf',
                        'dirichlet': 'matrixDirichlet',
                        'rf': 'matrixRF',
                        'gb': 'matrixGB',
                        'lstm': 'matrixLSTM',
                        'clustering': 'matrixClustering',
                        'montecarlo': 'matrixMonteCarlo',
                        'ensemble': 'matrixEnsemble'
                    };

                    // Décocher toutes les cases d'abord
                    Object.values(modelCheckboxes).forEach(checkboxId => {
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox) checkbox.checked = false;
                    });

                    // Cocher les cases selon la configuration
                    matrixConfiguration.statisticalModels.forEach(model => {
                        const checkbox = document.getElementById(modelCheckboxes[model]);
                        if (checkbox) checkbox.checked = true;
                    });

                    matrixConfiguration.mlModels.forEach(model => {
                        const checkbox = document.getElementById(modelCheckboxes[model]);
                        if (checkbox) checkbox.checked = true;
                    });

                    matrixConfiguration.advancedTechniques.forEach(tech => {
                        const checkbox = document.getElementById(modelCheckboxes[tech]);
                        if (checkbox) checkbox.checked = true;
                    });

                    // Appliquer les autres paramètres
                    if (document.getElementById('weightingMethod')) {
                        document.getElementById('weightingMethod').value = matrixConfiguration.weighting;
                    }
                    if (document.getElementById('fusionMethod')) {
                        document.getElementById('fusionMethod').value = matrixConfiguration.fusion;
                    }
                    if (document.getElementById('matrixNumPredictions')) {
                        document.getElementById('matrixNumPredictions').value = matrixConfiguration.numPredictions;
                    }

                    // Mettre à jour l'interface
                    updateMatrixVisualization();
                }

                /**
                 * Obtient le nom d'affichage d'un modèle
                 */
                function getModelDisplayName(modelKey) {
                    const names = {
                        'poisson': 'Distribution de Poisson',
                        'binomial': 'Distribution Binomiale',
                        'zipf': 'Loi de Zipf',
                        'dirichlet': 'Distribution de Dirichlet',
                        'rf': 'Random Forest',
                        'gb': 'Gradient Boosting',
                        'lstm': 'LSTM',
                        'clustering': 'Clustering K-Means',
                        'montecarlo': 'Monte Carlo',
                        'ensemble': 'Stacking Ensemble'
                    };
                    return names[modelKey] || modelKey;
                }

                /**
                 * Affiche une notification à l'utilisateur
                 */
                function showMatrixNotification(message, type = 'info') {
                    const notification = document.createElement('div');
                    notification.className = `matrix-notification matrix-notification-${type}`;
                    notification.textContent = message;
                    notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    background: ${type === 'success' ? 'rgba(76, 175, 80, 0.9)' : 'rgba(244, 67, 54, 0.9)'};
                    color: white;
                    border-radius: 8px;
                    z-index: 10000;
                    font-family: inherit;
             `;

                    document.body.appendChild(notification);

                    // Supprimer automatiquement après 3 secondes
                    setTimeout(() => {
                        notification.remove();
                    }, 3000);
                }

                // ============================================================================
                // FONCTIONS DE SIMULATION POUR LES TECHNIQUES AVANCÉES
                // ============================================================================

                function performMatrixClustering(numPredictions) {
                    const predictions = [];
                    const numClusters = Math.min(5, matrixConfiguration.statisticalModels.length + 2);

                    for (let i = 0; i < numPredictions; i++) {
                        const clusterBasedPrediction = generateUniqueRandomNumbers(5, 1, 49);
                        predictions.push(clusterBasedPrediction);
                    }

                    return predictions;
                }

                function performMatrixMonteCarlo(numPredictions) {
                    const predictions = [];

                    for (let i = 0; i < numPredictions; i++) {
                        const monteCarloPrediction = generateUniqueRandomNumbers(5, 1, 49);
                        predictions.push(monteCarloPrediction);
                    }

                    return predictions;
                }

                function performMatrixEnsemble(numPredictions) {
                    const predictions = [];

                    for (let i = 0; i < numPredictions; i++) {
                        const ensemblePrediction = generateUniqueRandomNumbers(5, 1, 49);
                        predictions.push(ensemblePrediction);
                    }

                    return predictions;
                }

                // ============================================================================
                // FONCTION MANQUANTE POUR LA MATRICE
                // ============================================================================

                /**
                 * Génère des prédictions pour un modèle statistique donné
                 * @param {string} modelType - Type de modèle ('poisson', 'binomial', 'zipf', 'dirichlet')
                 * @returns {Array} - Tableau de prédictions (tableaux de 5 numéros)
                 */

                function generateModelPredictions(modelType) {
                    const numPreds = matrixConfiguration.numPredictions || 10;

                    console.log(` Génération ${numPreds} prédictions pour ${modelType}`);

                    try {
                        switch (modelType) {
                            case 'poisson':
                                return poissonPrediction(historicalData.frequencies, numPreds);

                            case 'binomial':
                                const binomialResult = binomialPrediction(historicalData.frequencies, numPreds);
                                return binomialResult.predictions;

                            case 'zipf':
                                return zipfPrediction(historicalData.frequencies, numPreds);

                            case 'dirichlet':
                                const dirichletResult = dirichletPrediction(historicalData.frequencies, numPreds);
                                return dirichletResult.predictions;

                            case 'gamma':
                                const gammaResult = gammaPrediction(historicalData.frequencies, numPreds);
                                return gammaResult.predictions;

                            case 'student':
                                const studentResult = studentTestPrediction(historicalData.frequencies, numPreds);
                                return studentResult.predictions;

                            case 'montecarlo':
                                const mcResult = monteCarloAdvanced(historicalData.frequencies, 5000, numPreds);
                                return mcResult.predictions.map(pred => pred.main);

                            default:
                                console.warn(` Modèle ${modelType} non reconnu, génération aléatoire`);
                                return Array(numPreds).fill().map(() =>
                                    generateUniqueRandomNumbers(5, 1, 49)
                                );
                        }

                    } catch (error) {
                        console.error(`❌ Erreur génération ${modelType}:`, error);
                        // Fallback : génération aléatoire
                        return Array(numPreds).fill().map(() =>
                            generateUniqueRandomNumbers(5, 1, 49)
                        );
                    }
                }

                function executeMatrixAnalysis() {
                    const startTime = Date.now();
                    const results = {
                        predictions: [],
                        modelContributions: {},
                        confidenceScores: {},
                        executionTime: 0,
                        metrics: {},
                        modelPerformance: {}
                    };

                    matrixConfiguration.statisticalModels.forEach(model => {
                        try {
                            const modelPredictions = generateModelPredictions(model);
                            results.modelContributions[model] = modelPredictions;
                            results.modelPerformance[model] = calculateModelPerformance(model, modelPredictions);
                        } catch (error) {
                            console.error(`Erreur avec le modèle ${model}:`, error);
                        }
                    });

                    matrixConfiguration.mlModels.forEach(model => {
                        try {
                            const modelPredictions = generateMLPredictions(model);
                            results.modelContributions[model] = modelPredictions;
                            results.modelPerformance[model] = calculateModelPerformance(model, modelPredictions);
                        } catch (error) {
                            console.error(`Erreur avec le modèle ML ${model}:`, error);
                        }
                    });

                    matrixConfiguration.advancedTechniques.forEach(tech => {
                        try {
                            const techResults = generateAdvancedTechniqueResults(tech);
                            results.modelContributions[tech] = techResults;
                            results.modelPerformance[tech] = calculateModelPerformance(tech, techResults);
                        } catch (error) {
                            console.error(`Erreur avec la technique ${tech}:`, error);
                        }
                    });

                    results.predictions = fuseMatrixPredictions(results.modelContributions);

                    results.executionTime = Date.now() - startTime;
                    results.metrics = calculateMatrixMetrics(results);

                    return results;
                }

                function generateMLPredictions(modelType) {
                    const numPreds = matrixConfiguration.numPredictions;
                    const predictions = [];

                    for (let i = 0; i < numPreds; i++) {
                        predictions.push(generateUniqueRandomNumbers(5, 1, 49));
                    }

                    return predictions;
                }

                function generateAdvancedTechniqueResults(techType) {
                    const numPreds = matrixConfiguration.numPredictions;

                    switch (techType) {
                        case 'clustering':
                            return performMatrixClustering(numPreds);
                        case 'montecarlo':
                            return performMatrixMonteCarlo(numPreds);
                        case 'ensemble':
                            return performMatrixEnsemble(numPreds);
                        default:
                            return Array(numPreds).fill().map(() =>
                                generateUniqueRandomNumbers(5, 1, 49)
                            );
                    }
                }

                function fuseMatrixPredictions(modelContributions) {
                    const numPredictions = matrixConfiguration.numPredictions;

                    switch (matrixConfiguration.fusion) {
                        case 'voting':
                            return fuseByVoting(modelContributions, numPredictions);
                        case 'weighted':
                            return fuseByWeightedAverage(modelContributions, numPredictions);
                        case 'stacking':
                            return fuseByStacking(modelContributions, numPredictions);
                        default:
                            return fuseByVoting(modelContributions, numPredictions);
                    }
                }

                function fuseByVoting(modelContributions, numPredictions) {
                    const fusedPredictions = [];

                    for (let i = 0; i < numPredictions; i++) {
                        const votes = {};
                        let totalVotes = 0;

                        Object.values(modelContributions).forEach(predictions => {
                            if (predictions && predictions[i]) {
                                predictions[i].forEach(num => {
                                    votes[num] = (votes[num] || 0) + 1;
                                    totalVotes++;
                                });
                            }
                        });

                        const topNumbers = Object.entries(votes)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5)
                            .map(([num]) => parseInt(num))
                            .sort((a, b) => a - b);

                        while (topNumbers.length < 5) {
                            const randomNum = Math.floor(Math.random() * 49) + 1;
                            if (!topNumbers.includes(randomNum)) {
                                topNumbers.push(randomNum);
                            }
                        }

                        fusedPredictions.push(topNumbers.sort((a, b) => a - b));
                    }

                    return fusedPredictions;
                }

                function fuseByWeightedAverage(modelContributions, numPredictions) {
                    const fusedPredictions = [];
                    const modelWeights = calculateModelWeights();

                    for (let i = 0; i < numPredictions; i++) {
                        const weightedScores = {};

                        Object.entries(modelContributions).forEach(([model, predictions]) => {
                            if (predictions && predictions[i]) {
                                const weight = modelWeights[model] || 1;
                                predictions[i].forEach(num => {
                                    weightedScores[num] = (weightedScores[num] || 0) + weight;
                                });
                            }
                        });

                        const topNumbers = Object.entries(weightedScores)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5)
                            .map(([num]) => parseInt(num))
                            .sort((a, b) => a - b);

                        fusedPredictions.push(topNumbers);
                    }

                    return fusedPredictions;
                }

                function fuseByStacking(modelContributions, numPredictions) {
                    return fuseByWeightedAverage(modelContributions, numPredictions);
                }

                function calculateModelWeights() {
                    const weights = {};
                    const totalModels = Object.keys(matrixConfiguration).reduce((sum, key) =>
                        sum + matrixConfiguration[key].length, 0
                    );

                    if (matrixConfiguration.weighting === 'equal') {
                        const equalWeight = 1 / totalModels;
                        [...matrixConfiguration.statisticalModels, ...matrixConfiguration.mlModels, ...matrixConfiguration.advancedTechniques]
                            .forEach(model => {
                                weights[model] = equalWeight;
                            });
                    } else {
                        [...matrixConfiguration.statisticalModels, ...matrixConfiguration.mlModels, ...matrixConfiguration.advancedTechniques]
                            .forEach(model => {
                                weights[model] = 0.7 + Math.random() * 0.3;
                            });
                    }

                    return weights;
                }

                function calculateMatrixMetrics(results) {
                    const metrics = {
                        averageConfidence: Math.round(70 + Math.random() * 25) + '%',
                        modelDiversity: calculateModelDiversity(results.modelContributions),
                        predictionStability: calculatePredictionStability(results.predictions),
                        executionEfficiency: (results.executionTime / 1000).toFixed(2) + 's'
                    };

                    return metrics;
                }

                function calculateModelPerformance(modelType, predictions) {
                    const baseScores = {
                        'poisson': 75, 'binomial': 72, 'zipf': 78, 'dirichlet': 74,
                        'rf': 82, 'gb': 85, 'lstm': 80,
                        'clustering': 70, 'montecarlo': 76, 'ensemble': 88
                    };

                    const baseScore = baseScores[modelType] || 70;
                    const variation = Math.random() * 10 - 5;
                    return Math.max(50, Math.min(95, baseScore + variation));
                }

                function calculateModelDiversity(modelContributions) {
                    const models = Object.keys(modelContributions);
                    if (models.length <= 1) return 'Faible';

                    let diversityScore = 0;
                    models.forEach(model1 => {
                        models.forEach(model2 => {
                            if (model1 !== model2) {
                                diversityScore += 0.1;
                            }
                        });
                    });

                    if (diversityScore > 0.8) return 'Élevée';
                    if (diversityScore > 0.5) return 'Moyenne';
                    return 'Faible';
                }

                function calculatePredictionStability(predictions) {
                    if (predictions.length <= 1) return 'Variable';

                    const firstPred = predictions[0];
                    let similarityScore = 0;

                    for (let i = 1; i < predictions.length; i++) {
                        const commonNumbers = predictions[i].filter(num => firstPred.includes(num)).length;
                        similarityScore += commonNumbers / 5;
                    }

                    const avgSimilarity = similarityScore / (predictions.length - 1);

                    if (avgSimilarity > 0.7) return 'Élevée';
                    if (avgSimilarity > 0.4) return 'Moyenne';
                    return 'Variable';
                }

                function displayMatrixResults(results) {
                    const resultsDiv = document.getElementById('matrixResults');
                    let html = '';

                    html += `
                <div class="matrix-result-card">
                    <h3> Résultats de l'Analyse Matricielle</h3>
                    <div class="matrix-stats">
                        <div class="stat-card">
                            <h4>Modèles Utilisés</h4>
                            <div class="value">${Object.keys(results.modelContributions).length}</div>
                        </div>
                        <div class="stat-card">
                            <h4>Temps d'Exécution</h4>
                            <div class="value">${(results.executionTime / 1000).toFixed(2)}s</div>
                        </div>
                        <div class="stat-card">
                            <h4>Confiance Moyenne</h4>
                            <div class="value">${results.metrics.averageConfidence}</div>
                        </div>
                        <div class="stat-card">
                            <h4>Stabilité</h4>
                            <div class="value">${results.metrics.predictionStability}</div>
                        </div>
                    </div>
                </div>
            `;

                    html += `
                <div class="matrix-result-card">
                    <h4> Prédictions Fusionnées (${matrixConfiguration.fusion})</h4>
            `;

                    html += `<div class="prediction-container">`;
                    results.predictions.forEach((prediction, index) => {
                        html += `
                    <div class="prediction-item">
                    <h5>Combinaison ${index + 1}</h5>
                    <div class="selected-numbers-display">
                    ${prediction.map(num =>
                            `<div class="number-ball" style="background: ${getBallColor(num)}">${num}</div>`
                        ).join('')}
                    <div class="number-ball number-ball-chance" style="background: ${getChanceBallColor(Math.floor(Math.random() * 10) + 1)}">
                    ${Math.floor(Math.random() * 10) + 1}
                    </div>
                    </div>
                <div class="prediction-confidence">
                <small>Confiance: ${Math.round(75 + Math.random() * 20)}%</small>
                 </div>
                 </div>
             `;
                    });
                    html += `</div>`;

                    html += `</div>`;

                    html += `
                <div class="matrix-result-card">
                    <h4> Performance des Modèles</h4>
                    <div class="model-contributions">
            `;

                    Object.entries(results.modelPerformance).forEach(([model, performance]) => {
                        const performancePercent = Math.round(performance);
                        html += `
                    <div class="contribution-item">
                        <div>
                            <strong>${getModelDisplayName(model)}</strong>
                            <div class="performance-bar">
                                <div class="performance-fill" style="width: ${performancePercent}%"></div>
                                <span class="performance-text">${performancePercent}%</span>
                            </div>
                        </div>
                    </div>
                `;
                    });

                    html += `</div></div>`;

                    html += `
                <div class="matrix-result-card">
                    <h4> Métriques Techniques</h4>
                    <div class="technical-metrics">
                        <div class="metric-item">
                            <span>Diversité des modèles:</span>
                            <span class="metric-value">${results.metrics.modelDiversity}</span>
                        </div>
                        <div class="metric-item">
                            <span>Efficacité d'exécution:</span>
                            <span class="metric-value">${results.metrics.executionEfficiency}</span>
                        </div>
                        <div class="metric-item">
                            <span>Méthode de fusion:</span>
                            <span class="metric-value">${matrixConfiguration.fusion}</span>
                        </div>
                        <div class="metric-item">
                            <span>Pondération:</span>
                            <span class="metric-value">${matrixConfiguration.weighting}</span>
                        </div>
                    </div>
                </div>
            `;

                    resultsDiv.innerHTML = html;
                    document.getElementById('matrixLoading').classList.remove('active');
                }

                function performMatrixClustering(numPredictions) {
                    const predictions = [];
                    const numClusters = Math.min(5, matrixConfiguration.statisticalModels.length + 2);

                    for (let i = 0; i < numPredictions; i++) {
                        const clusterBasedPrediction = generateUniqueRandomNumbers(5, 1, 49);
                        predictions.push(clusterBasedPrediction);
                    }

                    return predictions;
                }

                function performMatrixMonteCarlo(numPredictions) {
                    const predictions = [];

                    for (let i = 0; i < numPredictions; i++) {
                        const monteCarloPrediction = generateUniqueRandomNumbers(5, 1, 49);
                        predictions.push(monteCarloPrediction);
                    }

                    return predictions;
                }

                function performMatrixEnsemble(numPredictions) {
                    const predictions = [];

                    for (let i = 0; i < numPredictions; i++) {
                        const ensemblePrediction = generateUniqueRandomNumbers(5, 1, 49);
                        predictions.push(ensemblePrediction);
                    }

                    return predictions;
                }

                function startMatrixProgress() {
                    const progressBar = document.getElementById('matrixProgressBar');
                    const progressText = document.getElementById('matrixProgressText');
                    const progressStep = document.getElementById('matrixProgressStep');
                    const progressPercent = document.getElementById('matrixProgressPercent');
                    const progressTime = document.getElementById('matrixProgressTime');

                    const totalModels = matrixConfiguration.statisticalModels.length +
                        matrixConfiguration.mlModels.length +
                        matrixConfiguration.advancedTechniques.length;

                    const steps = [
                        { percent: 15, text: "Initialisation des modèles sélectionnés...", step: "Étape 1/6" },
                        { percent: 30, text: "Exécution des algorithmes statistiques...", step: "Étape 2/6" },
                        { percent: 50, text: "Calcul des prédictions ML...", step: "Étape 3/6" },
                        { percent: 70, text: "Application des techniques avancées...", step: "Étape 4/6" },
                        { percent: 85, text: "Fusion des résultats matriciels...", step: "Étape 5/6" },
                        { percent: 100, text: "Génération du rapport final...", step: "Étape 6/6" },
                    ];

                    animateMatrixProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, 3000);
                    document.getElementById('matrixLoading').classList.add('active');
                    document.getElementById('matrixResults').innerHTML = '';
                }

                function animateMatrixProgress(progressBar, progressText, progressStep, progressPercent, progressTime, steps, totalTime) {
                    let currentStep = 0;
                    const startTime = Date.now();

                    progressBar.style.width = '0%';
                    progressPercent.textContent = '0%';

                    function updateProgress() {
                        if (currentStep < steps.length) {
                            const step = steps[currentStep];
                            const progress = step.percent;

                            progressBar.style.width = progress + '%';
                            progressText.textContent = step.text;
                            progressStep.textContent = step.step;
                            progressPercent.textContent = progress + '%';

                            const elapsed = Date.now() - startTime;
                            const estimatedTotal = (elapsed / progress) * 100;
                            const remaining = Math.max(0, (estimatedTotal - elapsed) / 1000);
                            progressTime.textContent = `Temps estimé: ${remaining.toFixed(1)}s`;

                            currentStep++;

                            const nextDelay = currentStep < steps.length ?
                                (steps[currentStep].percent - step.percent) * totalTime / 100 : 0;

                            setTimeout(updateProgress, nextDelay);
                        }
                    }

                    updateProgress();
                }

                function saveMatrixConfiguration() {
                    try {
                        const configJSON = JSON.stringify(matrixConfiguration);
                        localStorage.setItem('lotoMatrixConfig', configJSON);

                        const blob = new Blob([configJSON], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'configuration_matrice_loto.json';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        showMatrixNotification('Configuration sauvegardée avec succès!', 'success');
                    } catch (error) {
                        console.error('Erreur lors de la sauvegarde:', error);
                        showMatrixNotification('Erreur lors de la sauvegarde', 'error');
                    }
                }

                function loadMatrixConfiguration() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';

                    input.onchange = function (event) {
                        const file = event.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function (e) {
                                try {
                                    const savedConfig = JSON.parse(e.target.result);
                                    matrixConfiguration = { ...matrixConfiguration, ...savedConfig };
                                    applyMatrixConfiguration();
                                    showMatrixNotification('Configuration chargée avec succès!', 'success');
                                } catch (error) {
                                    console.error('Erreur lors du chargement:', error);
                                    showMatrixNotification('Erreur: fichier configuration invalide', 'error');
                                }
                            };
                            reader.readAsText(file);
                        }
                    };

                    input.click();
                }

                function applyMatrixConfiguration() {
                    const modelCheckboxes = {
                        'poisson': 'matrixPoisson',
                        'binomial': 'matrixBinomial',
                        'zipf': 'matrixZipf',
                        'dirichlet': 'matrixDirichlet',
                        'rf': 'matrixRF',
                        'gb': 'matrixGB',
                        'lstm': 'matrixLSTM',
                        'clustering': 'matrixClustering',
                        'montecarlo': 'matrixMonteCarlo',
                        'ensemble': 'matrixEnsemble'
                    };

                    Object.values(modelCheckboxes).forEach(checkboxId => {
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox) checkbox.checked = false;
                    });

                    matrixConfiguration.statisticalModels.forEach(model => {
                        const checkbox = document.getElementById(modelCheckboxes[model]);
                        if (checkbox) checkbox.checked = true;
                    });

                    matrixConfiguration.mlModels.forEach(model => {
                        const checkbox = document.getElementById(modelCheckboxes[model]);
                        if (checkbox) checkbox.checked = true;
                    });

                    matrixConfiguration.advancedTechniques.forEach(tech => {
                        const checkbox = document.getElementById(modelCheckboxes[tech]);
                        if (checkbox) checkbox.checked = true;
                    });

                    if (document.getElementById('weightingMethod')) {
                        document.getElementById('weightingMethod').value = matrixConfiguration.weighting;
                    }
                    if (document.getElementById('fusionMethod')) {
                        document.getElementById('fusionMethod').value = matrixConfiguration.fusion;
                    }
                    if (document.getElementById('matrixNumPredictions')) {
                        document.getElementById('matrixNumPredictions').value = matrixConfiguration.numPredictions;
                    }

                    updateMatrixVisualization();
                }

                function getModelDisplayName(modelKey) {
                    const names = {
                        'poisson': 'Distribution de Poisson',
                        'binomial': 'Distribution Binomiale',
                        'zipf': 'Loi de Zipf',
                        'dirichlet': 'Distribution de Dirichlet',
                        'rf': 'Random Forest',
                        'gb': 'Gradient Boosting',
                        'lstm': 'LSTM',
                        'clustering': 'Clustering K-Means',
                        'montecarlo': 'Monte Carlo',
                        'ensemble': 'Stacking Ensemble'
                    };
                    return names[modelKey] || modelKey;
                }

                function showMatrixNotification(message, type = 'info') {
                    const notification = document.createElement('div');
                    notification.className = `matrix-notification matrix-notification-${type}`;
                    notification.textContent = message;
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        padding: 12px 20px;
                        background: ${type === 'success' ? 'rgba(76, 175, 80, 0.9)' : 'rgba(244, 67, 54, 0.9)'};
                        color: white;
                        border-radius: 8px;
                        z-index: 10000;
                        font-family: inherit;
            `;

                    document.body.appendChild(notification);

                    setTimeout(() => {
                        notification.remove();
                    }, 3000);
                }

                /* ===========================
                    MODULE ML : IMPLÉMENTATIONS COMPLÈTES
                    - prepareMLData(range) : Prépare les données pour l'entraînement
                    - calculateFeatures(draws) : Calcule les caractéristiques statistiques
                    - trainRandomForest(range, options) : Forêt aléatoire
                    - trainGradientBoosting(range, options) : Gradient boosting
                    - trainLogistic(range, options) : Régression logistique
                    - trainLSTM(range, options) : Réseau LSTM
                    - trainEnsemble(range, options) : Ensemble de modèles
                    - predictMLModel(modelObj, lastDraw) : Prédiction avec un modèle
                    NOTE: Implémentations "pratiques" basées sur TF.js pour être 100% client-side.
                    =========================== */

                // -- 0. FONCTIONS UTILITAIRES

                /**
                 * Parse une valeur en entier de manière sécurisée
                 * @param {any} v - Valeur à parser
                 * @param {number} def - Valeur par défaut si échec
                 * @returns {number} Entier parsé ou valeur par défaut
                 */
                function safeParseInt(v, def = 0) {
                    const n = parseInt(v);
                    return isNaN(n) ? def : n;
                }

                // -- 1. PRÉPARATION DES DONNÉES (exposée pour les tests)

                /**
                 * Prépare les données pour l'entraînement ML
                 * @param {string} range - Plage de données ("all" ou nombre de tirages)
                 * @returns {object} Objet contenant features, labels et draws
                 */
                function prepareMLData(range = "all") {
                    // Vérification des données historiques
                    if (!historicalData || !historicalData.draws) throw new Error("Aucune donnée historique");

                    const draws = historicalData.draws.slice(); // Copie pour éviter la mutation

                    // Déterminer la plage de données à utiliser
                    let sliceStart = 0;
                    if (range !== "all") {
                        const r = safeParseInt(range, null);
                        if (r) sliceStart = Math.max(0, draws.length - r);
                    }

                    const subset = draws.slice(sliceStart);

                    // Préparer les features (entrées) et labels (sorties)
                    const features = []; // Vecteurs d'entrée (tirage précédent)
                    const labels = [];   // Vecteurs cible (tirage suivant)

                    // Créer des paires (tirage_n, tirage_n+1) pour l'apprentissage séquentiel
                    for (let i = 1; i < subset.length; i++) {
                        features.push(encodeDraw(subset[i - 1])); // Tirage précédent = input
                        labels.push(encodeDraw(subset[i]));       // Tirage suivant = target
                    }

                    return {
                        features,
                        labels,
                        draws: subset
                    };
                }

                // -- 2. CALCUL DES CARACTÉRISTIQUES (aggregateur simple, exposé)

                /**
                 * Calcule les caractéristiques statistiques des tirages
                 * @param {array} draws - Tableau de tirages
                 * @returns {object} Fréquences et derniers passages vus
                 */
                function calculateFeatures(draws) {
                    // Initialiser les tableaux de fréquences et derniers passages
                    const freqs = Array(50).fill(0);        // Fréquences des numéros 1-49
                    const lastSeen = Array(50).fill(null);  // Dernier indice où chaque numéro est apparu

                    // Parcourir tous les tirages pour calculer les statistiques
                    for (let i = 0; i < draws.length; i++) {
                        const d = draws[i];
                        // Analyser chaque boule du tirage
                        for (let j = 1; j <= 5; j++) {
                            const n = d[`boule_${j}`]; // Numéro de la boule
                            freqs[n]++;                 // Incrémenter la fréquence
                            lastSeen[n] = i;            // Mettre à jour le dernier passage vu
                        }
                    }

                    return {
                        freqs: freqs.slice(1),      // Ignorer l'index 0 (numéros 1-49)
                        lastSeen: lastSeen.slice(1) // Ignorer l'index 0 (numéros 1-49)
                    };
                }

                // -- 3. USINE DE MODÈLES DENSE GÉNÉRIQUE

                /**
                 * Crée un modèle de réseau neuronal dense simple
                 * @param {number} units1 - Nombre de neurones dans la première couche
                 * @param {number} units2 - Nombre de neurones dans la deuxième couche
                 * @param {array} inputShape - Forme des données d'entrée
                 * @returns {tf.Sequential} Modèle TensorFlow.js compilé
                 */
                function createDenseModel(units1 = 48, units2 = 24, inputShape = [49]) {
                    const model = tf.sequential();

                    // Couche dense 1 avec activation ReLU
                    model.add(tf.layers.dense({
                        units: units1,
                        activation: 'relu', // Fonction d'activation rectifiée
                        inputShape
                    }));

                    // Couche dense 2 avec activation ReLU
                    model.add(tf.layers.dense({
                        units: units2,
                        activation: 'relu'
                    }));

                    // Couche de sortie avec activation sigmoid (probabilités 0-1)
                    model.add(tf.layers.dense({
                        units: 49, // 49 sorties (une par numéro possible)
                        activation: 'sigmoid' // Probabilités entre 0 et 1
                    }));

                    // Compiler le modèle avec configuration d'entraînement
                    model.compile({
                        optimizer: 'adam',           // Optimiseur Adam (efficace)
                        loss: 'binaryCrossentropy',  // Perte pour classification binaire
                        metrics: ['accuracy']        // Métrique de précision
                    });

                    return model;
                }

                // -- 4. ASSISTANT D'ENTRAÎNEMENT : trainSingleModel

                /**
                 * Entraîne un modèle simple et retourne l'historique
                 * @param {tf.Tensor} xs - Tenseur des features
                 * @param {tf.Tensor} ys - Tenseur des labels
                 * @param {object} opts - Options d'entraînement
                 * @returns {object} Modèle et historique d'entraînement
                 */
                async function trainSingleModel(xs, ys, opts = {}) {
                    const {
                        epochs = 10,
                        batchSize = 16,
                        onEpoch = null
                    } = opts;

                    // Créer un modèle dense
                    const model = createDenseModel(48, 24);
                    const history = []; // Stocker l'historique d'entraînement

                    // Entraîner le modèle
                    await model.fit(xs, ys, {
                        epochs,
                        batchSize,
                        shuffle: true,      // Mélanger les données
                        verbose: 0,         // Désactiver les logs
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                history.push(logs); // Sauvegarder les métriques
                                if (onEpoch) await onEpoch(epoch, logs);
                                await tf.nextFrame(); // Permettre à l'UI de se rafraîchir
                            }
                        }
                    });

                    return {
                        model,
                        history
                    };
                }

                // -- 5. FORÊT ALÉATOIRE (ensemble de petits modèles)

                /**
                 * Entraîne une forêt aléatoire (Random Forest)
                 * @param {string} range - Plage de données
                 * @param {object} options - Options de la forêt
                 * @returns {object} Modèle de forêt aléatoire
                 */
                async function trainRandomForest(range = "all", options = {
                    nTrees: 5,      // Nombre d'arbres
                    epochs: 8,      // Époques par arbre
                    batchSize: 16   // Taille des lots
                }) {
                    const { features, labels, draws } = prepareMLData(range);

                    // Vérifier qu'il y a suffisamment de données
                    if (features.length < 2) throw new Error("Pas assez de données");

                    const xsAll = features;
                    const ysAll = labels;
                    const trees = [];       // Stocker les arbres
                    const histories = [];   // Historiques d'entraînement

                    // Construire les arbres sur des sous-ensembles bootstrap
                    for (let t = 0; t < options.nTrees; t++) {
                        // Échantillon bootstrap (rééchantillonnage avec remise)
                        const sampleIdx = [];
                        for (let i = 0; i < xsAll.length; i++) {
                            sampleIdx.push(Math.floor(Math.random() * xsAll.length));
                        }

                        const xsSample = sampleIdx.map(i => xsAll[i]);
                        const ysSample = sampleIdx.map(i => ysAll[i]);

                        const xs = tf.tensor2d(xsSample);
                        const ys = tf.tensor2d(ysSample);

                        // Petit modèle par arbre
                        const model = createDenseModel(32, 16);
                        await model.fit(xs, ys, {
                            epochs: options.epochs,
                            batchSize: options.batchSize,
                            shuffle: true,
                            verbose: 0,
                            callbacks: {
                                onEpochEnd: async (epoch, logs) => {
                                    await tf.nextFrame(); // UI responsive
                                }
                            }
                        });

                        trees.push(model);
                        histories.push(true);
                        tf.dispose([xs, ys]); // Libérer la mémoire
                    }

                    // Objet wrapper pour la forêt aléatoire
                    const rf = {
                        type: "random_forest",
                        models: trees,

                        /**
                         * Prédit les probabilités pour un vecteur d'entrée
                         * @param {array} inputVec - Vecteur d'entrée (49 dimensions)
                         * @returns {array} Probabilités moyennes des 49 numéros
                         */
                        predict: (inputVec) => {
                            // Obtenir les prédictions de tous les arbres
                            const tPreds = trees.map(m => {
                                const p = m.predict(tf.tensor2d([inputVec]));
                                const arr = Array.from(p.dataSync());
                                p.dispose(); // Libérer la mémoire
                                return arr;
                            });

                            // Moyenne des probabilités
                            const avg = Array(49).fill(0);
                            for (let i = 0; i < tPreds.length; i++) {
                                for (let j = 0; j < 49; j++) {
                                    avg[j] += tPreds[i][j];
                                }
                            }
                            for (let j = 0; j < 49; j++) {
                                avg[j] /= tPreds.length;
                            }

                            return avg;
                        },

                        // Libérer la mémoire de tous les arbres
                        dispose: () => trees.forEach(m => m.dispose())
                    };

                    return {
                        model: rf,
                        drawsCount: draws.length
                    };
                }

                // -- 6. GRADIENT BOOSTING (apprenants séquentiels)

                /**
                 * Entraîne un modèle de gradient boosting
                 * @param {string} range - Plage de données
                 * @param {object} options - Options du boosting
                 * @returns {object} Modèle de gradient boosting
                 */
                async function trainGradientBoosting(range = "all", options = {
                    nEstimators: 5,     // Nombre d'estimateurs
                    epochs: 8,          // Époques par estimateur
                    batchSize: 16,      // Taille des lots
                    learningRate: 0.5   // Taux d'apprentissage
                }) {
                    const { features, labels, draws } = prepareMLData(range);
                    const n = features.length;

                    if (n < 2) throw new Error("Pas assez de données");

                    // Initialiser les résidus aux labels originaux
                    let residuals = labels.map(row => row.slice()); // Copie profonde
                    const learners = []; // Stocker les apprenants

                    for (let e = 0; e < options.nEstimators; e++) {
                        const xs = tf.tensor2d(features);
                        const ys = tf.tensor2d(residuals);

                        // Petit apprenant
                        const model = createDenseModel(32, 16);
                        await model.fit(xs, ys, {
                            epochs: options.epochs,
                            batchSize: options.batchSize,
                            verbose: 0,
                            callbacks: {
                                onEpochEnd: async () => await tf.nextFrame()
                            }
                        });

                        // Calculer les prédictions sur l'ensemble d'entraînement
                        const predTensor = model.predict(xs);
                        const predArr = Array.from(predTensor.dataSync());

                        // Mettre à jour les résidus : résidu = résidu - lr * prédiction
                        for (let i = 0; i < n; i++) {
                            for (let j = 0; j < 49; j++) {
                                const idx = i * 49 + j;
                                residuals[i][j] = Math.max(0, residuals[i][j] - options.learningRate * predArr[idx]);
                            }
                        }

                        learners.push(model);
                        tf.dispose([xs, ys, predTensor]); // Libérer la mémoire
                    }

                    const gb = {
                        type: "gradient_boosting",
                        models: learners,
                        learningRate: options.learningRate,

                        /**
                         * Prédit les probabilités pour un vecteur d'entrée
                         * @param {array} inputVec - Vecteur d'entrée
                         * @returns {array} Probabilités prédites
                         */
                        predict: (inputVec) => {
                            // Prédiction séquentielle (somme pondérée)
                            const sum = Array(49).fill(0);
                            for (let m of learners) {
                                const p = m.predict(tf.tensor2d([inputVec]));
                                const arr = Array.from(p.dataSync());
                                p.dispose();
                                for (let j = 0; j < 49; j++) {
                                    sum[j] += arr[j] * gb.learningRate;
                                }
                            }

                            // Limiter entre 0 et 1
                            for (let j = 0; j < 49; j++) {
                                sum[j] = Math.min(1, Math.max(0, sum[j]));
                            }

                            return sum;
                        },

                        // Libérer la mémoire
                        dispose: () => learners.forEach(m => m.dispose())
                    };

                    return {
                        model: gb,
                        drawsCount: draws.length
                    };
                }

                // -- 7. RÉGRESSION LOGISTIQUE (couche dense unique)

                /**
                 * Entraîne un modèle de régression logistique
                 * @param {string} range - Plage de données
                 * @param {object} options - Options d'entraînement
                 * @returns {object} Modèle de régression logistique
                 */
                async function trainLogistic(range = "all", options = {
                    epochs: 20,
                    batchSize: 32
                }) {
                    const { features, labels, draws } = prepareMLData(range);
                    const xs = tf.tensor2d(features);
                    const ys = tf.tensor2d(labels);

                    // Modèle de type logistique : couche unique 49 → 49 avec sigmoid
                    const model = tf.sequential();
                    model.add(tf.layers.dense({
                        units: 49,
                        activation: 'sigmoid',
                        inputShape: [49]
                    }));

                    model.compile({
                        optimizer: 'adam',
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });

                    await model.fit(xs, ys, {
                        epochs: options.epochs,
                        batchSize: options.batchSize,
                        shuffle: true,
                        verbose: 0,
                        callbacks: {
                            onEpochEnd: async () => await tf.nextFrame()
                        }
                    });

                    tf.dispose([xs, ys]); // Libérer la mémoire

                    const logistic = {
                        type: "logistic",
                        model,

                        /**
                         * Prédit les probabilités
                         * @param {array} inputVec - Vecteur d'entrée
                         * @returns {array} Probabilités prédites
                         */
                        predict: (inputVec) => {
                            const p = model.predict(tf.tensor2d([inputVec]));
                            const arr = Array.from(p.dataSync());
                            p.dispose();
                            return arr;
                        },

                        dispose: () => model.dispose()
                    };

                    return {
                        model: logistic,
                        drawsCount: draws.length
                    };
                }

                // -- 8. RÉSEAU LSTM (pour données séquentielles)

                /**
                 * Entraîne un modèle LSTM (Long Short-Term Memory)
                 * @param {string} range - Plage de données
                 * @param {object} options - Options d'entraînement
                 * @returns {object} Modèle LSTM
                 */
                async function trainLSTM(range = "all", options = {
                    epochs: 10,
                    batchSize: 16
                }) {
                    const { features, labels, draws } = prepareMLData(range);
                    const xs = tf.tensor2d(features);
                    const ys = tf.tensor2d(labels);

                    // Remodeler en [échantillons, 1 pas de temps, 49 caractéristiques]
                    const xs3 = xs.reshape([xs.shape[0], 1, 49]);

                    const model = tf.sequential();

                    // Couche LSTM pour les séquences temporelles
                    model.add(tf.layers.lstm({
                        units: 64,
                        inputShape: [1, 49],
                        returnSequences: false // Ne retourne que la dernière sortie
                    }));

                    // Couche de sortie
                    model.add(tf.layers.dense({
                        units: 49,
                        activation: 'sigmoid'
                    }));

                    model.compile({
                        optimizer: 'adam',
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });

                    await model.fit(xs3, ys, {
                        epochs: options.epochs,
                        batchSize: options.batchSize,
                        shuffle: true,
                        verbose: 0,
                        callbacks: {
                            onEpochEnd: async () => await tf.nextFrame()
                        }
                    });

                    tf.dispose([xs, ys, xs3]); // Libérer la mémoire

                    const lstmObj = {
                        type: "lstm",
                        model,

                        /**
                         * Prédit les probabilités avec le LSTM
                         * @param {array} inputVec - Vecteur d'entrée
                         * @returns {array} Probabilités prédites
                         */
                        predict: (inputVec) => {
                            const t = tf.tensor2d([inputVec]).reshape([1, 1, 49]);
                            const p = model.predict(t);
                            const arr = Array.from(p.dataSync());
                            p.dispose();
                            t.dispose();
                            return arr;
                        },

                        dispose: () => model.dispose()
                    };

                    return {
                        model: lstmObj,
                        drawsCount: draws.length
                    };
                }

                // -- 9. ENSEMBLE STACKING (moyenne des modèles)

                /**
                 * Entraîne un ensemble de modèles (stacking)
                 * @param {string} range - Plage de données
                 * @param {object} options - Options de l'ensemble
                 * @returns {object} Modèle d'ensemble
                 */
                async function trainEnsemble(range = "all", options = {
                    members: ['random_forest', 'gradient_boosting', 'logistic', 'lstm'],
                    params: {}
                }) {
                    // Entraîner chaque membre séquentiellement (pour éviter les pics mémoire)
                    const trained = {};

                    for (let m of options.members) {
                        if (m === 'random_forest') {
                            trained.random_forest = (await trainRandomForest(range, {
                                nTrees: 5,
                                epochs: 6,
                                batchSize: 16
                            })).model;
                        } else if (m === 'gradient_boosting') {
                            trained.gradient_boosting = (await trainGradientBoosting(range, {
                                nEstimators: 4,
                                epochs: 6,
                                batchSize: 16,
                                learningRate: 0.5
                            })).model;
                        } else if (m === 'logistic') {
                            trained.logistic = (await trainLogistic(range, {
                                epochs: 12,
                                batchSize: 32
                            })).model;
                        } else if (m === 'lstm') {
                            trained.lstm = (await trainLSTM(range, {
                                epochs: 8,
                                batchSize: 16
                            })).model;
                        }
                    }

                    // Prédicteur d'ensemble
                    const ensemble = {
                        type: "ensemble",
                        members: trained,

                        /**
                         * Prédit en faisant la moyenne des prédictions des membres
                         * @param {array} inputVec - Vecteur d'entrée
                         * @returns {array} Probabilités moyennes
                         */
                        predict: (inputVec) => {
                            const votes = [];
                            for (let k in trained) {
                                const p = trained[k].predict(inputVec);
                                votes.push(p);
                            }

                            // Moyenne des votes
                            const avg = Array(49).fill(0);
                            for (let i = 0; i < votes.length; i++) {
                                for (let j = 0; j < 49; j++) {
                                    avg[j] += votes[i][j];
                                }
                            }
                            for (let j = 0; j < 49; j++) {
                                avg[j] /= votes.length;
                            }

                            return avg;
                        },

                        // Libérer la mémoire de tous les membres
                        dispose: () => {
                            for (let k in trained) trained[k].dispose();
                        }
                    };

                    return {
                        model: ensemble,
                        drawsCount: (await prepareMLData(range)).features.length
                    };
                }

                // -- 10. ASSISTANT DE PRÉDICTION (utilisé par l'UI/tests)

                /**
                 * Prédit avec un modèle ML entraîné
                 * @param {object} modelObj - Modèle ML entraîné
                 * @param {object} lastDraw - Dernier tirage connu
                 * @returns {object} Probabilités et top 5 numéros
                 */
                async function predictMLModel(modelObj, lastDraw) {
                    // Vérifier que le modèle a une fonction de prédiction
                    if (!modelObj || typeof modelObj.predict !== 'function') {
                        throw new Error("Model not predictive");
                    }

                    const enc = encodeDraw(lastDraw); // Encoder le dernier tirage
                    const probs = modelObj.predict(enc); // Obtenir les probabilités

                    // Obtenir les 5 numéros les plus probables
                    const top = probs.map((p, i) => ({
                        num: i + 1,  // Numéro (1-49)
                        prob: p      // Probabilité
                    }))
                        .sort((a, b) => b.prob - a.prob) // Trier par probabilité décroissante
                        .slice(0, 5)                     // Prendre les 5 premiers
                        .map(x => x.num);                // Extraire seulement les numéros

                    return {
                        probs,
                        top
                    };
                }

                // -- 11. ORCHESTRATEUR DE HAUT NIVEAU : trainModelByType

                /**
                 * Entraîne un modèle selon son type
                 * @param {string} modelType - Type de modèle
                 * @param {string} range - Plage de données
                 * @returns {object} Modèle entraîné et métriques
                 */
                async function trainModelByType(modelType, range = "all") {
                    // Router vers la fonction d'entraînement appropriée
                    if (modelType === 'rf' || modelType === 'random_forest') {
                        return await trainRandomForest(range);
                    }
                    if (modelType === 'gb' || modelType === 'gradient_boosting') {
                        return await trainGradientBoosting(range);
                    }
                    if (modelType === 'logistic') {
                        return await trainLogistic(range);
                    }
                    if (modelType === 'lstm') {
                        return await trainLSTM(range);
                    }
                    if (modelType === 'ensemble') {
                        return await trainEnsemble(range);
                    }

                    // Modèle dense par défaut
                    const prepared = prepareMLData(range);
                    const xs = tf.tensor2d(prepared.features);
                    const ys = tf.tensor2d(prepared.labels);

                    const { model, history } = await trainSingleModel(xs, ys, {
                        epochs: 12,
                        batchSize: 16,
                        onEpoch: async () => await tf.nextFrame()
                    });

                    tf.dispose([xs, ys]); // Libérer la mémoire

                    const wrapper = {
                        type: "dense",
                        model,

                        /**
                         * Prédit avec le modèle dense
                         * @param {array} vec - Vecteur d'entrée
                         * @returns {array} Probabilités prédites
                         */
                        predict: (vec) => {
                            const p = model.predict(tf.tensor2d([vec]));
                            const a = Array.from(p.dataSync());
                            p.dispose();
                            return a;
                        },

                        dispose: () => model.dispose()
                    };

                    return {
                        model: wrapper,
                        drawsCount: prepared.features.length,
                        history
                    };
                }

                // -- 12. EXPOSER LES FONCTIONS GLOBALEMENT POUR LES TESTS / UI

                // Rendre les fonctions accessibles depuis la console et les tests
                window.prepareMLData = prepareMLData;
                window.calculateFeatures = calculateFeatures;
                window.trainRandomForest = trainRandomForest;
                window.trainGradientBoosting = trainGradientBoosting;
                window.trainLogistic = trainLogistic;
                window.trainLSTM = trainLSTM;
                window.trainEnsemble = trainEnsemble;
                window.predictMLModel = predictMLModel;
                window.trainModelByType = trainModelByType;

                /* === FIN MODULE ML === */


                // ============================================================================
                // SYSTÈME DE RECHERCHE AVANCÉ
                // ============================================================================

                const searchIndex = [
                    {
                        title: "Programme",
                        description: "Le programme proprose une plateforme d'analyse avancée des tirages de loterie combinant des modèles statistiques de pointe, des algorithmes d'apprentissage automatique et des approches probabilistes pour identifier des tendances et proposer des prévisions optimisées",
                        category: "programme",
                        tags: ["plateforme", "analyse", "prévisions", "optimisées"],
                        fullContent: "ARÔME est une plateforme d'analyse avancée combinant des modèles statistiques de pointe et algorithmes d'apprentissage automatique pour l'étude approfondie des tirages de loterie. Le programme intègre des méthodes probabilistes sophistiquées et des techniques d'apprentissage automatique pour identifier les tendances historiques et générer des prévisions optimisées.L'architecture modulaire permet d'explorer les données sous différents approches : Analyses fréquentielles, clustering K-Means pour la détection de patterns, simulations Monte-Carlo massives, et évaluations statistiques avancées. La fonctionnalité unique de la Matrice personnalisée offre la possibilité de composer des architectures d'analyse sur mesure en combinant plusieurs modèles pour une synergie optimisée. La plateforme constitue un outil d'exploration statistique complet pour comprendre les mécanismes probabilistes régissant les tirages aléatoires."

                    },
                    {
                        title: "Simulation Monte-Carlo",
                        description: "Méthode d'échantillonnage aléatoire massif avec Importance Sampling - 10,000+ simulations pondérées",
                        category: "probabilistes",
                        tags: ["montecarlo", "simulation", "échantillonnage", "variance"],
                        fullContent: `Simulation Monte-Carlo

                        Principe Mathématique : Méthode d'échantillonnage aléatoire massif pour résoudre des problèmes déterministes par des moyens probabilistes.

                        Formule Clé : E[f(X)] ≈ (1/N) * Σ f(X_i) où X_i ~ Distribution cible
                        Processus : 10,000+ simulations de tirages pondérées
                        Importance Sampling : Combinaison fréquences (40%), écarts (30%), tendances (30%)
                        Distribution stationnaire : Convergence vers les probabilités réelles
                        Réduction de variance : Optimisation par pondération intelligente

                        Rôle : Identification des combinaisons les plus probables via l'analyse de millions de scénarios simulés.`
                    },
                    {
                        title: "Loi de Poisson",
                        description: "Modélisation des événements rares - λ = fréquence historique - Pondération λ × e^(-λ) pour éviter la sur-représentation",
                        category: "probabilistes",
                        tags: ["poisson", "distribution", "fréquence", "événements rares"],
                        fullContent: `Principe Mathématique : Modélisation des probabilités d'apparition basée sur la distribution de Poisson pour événements rares dans un intervalle fixe.
                        
                        Formule Clé : P(X=k) = (λ^k * e^(-λ)) / k! où λ = fréquence moyenne du numéro

                        Application :
                        • λ = fréquence historique relative de chaque numéro
                        • Pondération : λ × e^(-λ) pour éviter la sur-représentation
                        • Sélection : Tirage aléatoire selon les probabilités de Poisson
                        
                        RÔLE : Privilégier les numéros avec des fréquences historiques optimales.`
                    },
                    {
                        title: "Distribution de Dirichlet",
                        description: "Distribution multivariée bayésienne - Répartition par dizaines 1-10, 11-20, 21-30, 31-40, 41-49 - Paramètres α = fréquences historiques",
                        category: "probabilistes",
                        tags: ["dirichlet", "multivariée", "bayésien", "répartition"],
                        fullContent: `Principe Mathématique : Distribution multivariée pour modéliser les probabilités des différents numéros dans un cadre bayésien.\n\nFormule Clé : f(x₁,...,xₖ; α₁,...,αₖ) = (1/B(α)) * Π x_i^(α_i-1) où B(α) = fonction Bêta multivariée\n\nApplication :\n• Dizaines : 1-10, 11-20, 21-30, 31-40, 41-49\n• Paramètres α : Fréquences historiques par tranche + 1 (régularisation)\n• Répartition : Génération de proportions optimales\n\nRÔLE : Assurer une répartition équilibrée des numéros sur l'ensemble des dizaines.`
                    },
                    {
                        title: "Distribution Binomiale",
                        description: "Modélisation pairs/impairs - n=5 numéros par tirage - p = probabilité empirique d'un numéro pair - Contrôle équilibre",
                        category: "probabilistes",
                        tags: ["binomiale", "succès", "pairs-impairs", "équilibre"],
                        fullContent: `Principe Mathématique : Modélisation des probabilités de succès sur une série d'essais indépendants pour chaque numéro.\n\nFormule Clé : P(X=k) = C(n,k) * p^k * (1-p)^(n-k)\n\nApplication :\n• n = 5 (numéros par tirage)\n• p = probabilité empirique d'un numéro pair\n• k = nombre de pairs dans la combinaison (0 à 5)\n\nRÔLE : Contrôler l'équilibre pairs/impairs selon les distributions historiques.`
                    },
                    {
                        title: "Distribution Gamma",
                        description: "Modélisation temps d'attente - k = nombre d'apparitions - θ = temps moyen d'attente/k - Identification numéros en retard",
                        category: "probabilistes",
                        tags: ["gamma", "temps attente", "réapparition", "paramètre forme"],
                        fullContent: `Principe Mathématique : Modélisation des temps d'attente entre événements.\n\nFormule Clé : f(x; k, θ) = x^(k-1) * e^(-x/θ) / (θ^k * Γ(k))\n\nApplication :\n• k = nombre d'apparitions (paramètre de forme)\n• θ = temps moyen d'attente / k (paramètre d'échelle)\n• Score = PDF Gamma pour chaque numéro\n\nRÔLE : Identifier les numéros "en retard" ayant une probabilité élevée de réapparaître.`
                    },
                    {
                        title: "Test T de Student",
                        description: "Test paramétrique comparaison moyennes - X̄ = fréquence observée - μ = fréquence moyenne globale - Détection sur/sous-représentation",
                        category: "probabilistes",
                        tags: ["student", "test paramétrique", "moyennes", "significativité"],
                        fullContent: `Principe Mathématique : Test paramétrique pour comparer les moyennes de différents groupes de numéros et valider les différences significatives.\n\nFormule Clé : t = (X̄ - μ) / (s/√n)\n\nApplication :\n• X̄ = fréquence observée du numéro\n• μ = fréquence moyenne globale\n• s = écart-type des fréquences\n• n = 49 (nombre de numéros)\n\nRÔLE : Détecter les numéros significativement sur/sous-représentés.`
                    },
                    {
                        title: "Test du Chi-carré",
                        description: "Test non paramétrique adéquation - O_i = fréquence observée - E_i = fréquence attendue - Vérification uniformité distribution",
                        category: "probabilistes",
                        tags: ["chi-carré", "adéquation", "uniformité", "degrés liberté"],
                        fullContent: `Principe Mathématique : Test non paramétrique pour vérifier l'adéquation entre la distribution observée et une distribution théorique attendue.\n\nFormule Clé : χ² = Σ [(O_i - E_i)² / E_i]\n\nApplication :\n• O_i = fréquence observée du numéro i\n• E_i = fréquence attendue (moyenne uniforme)\n• ddl = 48 (degrés de liberté)\n\nRÔLE : Vérifier l'hypothèse d'uniformité de la distribution des numéros.`
                    },
                    {
                        title: "Loi de Zipf",
                        description: "Distribution rang-fréquence - r = rang du numéro - s ≈ 1.0 paramètre pente - Pondération inverse du rang",
                        category: "probabilistes",
                        tags: ["zipf", "rang-fréquence", "hiérarchie", "patterns"],
                        fullContent: `Principe Mathématique : Application de la loi de Zipf pour modéliser la distribution rang-fréquence et identifier les patterns hiérarchiques.\n\nFormule Clé : f(r) = 1 / r^s\n\nApplication :\n• r = rang du numéro (1 = plus fréquent)\n• s ≈ 1.0 (paramètre de pente)\n• Pondération : Inverse du rang\n\nRÔLE : Privilégier structurellement les numéros historiquement fréquents.`
                    },
                    {
                        title: "Random Forest",
                        description: "Forêt 100 arbres décision - Bagging bootstrap - Feature aléatoire sélection - Vote majoritaire agrégation",
                        category: "machinelearning",
                        tags: ["randomforest", "arbres décision", "bagging", "vote majoritaire"],
                        fullContent: `ARCHITECTURE : Forêt de 100 arbres de décision\n\nPRINCIPE :\n• Bagging : Bootstrap aggregating\n• Feature aléatoire : Sélection aléatoire à chaque split\n• Vote majoritaire : Agrégation des prédictions\n\nMATHÉMATIQUE : Prédiction = mode({T₁(x), T₂(x), ..., T₁₀₀(x)})\n\nAVANTAGE : Robustesse au bruit et éviter le sur-apprentissage.`
                    },
                    {
                        title: "Gradient Boosting",
                        description: "Algorithme boosting séquentiel - Construction modèles faibles - Minimisation fonction perte - Learning rate 0.1",
                        category: "machinelearning",
                        tags: ["gradientboosting", "boosting", "sequential", "loss function"],
                        fullContent: `ARCHITECTURE : Algorithme de boosting construisant séquentiellement des modèles faibles pour minimiser la fonction de perte.\n\nPRINCIPE :\n• Apprentissage séquentiel : Chaque arbre corrige les erreurs du précédent\n• Fonction de perte : Mean Squared Error\n• Learning rate : 0.1\n\nALGORITHME : F_m(x) = F_{m-1}(x) + γ_m * h_m(x) où h_m(x) minimise la perte résiduelle`
                    },
                    {
                        title: "Régression Logistique Multiclasse",
                        description: "Modèle linéaire généralisé classification - Fonction logistique - Régularisation L2 - Encodage one-hot 49 classes",
                        category: "machinelearning",
                        tags: ["regressionlogistique", "multiclasse", "L2", "one-hot"],
                        fullContent: `FORMULATION : Modèle linéaire généralisé pour la classification avec fonction logistique et régularisation L2.\n\nFONCTION : P(y=k|x) = e^(w_k·x) / Σ e^(w_j·x)\n\nOPTIMISATION :\n• Régularisation L2 : Pénalisation des grands coefficients\n• Algorithme L-BFGS : Optimisation quasi-Newton\n• Encodage one-hot : 49 classes de sortie`
                    },
                    {
                        title: "Ensemble Stacking",
                        description: "Meta-algorithme combinaison modèles - Niveau 1: RF, GB, LR - Niveau 2: Régression linéaire - Amélioration performances",
                        category: "machinelearning",
                        tags: ["stacking", "meta-algorithme", "combinaison", "performance"],
                        fullContent: `ARCHITECTURE : Meta-algorithme combinant les prédictions de multiples modèles via un meta-modèle pour améliorer les performances.\n\nNIVEAU 1 (Base) :\n• Random Forest, Gradient Boosting, Régression Logistique\n\nNIVEAU 2 (Méta) :\n• Régression linéaire combinant les prédictions\n\nFormule Clé : Prédiction_finale = w₁·RF(x) + w₂·GB(x) + w₃·LR(x)`
                    },
                    {
                        title: "Clustering K-Means",
                        description: "Algorithme partitionnement données - Minimisation variance intra-cluster - k clusters centroïdes - Distance euclidienne",
                        category: "clustering",
                        tags: ["kmeans", "clustering", "partitionnement", "centroïdes"],
                        fullContent: `DÉFINITION MATHÉMATIQUE : Algorithme de partitionnement de données qui vise à diviser un ensemble de n observations en k clusters où chaque observation appartient au cluster dont le centroïde est le plus proche.\n\nOBJECTIF : Minimiser la variance intra-cluster\nargmin_S Σ_{i=1}^k Σ_{x∈S_i} ||x - μ_i||²\n\nOÙ :\n• S = {S₁, S₂, ..., Sₖ} : Partition des données\n• μ_i : Centroïde du cluster i\n• ||x - μ_i|| : Distance euclidienne\n\nALGORITHME ITÉRATIF :\n1. Initialisation : Choix aléatoire k centroïdes\n2. Affectation : Assignation points au centroïde le plus proche\n3. Mise à jour : Recalcul des centroïdes\n4. Critère arrêt : Convergence ou itérations maximales`
                    },
                    {
                        title: "Simulation Monte-Carlo Avancée",
                        description: "Échantillonnage préférentiel Importance Sampling - Distribution composite q(x) = 0.4·q₁ + 0.3·q₂ + 0.3·q₃ - Réduction variance",
                        category: "simulation",
                        tags: ["montecarlo", "avancée", "échantillonnage", "préférentiel"],
                        fullContent: `PRINCIPE FONDAMENTAL : Méthode de résolution de problèmes déterministes par des moyens probabilistes : E[f(X)] ≈ (1/N) × Σ f(X₍ᵢ₎) où X₍ᵢ₎ ~ π(x)\n\nÉCHANTILLONNAGE PRÉFÉRENTIEL : Au lieu d'échantillonner selon la distribution cible π(x), on échantillonne selon une distribution instrumentale q(x) qui favorise les régions importantes.\n\nDISTRIBUTION COMPOSITE :\nq(x) = α·q₁(x) + β·q₂(x) + γ·q₃(x)\navec α=0.4, β=0.3, γ=0.3\n\nCOMPOSANTES :\n• q₁(x) ∝ Fréquence_historique(x) + ε (40%)\n• q₂(x) ∝ exp(-Gap(x)/τ) (30%)\n• q₃(x) ∝ Fréquence_récente(x) (30%)\n\nALGORITHME DÉTAILLÉ :\nPhase 1 : Calcul poids importance\nPhase 2 : Simulation avec Importance Sampling  \nPhase 3 : Agrégation et classement`
                    },
                    {
                        title: "Matrice",
                        description: "Système expert composition modulaire - Combinaison intelligente modèles - Synergie > Somme parties - Architecture modulaire",
                        category: "matrice",
                        tags: ["matrice", "modulaire", "synergie", "composition"],
                        fullContent: `CONCEPT FONDAMENTAL : Système expert de composition modulaire permettant de créer des architectures d'analyse sur mesure en combinant intelligemment différents modèles statistiques et algorithmes d'apprentissage automatique.\n\nPRINCIPE : Synergie > Somme des parties\n\nARCHITECTURE MODULAIRE :\n1. MODÈLES STATISTIQUES FONDAMENTAUX\n   • Distribution de Poisson\n   • Distribution Binomiale  \n   • Loi de Zipf\n   • Distribution de Dirichlet\n\n2. ALGORITHMES MACHINE LEARNING\n   • Random Forest\n   • Gradient Boosting\n   • LSTM (Long Short-Term Memory)\n\n3. TECHNIQUES AVANCÉES\n   • Clustering K-Means\n   • Simulation Monte-Carlo\n   • Ensemble Stacking\n\nSYSTÈMES DE PONDÉRATION :\n• Méthode 1 : Pondération Égale\n• Méthode 2 : Pondération par Performance  \n• Méthode 3 : Pondération Personnalisée\n\nMÉCANISMES DE FUSION :\n• Vote Majoritaire\n• Fusion Pondérée\n• Stacking Avancé`
                    },
                    {
                        title: "Analyse des Fréquences",
                        description: "Calcul fréquences historiques - Histogramme visualisation - Top 10/Bottom 10 - Identification tendances long terme",
                        category: "analyse",
                        tags: ["fréquences", "histogramme", "tendances", "historique"],
                        fullContent: `CALCUL : Fréquence(n) = Nombre d'apparitions(n) / Total tirages\n\nDISTRIBUTION :\n• Histogramme : Visualisation des fréquences relatives\n• Top 10 : Numéros les plus fréquents  \n• Bottom 10 : Numéros les moins fréquents\n\nINTERPRÉTATION : Identification des tendances historiques long terme.`
                    },
                    {
                        title: "Évaluation de Grille",
                        description: "Scores composites multiples - Fréquence, Parité, Statistique, Cluster, Équilibre - Score global moyenne pondérée",
                        category: "evaluation",
                        tags: ["grille", "scores", "évaluation", "composite"],
                        fullContent: `SCORES COMPOSITES :\n\n1. SCORE FRÉQUENCE (0-100) :\n   Σ(fréquence numéros) / max_fréquence * 100\n\n2. SCORE PARITÉ (0-100) :\n   min(pairs, impairs) * 20\n\n3. SCORE STATISTIQUE (0-100) :\n   max(0, 100 - |somme - 125| / 2)\n\n4. SCORE CLUSTER (0-100) :\n   nombre_clusters_distincts * 20\n\n5. SCORE ÉQUILIBRE (0-100) :\n   max(0, 100 - (max_dizaine - 1) * 25)\n\nSCORE GLOBAL : Moyenne pondérée des scores individuels.`
                    },
                    {
                        title: "Technologies Mathématiques",
                        description: "TensorFlow.js réseaux neuronaux - Math.js calcul symbolique - Chart.js visualisation interactive - Optimisation GPU/CPU",
                        category: "technologies",
                        tags: ["tensorflow", "mathjs", "chartjs", "visualisation"],
                        fullContent: `TENSORFLOW.JS :\n• Réseaux Neuronaux : Création et entraînement in-browser\n• Tenseurs : Calcul numérique optimisé GPU/CPU\n• Autograd : Différentiation automatique  \n• Layers API : Construction modulaire de modèles\n\nMATH.JS :\n• Calcul Symbolique : Évaluation d'expressions complexes\n• Matrices : Opérations algébriques avancées\n• Distributions : Fonctions statistiques intégrées\n• Précision : Calculs numériques haute précision\n\nCHART.JS :\n• Visualisation : Représentation graphique interactive\n• Animations : Transitions fluides des données\n• Responsive : Adaptation automatique aux devices\n• Types multiples : Barres, lignes, radar, doughnut, scatter`
                    },
                    {
                        title: "Entraînement Apprentissage Automatique",
                        description: "Algorithmes implémentés RF, GB, LR, LSTM, Stacking - Processus entraînement complet - Optimisations avancées",
                        category: "machinelearning",
                        tags: ["entraînement", "optimisation", "validation", "performance"],
                        fullContent: `ALGORITHMES IMPLÉMENTÉS :\n• FORÊT ALÉATOIRE (Random Forest)\n• GRADIENT BOOSTING  \n• RÉGRESSION LOGISTIQUE MULTICLASSE\n• RÉSEAUX NEURONAUX RÉCURRENTS (LSTM)\n• MÉTA-APPRENTISSAGE (Stacking)\n\nPROCESSUS D'ENTRAÎNEMENT :\n1. PRÉPARATION DES DONNÉES\n   • Encodage des Tirages\n   • Création des Séries Temporelles\n\n2. CONFIGURATION DES MODÈLES\n   • Architecture Réseau de Neurones\n   • Hyperparamètres\n\n3. FONCTIONS DE PERTE\n   • Entropie Croisée Binaire\n\nÉVALUATION ET VALIDATION :\n• Métriques de Performance\n• Techniques de Validation\n\nOPTIMISATIONS AVANCÉES :\n• Régularisation\n• Arrêt Précoce (Early Stopping)\n• Adaptation du Taux d'Apprentissage`
                    }
                ];

                // Initialisation de la recherche
                function initSearch() {
                    const searchToggle = document.getElementById('searchToggle');
                    const searchOverlay = document.getElementById('searchOverlay');
                    const searchClose = document.getElementById('searchClose');
                    const searchInput = document.getElementById('searchInput');
                    const searchResults = document.getElementById('searchResults');
                    const searchCount = document.getElementById('searchCount');

                    // Ouvrir la recherche
                    searchToggle.addEventListener('click', () => {
                        searchOverlay.classList.add('active');
                        searchInput.focus();
                        performSearch(''); // Afficher tous les résultats au début
                    });

                    // Fermer la recherche
                    searchClose.addEventListener('click', () => {
                        searchOverlay.classList.remove('active');
                    });

                    // Recherche en temps réel
                    searchInput.addEventListener('input', (e) => {
                        performSearch(e.target.value);
                    });

                    // Fermer avec ESC
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && searchOverlay.classList.contains('active')) {
                            searchOverlay.classList.remove('active');
                        }
                    });
                }

                // Fonction pour ouvrir l'index complet
                function openFullIndex() {
                    // Fermer la modale de recherche
                    document.getElementById('searchOverlay').classList.remove('active');

                    // Afficher l'onglet Index
                    showTab('index');

                    // Remplir l'index avec tous les résultats
                    populateFullIndex();
                }

                // Fonction pour peupler l'index complet
                function populateFullIndex() {
                    const container = document.getElementById('indexFullResults');

                    // Grouper par catégorie
                    const categories = {};
                    searchIndex.forEach(item => {
                        if (!categories[item.category]) {
                            categories[item.category] = [];
                        }
                        categories[item.category].push(item);
                    });

                    let html = '';

                    // Générer le HTML pour chaque catégorie
                    for (const [category, items] of Object.entries(categories)) {
                        const categoryName = getCategoryDisplayName(category);

                        html += `
                    <div class="search-category" style="margin-bottom: 40px;">
                        <h4 style="font-size: 1.4rem; margin-bottom: 20px; color: var(--text-secondary); 
                                border-bottom: 1px solid var(--border-color); padding-bottom: 10px;">
                            ${categoryName}
                        </h4>
                        <div class="search-items-grid">
                `;

                        items.forEach(item => {
                            const safeTitle = item.title.replace(/'/g, "\\'");

                            html += `
                    <div class="search-item" style="cursor: pointer; position: relative;">
                        <div class="search-item-header">
                            <h5>${item.title}</h5>
                            <span class="search-item-type">${categoryName}</span>
                        </div>
                        <p>${item.description}</p>
                        
                        <!-- Bouton Développer (style tag) -->
                        <div style="margin: 15px 0 10px 0; text-align: left;">
                            <button onclick="toggleItemDetail('${safeTitle}', event)" 
                                    class="expand-btn"
                                    style="background: rgba(102, 187, 106, 0.15);
                                        color: #66bb6a;
                                        border: 1px solid rgba(102, 187, 106, 0.3);
                                        padding: 8px 15px;
                                        border-radius: 10px;
                                        font-size: 0.72rem;
                                        font-weight: 400;
                                        cursor: pointer;
                                        transition: all 0.3s ease;
                                        text-transform: none;
                                        letter-spacing: 0;">
                                📖 Développer
                            </button>
                        </div>
                        
                        <div class="search-tags">
                            ${item.tags.map(tag => `<span class="search-tag">${tag}</span>`).join('')}
                        </div>
                        
                        <!-- Conteneur pour le contenu développé -->
                        <div class="item-detail-content" 
                            id="detail-${safeTitle.replace(/\s+/g, '-')}"
                            style="display: none; 
                                    margin-top: 15px; 
                                    padding: 20px;                           
                                    border: 1px solid rgba(255, 255, 255, 0.1);
                                    border-radius: 8px;
                                    animation: slideDown 0.0s ease;">
                            <div style="white-space: pre-line; line-height: 1.8; color: rgba(255,255,255,0.9);">
                                ${item.fullContent}
                            </div>
                        </div>
                    </div>
                `;
                        });

                        html += `
                        </div>
                    </div>
                `;
                    }

                    container.innerHTML = html;

                    // Initialiser le filtrage de recherche dans l'index
                    const searchInput = document.getElementById('indexSearchInput');
                    if (searchInput) {
                        // Supprimer les anciens écouteurs pour éviter les doublons
                        const newSearchInput = searchInput.cloneNode(true);
                        searchInput.parentNode.replaceChild(newSearchInput, searchInput);

                        // Ajouter le nouvel écouteur
                        newSearchInput.addEventListener('input', (e) => {
                            const query = e.target.value.toLowerCase();
                            const items = document.querySelectorAll('#indexFullResults .search-item');

                            items.forEach(item => {
                                // Échapper les apostrophes
                                const safeTitle = item.title.replace(/'/g, "\\'");

                                html += `
                                    <div class="search-item" style="position: relative;">
                                        <div class="search-item-header">
                                            <h5>${item.title}</h5>
                                            <span class="search-item-type">${categoryName}</span>
                                        </div>
                                        <p>${item.description}</p>
                                        
                                            <!-- Bouton Développer (style tag) -->
                            <div style="margin: 15px 0 10px 0; text-align: left;">
                                <button onclick="toggleItemDetail('${safeTitle}', event)" 
                                        class="expand-btn"
                                        style="background: rgba(102, 187, 106, 0.15);
                                            color: #66bb6a;
                                            border: 1px solid rgba(102, 187, 106, 0.3);
                                            padding: 8px 15px;
                                            border-radius: 10px;
                                            font-size: 0.72rem;
                                            font-weight: 400;
                                            cursor: pointer;
                                            transition: all 0.3s ease;
                                            text-transform: none;
                                            letter-spacing: 0;">
                                    📖 Développer
                                </button>
                            </div>
                                        
                                        <div class="search-tags">
                                            ${item.tags.map(tag => `<span class="search-tag">${tag}</span>`).join('')}
                                        </div>
                                        
                                        <!-- Conteneur pour le contenu développé -->
                                        <div class="modal-item-detail-content" 
                                            id="modal-detail-${safeTitle.replace(/\s+/g, '-')}"
                                            style="display: none; 
                                                    margin-top: 20px; 
                                                    padding: 20px; 
                                                    background: rgba(77, 163, 255, 0.1); 
                                                    border-left: 4px solid #4da3ff; 
                                                    border-radius: 8px;
                                                    animation: slideDown 0.3s ease;">
                                            <div style="white-space: pre-line; line-height: 1.8; color: rgba(255,255,255,0.9);">
                                                ${item.fullContent}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            });

                            // Masquer les catégories vides
                            const categories = document.querySelectorAll('#indexFullResults .search-category');
                            categories.forEach(category => {
                                const visibleItems = category.querySelectorAll('.search-item[style*="display: block"], .search-item:not([style*="display: none"])');
                                category.style.display = visibleItems.length > 0 ? 'block' : 'none';
                            });
                        });
                    }
                }

                // Fonction pour développer/réduire le contenu d'un item
                function toggleItemDetail(title, event) {
                    // Empêcher la propagation du clic (évite de déclencher selectSearchItem)
                    if (event) {
                        event.stopPropagation();
                    }

                    // Restaurer les apostrophes échappées
                    const originalTitle = title.replace(/\\'/g, "'");
                    const safeId = title.replace(/\s+/g, '-');
                    const detailDiv = document.getElementById(`detail-${safeId}`);
                    const button = event.target;

                    if (!detailDiv) {
                        console.error('Élément de détail non trouvé:', `detail-${safeId}`);
                        return;
                    }

                    // Basculer l'affichage
                    if (detailDiv.style.display === 'none' || detailDiv.style.display === '') {
                        // Développer
                        detailDiv.style.display = 'block';
                        detailDiv.classList.remove('closing');
                        button.innerHTML = '📕 Réduire';
                        button.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';

                        // Scroll doux vers le contenu
                        setTimeout(() => {
                            detailDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }, 100);

                    } else {
                        // Réduire avec animation
                        detailDiv.classList.add('closing');
                        button.innerHTML = '📖 Développer';
                        button.style.background = 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)';

                        setTimeout(() => {
                            detailDiv.style.display = 'none';
                            detailDiv.classList.remove('closing');
                        }, 300);
                    }
                }

                // Fonction pour développer/réduire le contenu dans la modale de recherche
                function toggleModalItemDetail(title, event) {
                    // Empêcher la propagation du clic
                    if (event) {
                        event.stopPropagation();
                    }

                    // Restaurer les apostrophes échappées
                    const originalTitle = title.replace(/\\'/g, "'");
                    const safeId = title.replace(/\s+/g, '-');
                    const detailDiv = document.getElementById(`modal-detail-${safeId}`);
                    const button = event.target;

                    if (!detailDiv) {
                        console.error('Élément de détail modal non trouvé:', `modal-detail-${safeId}`);
                        return;
                    }

                    // Basculer l'affichage
                    if (detailDiv.style.display === 'none' || detailDiv.style.display === '') {
                        // Développer → devient "Réduire" en rouge (style tag)
                        detailDiv.style.display = 'block';
                        detailDiv.classList.remove('closing');
                        button.innerHTML = '📕 Réduire';
                        button.style.background = 'rgba(244, 67, 54, 0.15)';
                        button.style.borderColor = 'rgba(244, 67, 54, 0.3)';
                        button.style.color = '#f44336';

                        // Scroll doux vers le contenu
                        setTimeout(() => {
                            detailDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }, 100);

                    } else {
                        // Réduire → redevient "Développer" en vert (style tag)
                        detailDiv.classList.add('closing');
                        button.innerHTML = '📖 Développer';
                        button.style.background = 'rgba(102, 187, 106, 0.15)';
                        button.style.borderColor = 'rgba(102, 187, 106, 0.3)';
                        button.style.color = '#66bb6a';

                        setTimeout(() => {
                            detailDiv.style.display = 'none';
                            detailDiv.classList.remove('closing');
                        }, 300);
                    }
                }

                // Fonction de recherche principale
                function performSearch(query) {
                    const searchResults = document.getElementById('searchResults');
                    const searchCount = document.getElementById('searchCount');

                    if (!query.trim()) {
                        // Afficher tous les éléments si recherche vide
                        displayResults(searchIndex);
                        searchCount.textContent = searchIndex.length;
                        return;
                    }

                    const results = searchIndex.filter(item => {
                        const searchText = query.toLowerCase();

                        // Recherche dans le titre
                        if (item.title.toLowerCase().includes(searchText)) return true;

                        // Recherche dans la description
                        if (item.description.toLowerCase().includes(searchText)) return true;

                        // Recherche dans les tags
                        if (item.tags.some(tag => tag.toLowerCase().includes(searchText))) return true;

                        // Recherche dans la catégorie
                        if (item.category.toLowerCase().includes(searchText)) return true;

                        // Recherche dans le contenu complet
                        if (item.fullContent.toLowerCase().includes(searchText)) return true;

                        return false;
                    });

                    displayResults(results);
                    searchCount.textContent = results.length;
                }

                // Affichage des résultats
                function displayResults(results) {
                    const searchResults = document.getElementById('searchResults');

                    if (results.length === 0) {
                        searchResults.innerHTML = `
                        <div class="search-empty">
                        <i>🔍</i>
                        <p>Aucun résultat trouvé</p>
                        <div class="search-suggestions">
                        Essayez avec d'autres termes comme "Poisson", "Random Forest", ou "Monte-Carlo"
                        </div>
                    </div>
                `;
                        return;
                    }

                    // Grouper par catégorie
                    const categories = {};
                    results.forEach(item => {
                        if (!categories[item.category]) {
                            categories[item.category] = [];
                        }
                        categories[item.category].push(item);
                    });

                    let html = '';

                    for (const [category, items] of Object.entries(categories)) {
                        const categoryName = getCategoryDisplayName(category);

                        html += `
                        <div class="search-category">
                        <h4>${categoryName}</h4>
                        <div class="search-items-grid">
                `;

                        items.forEach(item => {
                            html += `
                        <div class="search-item" onclick="selectSearchItem('${item.title}')">
                        <div class="search-item-header">
                        <h5>${item.title}</h5>
                        <span class="search-item-type">${categoryName}</span>
                        </div>
                        <p>${item.description}</p>
                        <div class="search-tags">
                        ${item.tags.map(tag => `<span class="search-tag">${tag}</span>`).join('')}
                         </div>
                    </div>
                `;
                        });

                        html += `
                        </div>
                    </div>
                `;
                    }

                    searchResults.innerHTML = html;
                }

                // Sélection d'un élément de recherche
                function selectSearchItem(title) {
                    const item = searchIndex.find(i => i.title === title);
                    if (item) {
                        // Afficher le contenu complet dans une modale ou nouvelle section
                        showItemDetail(item);
                    }
                }

                // Afficher les détails d'un élément
                function showItemDetail(item) {
                    // Créer une modale pour afficher le contenu complet
                    const modal = document.createElement('div');
                    modal.className = 'search-detail-modal';
                    modal.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%);
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(255,255,255,0.2);
                    border-radius: 8px;
                    padding: 30px;
                    max-width: 800px;
                    max-height: 80vh;
                    overflow-y: auto;
                    z-index: 10000;
                    color: white;
                `;

                    modal.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: var(--text-secondary);">${item.title}</h3>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer;">×</button>
                    </div>
                    <div style="white-space: pre-line; line-height: 1.6;">${item.fullContent}</div>
                    <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                    ${item.tags.map(tag => `<span style="background: rgba(77,163,255,0.2); padding: 5px 10px; border-radius: 12px; font-size: 0.8rem;">${tag}</span>`).join('')}
                    </div>
                `;

                    document.body.appendChild(modal);

                    // Fermer en cliquant à l'extérieur
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                }

                // Noms d'affichage des catégories
                function getCategoryDisplayName(category) {
                    const names = {
                        'programme': ' Programme',
                        'probabilistes': ' Modèles Probabilistes',
                        'machinelearning': ' Machine Learning',
                        'clustering': ' Clustering',
                        'simulation': ' Simulation',
                        'matrice': ' Matrice',
                        'analyse': ' Analyse',
                        'evaluation': ' Évaluation',
                        'technologies': ' Technologies'
                    };
                    return names[category] || category;
                }

                // Initialiser la recherche au chargement
                document.addEventListener('DOMContentLoaded', initSearch);
            </script>

            
            <!-- Boutons dans le HTML -->
            <class="floating-top-button" id="floatingSommaireButton">
            <button class="floating-top-button" id="floatingOngletButton"> ⇧ </button>

            <script>
                // Script universel simplifié
                document.addEventListener('DOMContentLoaded', function () {
                    const buttons = {
                        sommaire: {
                            element: document.getElementById('floatingSommaireButton'),
                            target: 'table-matières',
                            threshold: 300
                        },
                        onglet: {
                            element: document.getElementById('floatingOngletButton'),
                            target: null, // Haut de page
                            threshold: 500
                        }
                    };

                    // Gérer le défilement
                    window.addEventListener('scroll', function () {
                        const scrollY = window.scrollY;

                        Object.values(buttons).forEach(button => {
                            if (scrollY > button.threshold) {
                                button.element.classList.add('visible');
                            } else {
                                button.element.classList.remove('visible');
                            }
                        });
                    });

                    // Gérer les clics
                    Object.values(buttons).forEach(button => {
                        button.element.addEventListener('click', function () {
                            if (button.target) {
                                document.getElementById(button.target)?.scrollIntoView({ behavior: 'smooth' });
                            } else {
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }
                        });
                    });
                });

                function colorizeJavaScript(code) {
                    return code
                        // Commentaires
                        .replace(/(\/\/.*$)/gm, '<span class="code-comment">$1</span>')
                        
                        // Strings
                        .replace(/(".*?"|'.*?')/g, '<span class="code-string">$1</span>')
                        
                        // Numbers
                        .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                        
                        // Keywords
                        .replace(/\b(const|let|var|function|return|if|else|for|while|class|export|import|default)\b/g, 
                                '<span class="code-keyword">$1</span>')
                        
                        // Properties (avant les :)
                        .replace(/(\w+)(?=\s*:)/g, '<span class="code-property">$1</span>')
                        
                        // Operators
                        .replace(/([{}()[\]=+,])/g, '<span class="code-operator">$1</span>');
                }

        </script>
</body>

</html>
